# Web

>  웹 개발 관련 전반적인 지식



[toc]

## 1. 웹 개념





### 1.1. 웹 서비스 아키텍처



![was](https://gmlwjd9405.github.io/images/web/web-service-architecture.png)

WS 웹 서버

- HTTP 기반으로 클라이언트의 요청을 서비스(응답)한다고 하여 Server라고 함
  - **정적 컨텐츠 제공**: WAS를 거치지 않고 제공
  - 동적 컨텐츠 제공을 위한 요청 전달: WAS에 요청하여 응답을 클라이언트에 전송
- 하드웨어
  - 웹 서버가 설치되어 있는 **컴퓨터**
- 소프트웨어
  - 웹 서버 기능을 제공하는 컴퓨터 프로그램
  - 어플리케이션 종류: **Apache**, Nginx, IIS 등



WAS 웹 어플리케이션 서버

- 서버단에서 필요한 기능(DB 조회 및 다양한 로직 처리)을 수행하고 **동적인 컨텐츠를 제공**
  - 웹 서버에 지나치게 부하가 가해지는 것을 막기 위해 도입
  - 웹 서버를 앞단에 두고(클라이언트 쪽) WAS들을 웹 서버에 플러그인 형태로 설정하는 것이 가능
- 웹 컨테이너(or 서블릿 컨테이너) 라고도 불림
  - **서블릿**
    - 동적으로 클라이언트의 요청을 처리하여 응답하는 웹 어플리케이션(CGI)
    - Common Gateway Interface : 사용자의 입력을 받아 동적인 HTML문서를 만드는 것
    - 서블릿은 자바로 만든 CGI임 : Java Servlet Class의 구현 규칙을 지킨 프로그램
  - 컨테이너
    - 소프트웨어 서비스를 실행하는 데 필요한 패키지
    - 특정 버전의 프로그래밍 언어 런타임 및 라이브러리와 같은 종속 항목 + 애플리케이션 코드
  - 서블릿 컨테이너
    - 서블릿이 작동하는 환경을 제공해 줌
    - 서블릿의 생명주기 관리 : 서블릿 로드-언로드, URL Mapping, 요청-응답 객체 생성 및 관리 수행
    - 멀티 쓰레드 지원 및 관리 : 요청이 올 때마다 쓰레드를 생성하고 서비스 실행 후 자동으로 kill
    - 보안 관리
- WAS 이용의 메리트
  - 자원 이용의 효율성 : 단순한 정적 컨텐츠는 웹 서버에게 맡기고 나머지를 WAS가 처리해 부하 경감
  - 장애 극복 
    - Fail Over : 여러 WAS를 연결하여 하나가 중지되어도 다른 WAS가 작업 수행
    - Fail Back : 작동이 중지된 WAS를 재가동
  - 보안 강화 : SSL 암복호화 처리는 웹 서버에게 맡김으로써 공격을 받더라도 WAS는 안전하게
  - **Load Balancing**
  - 배포 및 유지 보수의 편의성  : 다른 종류의 WAS를 이용해 PHP, Java 어플리케이션을 각각 실행 가능
- 종류: Tomcat, JBoss(Wildfly) 등



빌드란?

- 소스코드 파일을 컴퓨터에서 실행할 수 있는 독립적인 형태로 변환하는 과정 및 그 결과
  - 예) `.java` 파일을 컴파일하여 `.class`로 바꾸고 정적 resource 들을 클래스 파일이 참조할 수 있는 위치로 옮기면서 `META-INF`와 `MENIFEST.MF`들을 압축한 뒤 배포함
  - 위 과정의 개별적인 작업을 **Task**라 하고, 빌드 대상에 대한 Task의 집합이 Build가 됨
- 빌드 단계(Task의 종류)
  - 전처리(preprocessing)
    - 컴파일 단계 이전에 `#include`나 `#define` 과같은 매크로를 먼저 바꾸어주는 작업
  - 컴파일(Compile)
    - 소스코드를 바이너리 코드로 변환하는 과정
    - 자바에서는 JVM이 실행할 수 있는 파일인 `.class`를 생성하는 것
  - 패키징(packaging)
    - 프로젝트의 모든 파일을 유저에게 전송할 수 있도록 묶는 것
    - 좁은 의미로 패키징만을 빌드라고 하기도 함
    - META-INF 폴더는 **jar파일** 생성시 일종의 사용설명서인 manifest 파일을 담기위한 디렉터리
    - JAR(Java Archive) : 어플리케이션 전체를 한 번에 다운로드할 수 있도록 묶은 파일. 자바 클래스 파일, 리소스, 메타 데이터를 묶은 압축 파일로 zip 파일 포맷으로 이루어짐
  - 테스팅(testing)
  - 배포
    - deploy : **war**형태로 웹 서버에 올림
    - distribution : exe나 jar파일로 만들어서 사용자에게 직접 전달



WAR이란?

- Web Application Archive
  - JAR 파일의 일종으로 **웹어플리케이션 전체를 패키징**하기 위한 파일임
  - 웹 관련 자원만 포함하고 있음
- WEB-INF 및 META-INF 디렉토리로 **사전 정의 된 구조를 사용함**
  - JAR는 원하는 구성이 가능함
- WAR파일을 실행하려면 Tomcat, Weblogic, Websphere 등의 웹 서버 또는 웹 컨테이너(WAS)가 필요함



빌드 관리 도구(Java 기준)

- 프로젝트 생성, 테스트 빌드, 배포 등의 작업을 위한 전용 프로그램
  - 빌드의 많은 반복작업들을 자동화해 줌
  - java 코드와 프로젝트에 필요한 xml, properties 파일들을 JVM이나 WAS가 인식할 수 있도록 패키징
- Maven
  - **고정적이고 선형적인 단계의 모델**을 기반으로 함
  - 빌드 중인 프로젝트, 빌드 순서, 다양한 외부 라이브러리 종속성 관계를 pom.xml파일에 명시함
  - 외부저장소에서 필요한 라이브러리와 플러그인들을 다운로드 하여 로컬시스템의 캐시에 모두 저장함
    - 예) Maven Repository에서 Spring Boot Data JPA Starter 모듈을 검색, xml 파일에 추가해 사용
  - 멀티 프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 상속을 받아야 함
- Gradle
  - **작업 의존성 그래프**를 기반으로 함
  - Groovy 언어를 사용한 Domain-specific-language를 사용 : xml 파일을 사용하지 않음
  - 프로젝트 업데이트 사항을 빌드에 계속 추가할 수 있으며 이미 반영된 부분은 재실행되지 않아 빠름
    - 빌드 규모가 커질 수록 **Maven 대비 빠름**
  - 설정 주입 방식을 사용함
  - 커스터마이징이 간편하고, concurrent에 안전한 캐시를 사용함



웹팩

- 웹팩은 **모듈 번들러**(module bundler)임
  - 프로젝트의 구조를 분석하고 자원들을 브라우저에서 이용할 수 있는 번들로 묶는 것
  - 여기서 모듈은 일반적으로 말하는 것과 다름
    - 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보는 것
- 등장 배경
  - 최근의 웹 어플리케이션이 다양한 기능을 가지며 복잡한 JS와 대규모 의존성 트리를 포함하게 됨
  - 이러한 복잡성에 대응하기 위해 파일 단위로 변수를 관리, 자바스크립트를 모듈화 함
  - 그러나 이를 브라우저가 이해할 수 있도록 묶고 변환해야 했기 때문에 이를 해 주는 웹팩이 등장
- 설치 및 사용
  - npm을 이용, 전역으로 설치하거나 특정 트로젝트의 의존성으로 설치할 수 있음
- 빌드 도구와의 차이점
  - Grunt, Gulp 같은 빌드 툴은 정의한 경로에서 구성과 일치하는 파일을 찾고 이러한 파일을 변환, 조합 및 축소(minify)하는 작업이나 단계를 지정해야 함
  - 웹팩은 프로젝트 전체를 한 단위로 분석(지정한 메인 파일에서 require와 import 문을 참고해 프로젝트의 모든 의존성을 조사), 로더를 이용해 처리한 후 번들로 묶은 자바스크립트 파일을 생성함



모듈 vs 컴포넌트

- 공통점 : 전체 시스템을 분해시켜 구성하는 부분을 나타냄
- 모듈
  - 가장 첫 번째 그리고 가장 맨 앞에 위치하는 **구현의 단위**
    - 실질적으로 구현이 되어 있음
    - 자료구조나 알고리즘 등을 제공하는 인터페이스로, 비슷한 기능들을 모아 만든 **하나의 파일**임
  - 구현 단위와 산출물을 제안하는 반면 매체의 전달과 런타임에 일어나는 일은 강조하지 않음
- 컴포넌트
  - **런타임 엔티티를 참조하는 단위**
    - 예) 하나의 서버가 10개의 클라이언트에게 정보를 전달할 때 모듈은 2개, 컴포넌트는 11개가 됨
  - 독립적으로 배포될 수 있는 단위로, 써드 파티로부터의 **결합 대상**이 됨
- 모듈과 컴포넌트는 상위-하위 관계가 아니라 다른 개념임
  - 모듈은 하나의 컴포넌트 또는 여러 개의 컴포넌트로 표현될 수 있고, 컴포넌트도 마찬가지로 하나의 모듈 또는 여러 개의 모듈로 표현될 수 있음
  - 모듈이 모여 컴포넌트가 될 수도 있고 그 역도 가능함



플러그인 vs 라이브러리 vs 프레임워크

- 플러그인은 특정한 문제를 해결하기 위한 컴포넌트
  - 예) jQuery의 Slider, Modal
- 라이브러리는 비슷한 성격을 가진 플러그인의 집합
  - 특정 기능이나 함수들을 모은 것으로 모듈이라고 부르기도 함
  - 예) jQuery, React
- 프레임워크는 소프트웨어 개발의 뼈대를 제공하는 클래스, 인터페이스의 집합
  - 전체 흐름을 제공하며 개발자는 그 안에 필요한 코드를 작성함
  - 프레임워크에는 **제어의 역전**이 제공되어 있음



### 1.2. 디자인 패턴

> 소프트웨어 개발 방법론



소프트웨어 디자인 패턴이란?

- 특정 문맥에서 **공통적으로 발생하는 문제에 대해 재사용 가능한 해결책**
  - “바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)”
  - 예) DB에 접속할 때 사용할 클래스를(DAO) 미리 만들어두고 재사용
  - 다른 상황에 맞게 사용될 수 있는 문제들을 해결하는데에 쓰이는 서술이나 템플릿
  - 소스나 기계 코드로 바로 전환될수 있는 완성된 디자인은 아님: 방법론이니까
- 어플리케이션이나 시스템을 디자인할 때 공통된 문제들을 해결하는데에 쓰이는 **형식화 된 가장 좋은 관행**



디자인 패턴의 구조

- Context
  - 문제가 발생하는 상황
- Problem
  - 해결될 필요가 있는 디자인 상의 이슈들
  - 여러 제약 사항과 영향이 함께 고려되어야 함
- Solution
  - 문제를 해결하게끔 설계를 구성하는 요소들과 해당 요소들 간의 책임/협력 관계를 기술함
  - 구현 방법이나 언어에 의존적이지 않은 해결 "방법"으로 템플릿이라 볼 수 있음



#### MVC 패턴



![서블릿](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99DD12385B7C37F30D)

MVC 패턴이란?

- 어플리케이션을 Model, View, Controller 세 가지의 역할로 구분한 디자인 패턴
- Model
  - 데이터와 비즈니스 로직을 관리
  - 일반적으로 데이터베이스 테이블에 대응됨
- View
  - 레이아웃과 화면을 처리
  - 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너
- Controller
  - 명령을 모델과 뷰 부분으로 라우팅
  - 사용자가 접근 한 URL에 따라서 사용자의 요청사항을 파악
  - 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영해서 사용자에게 응답



MVC 패턴의 요소

- DAO(Data Access Object) : 데이터 접근 객체
  - JDBC 등을 이용하여 **DB에 쿼리를 전달하여 CRUD를 실행**하는 객체
    - 예) Connection 객체
  - DAO 내부의 메서드는 전부 DB에 관련된 작업을 수행함
- Service
  - 사용자가 요청한 작업을 처리하는 과정을 하나의 작업으로 묶은 것
    - 요청이 CRUD 작업의 조합을 필요로 하는 경우, 여러 dao를 service 안에 조립하는 로직을 가짐
  - Controller에게 호출되어 실제 **비즈니스 로직을 처리**
    - DAO를 호출해 DB 작업 처리 후 결과를 Controller로 반환함
- DTO(Data Transfer Object) : 데이터 전송 객체
  - 전달되는 데이터 그 자체 : DB의 **테이블(entity) 클래스로부터 생성된 인스턴스**
  - DAO의 메서드는 DTO를 대입하거나 반환함
  - Bean(Spring에서는 이렇게 부름)이나 VO(Value Object)라고도 함
- Servlet
  - 클라이언트의 요청을 받아 적절한 service method를 호출함
    - 요청 내용과 커넥션 정보 등을 내장 객체 형태로 가지고 있음(`HttpServletRequest` 등)
  - 서비스가 처리한 결과를 이용해 동적으로 클라이언트에게(View에게) 화면을 뿌려줌
    - **java안에 html 코드**를 작성할 수있게 고안되었음
    - 여기서 발생하는 불편함을 개선하기 위해 역으로 html 안에 java를 넣는 JSP가 고안됨
- JSP(Java Server Pages)
  - **html안에 java코드**가 들어가게 만든것
    - 사용자가 볼 HTML 화면에 데이터를 binding하여 View로 전달함
    - 자바코드를 `<% %>`를 이용해서 태그처럼 사용할 수 있음
  - 서버의 역할도 수행함
    - 간편하게 웹 프로그래밍을 구현할 수 있음 : 자바 코딩없이 태그만으로 간략히 기술이 가능
    - Servlet을 사용하지않고 JSP만을 사용해서 동적 웹 서비스를 하는 **model 1**이 탄생



model 1

![model1](https://media.vlpt.us/images/junhok82/post/cc7f73b2-82e1-4e28-b373-f51abbad0388/image.png)

- JSP와 Model을 거쳐서 클라이언트와 서버가 통신하는 단순한 구조
  - JSP가 서버이자 화면을 구성하는 view 역할을 함
- 다음과 같은 문제점이 있음
  - JSP에 java코드와 html 코드가 섞여있어서 가독성에 문제가 있음
  - 위의 이유로 프론트와 백엔드간의 분업이 모호함
  - 유지보수에 어려움이 있음
- 이를 개선하기 위해 등장한 것이 MVC 패턴
  - JSP를 보존하면서, java 코드로 이루어져있어 서버통신과 용이한 Servlet을 이용



MVC 패턴의 장단점

- 장점
  - 화면과 비지니스 로직을 분리해서 분업에 용이함
  - 영역별 개발로인해 확장성이 뛰어남
  - 표준화된 코드를 이용하기때문에 협업에 유리함
  - 유지보수가 용이함
- 단점
  - 구조가 복잡하여 초기 개발속도가 느림
  - 초보자가 이해하고 개발하기 다소 어려움



### 1.3. 웹 어플리케이션



**SSR, CSR, SPA, MPA**

- 웹 브라우저가 문서를 어떻게 가져올 것인가? [그림 설명](https://medium.com/%EC%95%84%EB%AA%BD%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/csr-ssr-spa-mpa-ede7b55c5f6f)
- SSR(Server Side Rendering)
  - 서버에서 view페이지를 렌더링해서 가져오고 브라우저는 이를 보여주기만 함
  - 매번 새로 렌더링하니 **느리고 서버에 부담**
  - CSR보다 **SEO가 뛰어나다**는 장점이 있음
- CSR(Client Side Rendering)
  - 서버에서 html, js등을 다운받은 후 클라이언트가(브라우저에서) 렌더링
- SPA(Single Page Application)
  - 서버에서 **처음 1회만 페이지를 받아오고** 이후에는 **동적으로 DOM을 구성하여** 렌더링 되는 화면이 바뀌게 함
    - SPA는 어플리케이션이고 CSR은 렌더링 방식으로 SPA구현을 위해 CSR이 사용됨
  - 사용자 경험(UX) 향상을 위해 도입
    - 예) 좋아요 버튼을 누를 때마다 페이지 새로고침이 되지 않도록
  - SPA를 만드는 데 최적화된 라이브러리로 React.js, Next.js 등이 있음
- MPA(Multi Page Application)
  - 서버로부터 완전한 페이지를 받아오고 수정/조회시 다른 완전한 페이지로 이동
  - 동적이지 않은 페이지를 상황에 맞게 클라이언트에 뿌려줌
- SEO(Search Engine Optimization)
  - 검색엔진에 잘 노출될 수 있도록 **웹사이트를 각 엔진이 잘 읽을 수 있게끔** 최적화
  - 첫번째 페이지는 SSR로, 이후에는 CSR을 이용하면 속도와 SEO를 다 잡을 수 있음



### 1.4. API



API란?

- Application Programming Interface : **응용프로그램에서 사용**할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 **인터페이스**
- 특징
  - 구현과는 독립적으로, **사양만 정의**되어 있음
  - API에 따라서 접근권한이 필요할 수도 있음
- 예시
  - 구글 지도 API: 어플리케이션에서 지도를 직접 구현하지 않고도 구글 지도의 기능을 이용할 수 있게 함
    - `map/위도&경도` 의 양식으로 request를 보내면 정보를 보내줌
  - 유튜브 API: 웹 커뮤니티에서 유튜브 동영상을 보여줄 수 있도록 함



**API의 개발**

- Model First 모델 우선 개발 방식
  - 레거시 API 어플리케이션을 이용할 때 유용함
    - 기존 클래스의 멤버마다 문서화가 잘 되어있다면 request/response 객체와 관련된 설계 문서를 작성하기 용이하기 때문
- Design First 설계 우선 개발 방식(스펙 주도 개발, SDD)
  - 설계를 먼저 하고 스펙을 확정한 후 FE의 피드백을 받아 실제 구현에 들어감
    - 설계 → 시뮬레이션 → 확인 및 피드백 → 스펙 확정
    - 기존에는 구현까지 한 다음 피드백을 받아서 그 동안 FE는 업무가 불가능했다는 단점이 있음
  - 새롭게 API를 구현하는 경우에 유용함
    - 시간과 비용 문제 때문에 설계를 먼저 해야 함
  - 구현도 안 됐는데 시뮬레이션을 어떻게 하냐? **API 목킹**을 이용함



**API 목킹** [설명](https://www.soapui.org/learn/mocking/what-is-api-mocking/)

- 목킹이란? 어떠한 기능이 있는 것처럼 흉내내어 구현한 것
  - Mocking은 필수적인 기능 일부가 작동하는 것
  - Stubbing은 기능 없이 자리만 차지하는 것 
  - API 목킹은 구현할 API의 스펙을 대략적으로 만족시켜서 시뮬레이션 가능하게 한 것
    - 설명 좀 더 자세하게 할 수 없냐?
    - 차후  보강.....
- 대표적으로 사용되는 도구
  - MuleSoft API Manager
    - RAML를 이용하여 목킹이 용이함
  - Azure API Management
    - 테스트와 실제상황에서 동일한 URL을 사용 가능
    - 개별 API 엔드포인트별로 세세하게 목킹을 설정 가능
    - 비쌈
  - AWS API Gateway
    - 목킹이 어렵지만 세세하게 목킹 설정 가능



### 1.5. REST



REST란?

- REpresentational State Transfer: 웹의 장점을 활용하며 범용성을 보장한 **네트워크 아키텍처**
- 구성
  - 자원(URI), 행위(HTTP method), 표현(JSON, XML, txt)
  - 웹에 존재하는 모든 자원에 **URI**를 부여
  -  **HTTP method**를 통해 해당 자원에 대한 CRUD operation을 적용
  - 결과를 **JSON으로** 표현함



URI vs URL vs URN

- Uniform Resource **Identifier** : 하나의 **자원을 식별하는 문자열**
  - RFC-3986이라고 하는 URI 설계원칙을 따름
- Uniform Resource **Locator** : 자원의 위치를 나타내며 URI에 포함되는 개념임
  - URI가 자원의 식별자라면 URL은 자원이 "어디에 위치하는지"까지만 나타냄
  - 웹 뿐만 아니라 네트워크상의 모든 자원을 나타낼 수 있음 : 일반적으로는 사이트 도메인을 의미함
- Uniform Resource **Name** : 위치 관계 없이 해당 자원을 식별하는 것으로 URI에 포함되는 개념
  - 



URI 설계 원칙

- 가독성 관련
  - 하이픈을 사용하고, 언더바는 사용하지 않음
  - URI 경로로는 소문자를 사용함
  - 서브 도메인은 일관성 있게 사용 : 앞에 api를 붙이거나 dev를 붙이는 등
  - 명사에는 복수형을 이용, 특히 컬렉션에는 복수형을 사용
  - 컨트롤러 이름으로는 동사, 동사구를 사용
- 취약점 관련
  - 파일 확장자는 포함하지 않음
  - 프로그래밍 언어에 의존적인 확장자(`.py`) 및 구현에 의존적인 경로를 사용하지 않음(`Servelet` 등)
  - 세션 ID를 포함하지 않음
  - 메서드 이름을 포함하지 않음
- 식별성 관련
  - 슬래시 구분자로 계층 관계를 나타냄, 마지막 문자로 슬래시는 사용하지 않음
  - 변화하는 값(path variable)을 유일한 값으로 대체함
  - CRUD기능을 나타내는 것은 사용하지 않음
  - 쿼리 부분으로 컬렉션 결과를 필터링할 수 있고, 페이지로 구분하여 나누는 데 사용함



REST의 6가지 [특징](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)

- Client-Server Architecture
  - 클라이언트 - 서버 구조를 가질 것
  - 각각 독립적으로 확장 가능할 것
- Stateless
  - 클라이언트의 context를 서버에 유지하지 않고 **메시지로만 요청 처리**
  - 데이터 전체를 전달하지 않고 메세지만 전달 : 클라이언트와 서버를 독립적으로 확장하기 위해서
- Cacheable
  - HTTP가 가진 [**캐싱 기능**](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)을 적용
- Layered System
  - 서버와 클라이언트 사이를 다양한 계층 형태로 구성 : 방화벽, 게이트웨이, proxy 등
  - 클라이언트는 REST API만 호출
- Uniform Interface
  - 인터페이스 일관성을 지키면서(URI 조작을 HTTP method로 통일) 아키텍처는 단순화된 작은 단위로 분리
  - 클라이언트와 서버를 독립적으로 개선하기 위함
- Self-descriptiveness
  - **메시지만 보고도 요청하는 데이터가 어떻게 처리되어야 하는지 이해**할 수 있어야 함
  - HTTP method, 헤더 정보, URI 정보로 표현



REST API란?

- RESTful하게 설계된 API
  - REST 6가지 특징들을 잘 갖춘 API를 REST API라고 함
  - 구글맵 API의 경우 HTTP method로 요청을 보내 JSON으로 정보를 받는 REST API임

- 장점
  - 이해하기 쉬움(self-descriptiveness)
  - 모든 플랫폼 사용 가능함(서버와 클라이언트가 같은 방식을 사용해서 요청해야)
  - 별도의 인프라 구축 필요 없음
- 단점
  - 메서드가 제한적임(HTTP)



**RAML이란?**

- RESTful API Modeling Language
  - API를 설계하기 위해 만들어진 **API description format**의 하나
  - Mulesoft가 2013년에 개발했으며 **YAML** 형식으로 정의됨
- API 모델링 언어의 종류 [차후보강](https://www.educba.com/raml-vs-swagger/)
  - Swagger
    - OpenAPI사양을 구현하기 위해 가장 널리 사용되는 도구
  - RAML
  - API Blueprint
    - MIT 오픈소스로 마크다운 문법도 지원하는 것이 특징

 

**데이터 전송 포맷**

![format](https://cdn.inflearn.com/public/comments/0180f16f-cc83-4e69-aa80-c2b9c357f1f2/ymal%20%EB%B9%84%EA%B5%90.JPG)

- XML
  - 태그를 통해 Key와 Value를 구분
    - 태그 안에 태그를 넣어 부모-자식 관계도 표현 가능
  - 장황하다는 단점 존재
- JSON
  - 괄호를 통해 Key와 Value를 구분
    - Object일 경우 중괄호, Array일 경우 대괄호를 이용
  - 주석 기능이 없고 문법이 엄격하다는 단점 존재
- YAML
  - Indenting을 활용하여 가독성을 높임
    - indenting이 깨지면 안되기 때문에 XML이나 JSON과 달리 minify하지 않음
    - Array는 하이픈을 활용해 표현
    - 주석 처리 가능, 상속 관계 존재
  - 설정 파일에 많이 사용되고 최근 사용이 권장되고 있음(Spring, Kubernates 등)





#### UI, UX

- UI
  - 사용자가 앱을 사용할 때 마주하는 디자인, 레이아웃, 기술적 부분
  - 사용할 때 불편함이 없어야 함
- UX
  - 사용자 경험을 분석하여 편하고 효율적으로 진행되도록 하는 것
  - UI가 포장이라면 UX는 내용물



#### 네이티브 앱 vs 웹 앱 vs 하이브리드 앱

- 네이티브 앱
  - 모바일 OS(안드로이드, iOS)에 최적화된 어어로 개발된 앱
  - OS 자체의 기능을 사용하여 성능이 높고 사용성이 좋음
  - **네이티브 API**를 호출하여 플랫폼과 밀착됨
- 하이브리드 앱
  - 앱의 특정 부분의 브라우저를 올려서 HTML을 불러옴
  - 수정하기 좋지만 네트워크에 종속되어 느릴 수 있음
- 모바일 웹
  - 데스크탑 웹 애플리케이션의 사이즈만 줄인 것
- 웹 앱
  - 모바일 웹과 네이티브 앱을 결합한 것
  - SPA를 활용하여 속도가 빠름
  - 따로 설치할 필요 없으나 브라우저 API만 사용가능함







#### 기타

**웹에서 사용하는 이미지**

- 이미지의 분류
  - 비트맵 이미지
    - 픽셀이 모여 만들어진 정보의 집합
    - 그림판, 포토샵 등으로 편집 가능
    - 확대 축소 시 계단 현상 발생
    - `.jpg`, `.gif`, `.png` 파일
  - 벡터 이미지
    - 수학적 정보의 형태(좌표, 색상 등)들이 만들어 내는 결과물
    - 해상도로부터 자유롭게 렌더링 가능하나 연산이 많이 필요
    - 일러스트 등으로 편집 가능
    - `.svg` 파일
- 이미지 파일 종류
  - JPG
    - 손실 압축 방식: 여러 번 저장 시 디지털 풍화 발생
    - 압축률이 뛰어나고 표현 색상 뛰어남(24bit)
    - **가장 많이 쓰이는 형식**으로, 이미지의 품질과 용량을 쉽게 조절할 수 있음
  - PNG
    - 비손실 압축
    - 8bit 또는 24bit 컬러 이미지 처리
    - **투명도 지원**, W3C 권장 포맷임
  - GIF
    - 비손실 압축
    - 여러 장의 이미지를 한 파일에 담을 수 있음: 움짤
    - 8bit 컬러만 지원
  - WEBP: 구글에서 개발한 포맷
    - 손실/비손실 압축 지원
    - 애니메이션, 투명도 지원
    - 그러나 사용할 수 있는 브라우저가 한정적
  - SVG
    - 벡터 그래픽을 표현하는 포맷
    - 마크업 언어 기반: **코딩 가능**!
    - CSS로 스타일링 가능, JS로 이벤트 핸들링 가능



호스팅

- 대형 **서버의 기능을 빌려쓰는** 것
- 종류: 웹 호스팅, 서버 호스팅, 클라우드 호스팅
  - 웹호스팅: 하나의 서버 장비를 여러 명이 공유하여 사용
  - 서버호스팅: 한명의 고객이 하나의 서버장비를 임대
    - 고정적으로 트래픽 양이 많은 사이트에 적합
  - 클라우드호스팅: **가상서버를 임대**하고 **이용한만큼 지불**



## **DB**



###  JDBC

> OJT에서 JDBC를 이용해 postgresql을  어떻게 조작했는지



DB 서버 연결하기



CRUD 만들기



Insert에서 문제 발생

- 배경
  - 마지막으로 로그인한 시간을 담는 필드의 타입이 TIMESTAMP로 정의되었기 때문에, 시간을 String으로 받아 이를 다시 타임스탬프로 변환한 뒤 PreparedStatement를 이용하여 데이터를 추가하려고 했으나, **구문 에러 발생**
- 원인
  - 정확히 `executeUpdate();`에서 에러가 발생함
- 해결

```java
String logDate = "2021-03-19 00:00:00";
Timestamp LAST_LOG = Timestamp.valueOf(logDate);

String url = "jdbc:postgresql://localhost/postgres";
String sql = "INSERT INTO TABLE VALUES (?)";

Class.forName("org.postgresql.Driver");
Connection con = DriverManager.getConnection(url, "postgres", "password");
PreparedStatement st = con.prepareStatement(sql);

st.setTimestamp(1, LAST_LOG);

st.executeUpdate();

st.close();
con.close();
```



## **주요 질문**

