# Web

>  웹 개발 전반적인 지식



[toc]



**웹이란?**

- 인터넷상에서 **문서들**을 **연결**하여(HyperText) 정보 검색을 빠르게 할 수 있게 한 것
  - 웹사이트는 복수의 웹페이지(HTML 파일)로 구성됨
  - 문서의 레이아웃 및 디자인은 스타일 시트로 정의되며 **CSS**언어로 기술됨
- 구체적으로는 클라이언트-서버 간 **HTTP 프로토콜을 사용하여 HTML을 주고받는 시스템**
  - HTTP 프로토콜: 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜
    - HTTP 파일전송은 **Request**와 **Response**를 주고받으며 이루어짐
    - Request
      - 요청라인 + 메시지 헤더 + (공백) + entity 바디
      - 리퀘스트 라인: **HTTP method** + URL + version
        - HTTP method: GET, POST, PUT, PATCH, DELETE 등
        - version은 그냥 HTTP의 버전을 나타냄
      - 메시지 헤더는 웹브라우저 종류/버전, 대응하는 데이터 타입 등을 기술
      - entity 바디는 **POST에서 데이터를 담아 보낼 때** 사용
    - Response
      - 상태라인(status) + 메시지 헤더 + (공백) + entity 바디
      - 리스폰스 라인: 버전 + 상태 코드 + 설명문
        - [Response Code](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)
        - 설명문은 상태 코드의 의미를 간단히 보여줌
      - entity 바디에는 브라우저에 돌려보낼 데이터 포함: 주로 HTML
  - HTTP 특징: **비연결성, 무상태**
    - 비연결성: 리소스를 아끼기 위해 비연결성을 띔
      - 잦은 연결/해제는 오버헤드를 초래함
    - 무상태: 비연결성으로 인해 클라이언트를 식별할 수 없는 것
      - **쿠키/세션/토큰**을 이용하여 기억함



**웹 브라우저란?**

- **웹 기반 컨텐츠**(웹페이지)를 검색 및 열람하기 위한 어플리케이션

  - 서버에서 **컴포넌트 파일**(코드 파일 + 자원)을 가져옴
  - 코드 파일: HTML, CSS, JavaScript
  - 자원: 웹사이트를 만드는 모든 다른 것들 - 이미지, 음악, PDF 등

- 구성: UI - 브라우저 엔진 - 렌더링 엔진, 통신, JS해석기, 임시파일저장소

  ![ㅇ](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)

- 렌더링 동작 과정

  - html가져옴 - **DOM트리 작성** - CSSOM트리 작성 - 2개 결합해 렌더트리 생성
    - DOM트리는 HTML태그들의 계층관계를 나타낸 것
    - 문서객체모델(DOM)에서 모든 HTML 태그는 객체로 취급
    - JS를 통해 페이지를 조작할 때 객체를 사용함
  - 객체들에게 위치,크기 지정(레이아웃) - CSS속성 적용 - 화면 업데이트
  - 도중에 JS를 발견하면 JS엔진 실행했다가 다시 DOM 생성함



**웹 서버 vs WAS(Web Application Server)**

- [추후 보강](https://gyoogle.dev/blog/web-knowledge/Web%20Server%EC%99%80%20WAS%EC%9D%98%20%EC%B0%A8%EC%9D%B4.html)
- 웹 서버
  - 기능: HTTP 기반으로 클라이언트의 요청을 서비스
    - **정적 컨텐츠 제공**: WAS를 거치지 않고 제공
    - 동적 컨텐츠 제공을 위한 요청 전달: WAS에 요청하여 응답을 클라이언트에 전송
  - 어플리케이션 종류: **Apache**, Nginx, IIS 등
- WAS
  - 기능: 서버단에서 필요한 기능(DB 조회 및 다양한 로직 처리)을 수행하고 **동적인 컨텐츠를 제공**
    - 웹 서버에 지나치게 부하가 가해지는 것을 막기 위해 도입
    - 웹 서버를 앞단에 두고(클라이언트 쪽) WAS들을 웹 서버에 플러그인 형태로 설정하는 것이 가능
  - 종류: Tomcat, JBoss 등



**웹에서 사용하는 이미지**

- 이미지의 분류
  - 비트맵 이미지
    - 픽셀이 모여 만들어진 정보의 집합
    - 그림판, 포토샵 등으로 편집 가능
    - 확대 축소 시 계단 현상 발생
    - `.jpg`, `.gif`, `.png` 파일
  - 벡터 이미지
    - 수학적 정보의 형태(좌표, 색상 등)들이 만들어 내는 결과물
    - 해상도로부터 자유롭게 렌더링 가능하나 연산이 많이 필요
    - 일러스트 등으로 편집 가능
    - `.svg` 파일
- 이미지 파일 종류
  - JPG
    - 손실 압축 방식: 여러 번 저장 시 디지털 풍화 발생
    - 압축률이 뛰어나고 표현 색상 뛰어남(24bit)
    - **가장 많이 쓰이는 형식**으로, 이미지의 품질과 용량을 쉽게 조절할 수 있음
  - PNG
    - 비손실 압축
    - 8bit 또는 24bit 컬러 이미지 처리
    - **투명도 지원**, W3C 권장 포맷임
  - GIF
    - 비손실 압축
    - 여러 장의 이미지를 한 파일에 담을 수 있음: 움짤
    - 8bit 컬러만 지원
  - WEBP: 구글에서 개발한 포맷
    - 손실/비손실 압축 지원
    - 애니메이션, 투명도 지원
    - 그러나 사용할 수 있는 브라우저가 한정적
  - SVG
    - 벡터 그래픽을 표현하는 포맷
    - 마크업 언어 기반: **코딩 가능**!
    - CSS로 스타일링 가능, JS로 이벤트 핸들링 가능



**쿠키, 캐시, 세션, 토큰**

- 쿠키와 캐시의 [차이](https://zorba91.tistory.com/163)
  - 쿠키는 **사용자 인증**을 위해 사용됨
    - 키-값의 데이터 파일, **웹서버에서 PC로 **보내주는 파일 저장
    - 웹사이트 접속시 발생, 유출돼도 큰 일 없을 정보들(로그인 정보, 열람 이력)
    - 만료기간이 있어 자동 삭제됨
  - 캐시는 **웹페이지를 빠르게 렌더링**하기 위해 사용됨
    - 웹페이지요소(Response), 그림파일 등
    - 수동 삭제 필요, 캐시가 너무 많이 쌓이면 브라우저 속도 저하됨
- 세션
  - 사이트와 브라우저 사이의 상태를 유지시킴. 
    - 연결 그 자체를 세션이라 하기도 하고 통신을 마칠 때까지의 기간을 뜻하기도 함
  - 클라이언트는 세션 아이디(클라이언트 식별자)를 **쿠키**를 이용해 저장
  - **세션 자체는 서버에 저장**
    - 서버의 메모리를 차지하고 과부하의 원인이 됨
- 토큰
  - 쿠키와 세션의 문제점을 보완한 **본인 확인 수단**
  - 보호할 데이터를 토큰으로 치환하여 원본 대신 토큰을 이용함
  - **추후 보강**





**SSR, CSR, SPA, MPA**

- 웹 브라우저가 문서를 어떻게 가져올 것인가? [그림 설명](https://medium.com/%EC%95%84%EB%AA%BD%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/csr-ssr-spa-mpa-ede7b55c5f6f)
- SSR(Server Side Rendering)
  - 서버에서 view페이지를 렌더링해서 가져오고 브라우저는 이를 보여주기만 함
  - 매번 새로 렌더링하니 **느리고 서버에 부담**
  - CSR보다 **SEO가 뛰어나다**는 장점이 있음
- CSR(Client Side Rendering)
  - 서버에서 html, js등을 다운받은 후 클라이언트가(브라우저에서) 렌더링
- SPA(Single Page Application)
  - 서버에서 **처음 1회만 페이지를 받아오고** 이후에는 **동적으로 DOM을 구성하여** 렌더링 되는 화면이 바뀌게 함
    - SPA는 어플리케이션이고 CSR은 렌더링 방식으로 SPA구현을 위해 CSR이 사용됨
  - 사용자 경험(UX) 향상을 위해 도입
    - 좋아요 버튼을 누를 때마다 페이지 새로고침이 되지 않도록
  - SPA를 만드는 데 최적화된 라이브러리로 React.js, Next.js 등이 있음
- MPA(Multi Page Application)
  - 서버로부터 완전한 페이지를 받아오고 수정/조회시 다른 완전한 페이지로 이동
  - 동적이지 않은 페이지를 상황에 맞게 클라이언트에 뿌려줌
- SEO(Search Engine Optimization)
  - 검색엔진에 잘 노출될 수 있도록 **웹사이트를 각 엔진이 잘 읽을 수 있게끔** 최적화
  - 첫번째 페이지는 SSR로, 이후에는 CSR을 이용하면 속도와 SEO를 다 잡을 수 있음



### API

**API란?**

- Application Programming Interface
- 응용프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
- 특징
  - 구현과는 독립적으로, 사양만 정의되어 있음
  - API에 따라서 접근권한이 필요할 수도 있음
- 예시
  - 구글 지도 API: 어플리케이션에서 지도를 직접 구현하지 않고도 구글 지도의 기능을 이용할 수 있게 함
    - `map/위도&경도` 의 양식으로 request를 보내면 정보를 보내줌
  - 유튜브 API: 웹 커뮤니티에서 유튜브 동영상을 보여줄 수 있도록 함



**REST API란?**

- REST란?
  - REpresentational State Transfer: 웹의 장점을 활용하며 범용성을 보장한 아키텍처
  - 구성
    - 자원(URI), 행위(HTTP method), 표현(JSON, XML, txt)
    - 웹에 존재하는 모든 자원에 **URI**를 부여하고, **HTTP method**를 통해 해당 자원에 대한 CRUD operation을 적용한 결과를 JSON으로 표현
      - URI(Uniform Resource Identifier): 하나의 자원을 가리키는 문자열
      - URL이라고도 하는데 URI가 정식 표현이다
  - [특징](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)
    - Uniform Interface: URI에 대한 조작은 HTTP method로 통일
    - Stateless: 클라이언트의 context를 서버에 유지하지 않고 메시지로만 요청 처리
    - Cacheable: [HTTP가 가진 **캐싱 기능**](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)을 적용
    - Self-descriptiveness: REST API메시지만 보고도 이해 가능
    - Client-Server Architecture
    - Layered System: 클라이언트는 REST API만 호출하며 REST서버는 다중 계층으로 구성
- REST API란?
  - RESTful하게 설계된 API
    - 위의 구글맵 API의 경우 HTTP method로 요청을 보내 JSON으로 정보를 받는 REST API임
- 장점
  - 이해하기 쉬움(self-descriptiveness)
  - 모든 플랫폼 사용 가능함(서버와 클라이언트가 같은 방식을 사용해서 요청해야)
  - 별도의 인프라 구축 필요 없음
- 단점
  - 메서드가 제한적임(HTTP)



**RAML이란?**

- RESTful API Modeling Language
  - API를 설계하기 위해 만들어진 **API description format**의 하나
  - Mulesoft가 2013년에 개발했으며 **YAML** 형식으로 정의됨
- API 모델링 언어의 종류 [차후보강](https://www.educba.com/raml-vs-swagger/)
  - Swagger
    - OpenAPI사양을 구현하기 위해 가장 널리 사용되는 도구
  - RAML
  - API Blueprint
    - MIT 오픈소스로 마크다운 문법도 지원하는 것이 특징

 

**데이터 전송 포맷**

![format](https://cdn.inflearn.com/public/comments/0180f16f-cc83-4e69-aa80-c2b9c357f1f2/ymal%20%EB%B9%84%EA%B5%90.JPG)

- XML
  - 태그를 통해 Key와 Value를 구분
    - 태그 안에 태그를 넣어 부모-자식 관계도 표현 가능
  - 장황하다는 단점 존재
- JSON
  - 괄호를 통해 Key와 Value를 구분
    - Object일 경우 중괄호, Array일 경우 대괄호를 이용
  - 주석 기능이 없고 문법이 엄격하다는 단점 존재
- YAML
  - Indenting을 활용하여 가독성을 높임
    - indenting이 깨지면 안되기 때문에 XML이나 JSON과 달리 minify하지 않음
    - Array는 하이픈을 활용해 표현
    - 주석 처리 가능, 상속 관계 존재
  - 설정 파일에 많이 사용되고 최근 사용이 권장되고 있음(Spring, Kubernates 등)



**API의 개발**

- Model First 모델 우선 개발 방식
  - 레거시 API 어플리케이션을 이용할 때 유용함
    - 기존 클래스의 멤버마다 문서화가 잘 되어있다면 request/response 객체와 관련된 설계 문서를 작성하기 용이하기 때문
- Design First 설계 우선 개발 방식(스펙 주도 개발, SDD)
  - 설계를 먼저 하고 스펙을 확정한 후 FE의 피드백을 받아 실제 구현에 들어감
    - 설계 → 시뮬레이션 → 확인 및 피드백 → 스펙 확정
    - 기존에는 설계부터 구현까지 한 다음 피드백을 받아서 그 동안 FE는 업무가 불가능했다는 단점이 있음
  - 새롭게 API를 구현하는 경우에 유용함
    - 시간과 비용 문제 때문에 설계를 먼저 해야 함
  - 구현도 안 됐는데 시뮬레이션을 어떻게 하냐? **API 목킹**을 이용함



**API 목킹** [설명](https://www.soapui.org/learn/mocking/what-is-api-mocking/)

- 목킹이란? 어떠한 기능이 있는 것처럼 흉내내어 구현한 것
  - Mocking은 필수적인 기능 일부가 작동하는 것
  - Stubbing은 기능 없이 자리만 차지하는 것 
  - API 목킹은 구현할 API의 스펙을 대략적으로 만족시켜서 시뮬레이션 가능하게 한 것
    - 설명 좀 더 자세하게 할 수 없냐?
    - 차후  보강.....
- 대표적으로 사용되는 도구
  - MuleSoft API Manager
    - RAML를 이용하여 목킹이 용이함
  - Azure API Management
    - 테스트와 실제상황에서 동일한 URL을 사용 가능
    - 개별 API 엔드포인트별로 세세하게 목킹을 설정 가능
    - 비쌈
  - AWS API Gateway
    - 목킹이 어렵지만 세세하게 목킹 설정 가능





호스팅

- 대형 **서버의 기능을 빌려쓰는** 것
- 종류: 웹 호스팅, 서버 호스팅, 클라우드 호스팅
  - 웹호스팅: 하나의 서버 장비를 여러 명이 공유하여 사용
  - 서버호스팅: 한명의 고객이 하나의 서버장비를 임대
    - 고정적으로 트래픽 양이 많은 사이트에 적합
  - 클라우드호스팅: **가상서버를 임대**하고 **이용한만큼 지불**



#### 토큰

> 본인 확인 수단: 쿠키와 세션의 문제점을 보완함
>
> 보호할 데이터를 토큰으로 치환, 원본 대신 토큰을 이용함

- 요청 토큰: 소비자가 사용자에게 접근권한을 인증받기 위해 필요한 정보
- 접근 토큰: 인증 후에 사용자가 소비자를 통해 보호 자원에 접근하기 위한 키 값
- CSRF 토큰
  - 랜덤한 수를 사용자 세션에 저장하고, 요청 페이지에 CSRF 토큰을 담아 전송함
  - CSRF는 서버를 공격, XSS는 클라이언트를 공격



#### UI, UX

- UI
  - 사용자가 앱을 사용할 때 마주하는 디자인, 레이아웃, 기술적 부분
  - 사용할 때 불편함이 없어야 함
- UX
  - 사용자 경험을 분석하여 편하고 효율적으로 진행되도록 하는 것
  - UI가 포장이라면 UX는 내용물



#### 네이티브 앱 vs 웹 앱 vs 하이브리드 앱

- 네이티브 앱
  - 모바일 OS(안드로이드, iOS)에 최적화된 어어로 개발된 앱
  - OS 자체의 기능을 사용하여 성능이 높고 사용성이 좋음
  - **네이티브 API**를 호출하여 플랫폼과 밀착됨
- 하이브리드 앱
  - 앱의 특정 부분의 브라우저를 올려서 HTML을 불러옴
  - 수정하기 좋지만 네트워크에 종속되어 느릴 수 있음
- 모바일 웹
  - 데스크탑 웹 애플리케이션의 사이즈만 줄인 것
- 웹 앱
  - 모바일 웹과 네이티브 앱을 결합한 것
  - SPA를 활용하여 속도가 빠름
  - 따로 설치할 필요 없으나 브라우저 API만 사용가능함



### 0.1. 디자인 패턴

> 소프트웨어 개발 방법론



소프트웨어 디자인 패턴이란?

- 특정 문맥에서 **공통적으로 발생하는 문제에 대해 재사용 가능한 해결책**
  - “바퀴를 다시 발명하지 마라(Don’t reinvent the wheel)”
  - 예) DB에 접속할 때 사용할 클래스를(DAO) 미리 만들어두고 재사용
  - 다른 상황에 맞게 사용될 수 있는 문제들을 해결하는데에 쓰이는 서술이나 템플릿
  - 소스나 기계 코드로 바로 전환될수 있는 완성된 디자인은 아님: 방법론이니까
- 어플리케이션이나 시스템을 디자인할 때 공통된 문제들을 해결하는데에 쓰이는 **형식화 된 가장 좋은 관행**



디자인 패턴의 구조

- Context
  - 문제가 발생하는 상황
- Problem
  - 해결될 필요가 있는 디자인 상의 이슈들
  - 여러 제약 사항과 영향이 함께 고려되어야 함
- Solution
  - 문제를 해결하게끔 설계를 구성하는 요소들과 해당 요소들 간의 책임/협력 관계를 기술함
  - 구현 방법이나 언어에 의존적이지 않은 해결 "방법"으로 템플릿이라 볼 수 있음



디자인 패턴의 종류

- 생성 패턴
- 구조 패턴
- 행위 패턴





#### MVC 패턴



![서블릿](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99DD12385B7C37F30D)

- DTO
  - 전달되는 데이터
  - 실제로는 전달할 데이터의 클래스로부터(entity) 생성된 인스턴스가 전달된다 
- DAO
  - DB와 연결하여 직접적으로 통신하는 클래스
- Servlet
- JSP





## 클라우드



개념 설명



IaaS vs PaaS vs SaaS



IaaS



PaaS



SaaS