# OOP



참고자료

- 이것이 자바다
- fastcamp 한번에 끝내는 Java/Spring 웹 개발 마스터 패키지
- Softbank 신입사원 OJT



[TOC]

## **1. OOP 개론**



객체란?

- 사전적 의미 : 의사나 행위가 미치는 대상
- 구체적, 추상적 데이터의 단위



객체 지향 프로그래밍 vs 절차 지향 프로그래밍

- 객체 지향 프로그래밍
  - **객체 사이의 interaction에 따라 프로그래밍**
    - 학생 객체 - 세면대 객체 - 밥 객체 - 버스 객체들 간에 상호작용
    - 객체의 정의 -> 각 객체가 제공하는 기능 구현 -> 메세지 전달을 통해 상호작용 구현
- 절차 지향 프로그래밍
  - **시간이나 사건 흐름에 따라 프로그래밍**
  - 일어난다 - 씻는다 - 밥먹는다 - 버스 탄다
- 절차 지향의 구현이 쉬워보이나 프로그램이 복잡해지면 객체 지향이 훨씬 간단



객체와 클래스

- 클래스는 객체의 blueprint다
  - 각 객체가 가지는 속성을 클래스의 **멤버 변수**로 선언함
  - 프로그램을 짜기 전에 필요한 객체들을 정의하고, 각각을 클래스로 설계함
    - 클래스를 만든다는 것은 **추상화 작업**
    - 학생 클래스, 주문 클래스, 회원 클래스...
- 클래스 코딩
  - 클래스 이름은 PascalCase
    - 멤버 변수와 메서드는 camelCase
  - 하나의 java 파일에는 하나의 public 클래스가 있어야 하며 파일명과 클래스명이 동일해야 함



함수와 메서드

- 함수란?

  - **하나의 기능을 수행**하는 일련의 코드

  - 정의된 함수는 **호출하여 사용하고, 기능이 끝나면 제어가 반환됨**

    - 함수는 여러 곳에서 동일한 방식으로 호출되어 사용될 수 있음
    - 함수가 호출되면 **스택**에 함수가 사용할 메모리 공간이 생성되고, 지역 변수가 저장됨
    - 함수가 끝나면 메모리 공간이 해제되면서 반환되는 것

  - 함수의 정의: 반환 값 + 이름 + 매개 변수 + 함수 몸체

    - ```java
      int add(int num1, int num2){
          int result;
          result = num1 + num2;
          return result;
      }
      ```

- 메서드란?

  - 객체의 기능을 구현하기 위해 **클래스 내부에 구현되는 함수**
    - 멤버 변수를 매개 변수로 사용하여 멤버 함수라고 하기도 함
  - 메서드 이름은 객체에 맞춰서 지음
    - 예) `getStudentName()` 



인스턴스

- **특정 클래스 기반으로 생성된 객체**를 클래스의 인스턴스라고 함
  - 인스턴스는 해당 클래스의 멤버 변수, 메서드를 사용할 수 있음
  - 생성은 `new 생성자()`로 함
- 생성된 인스턴스는 **heap에 할당됨**
  - 하나의 클래스는 여러 인스턴스를 생성할 수 있는데, 각각 다른 메모리 주소를 가리키기 위해 힙 사용
  - 사용되지 않는 인스턴스는 GC가 자동으로 메모리에서 해제함
  - 메모리에 생성된 인스턴스를 가리키는 변수를 **참조 변수**, 해당 메모리 주소 값을 **참조 값**이라 함



생성자

- 어떤 클래스에서 **인스턴스를 생성하는 함수**를 생성자라고 함

  - 클래스에는 반드시 하나 이상의 생성자가 있고, 구현하지 않으면 컴파일러가 **기본 생성자**를 넣음
    - 생성자가 있는데 기본 생성자를 호출하면 에러: 만들어줘야 함
  - 기본 생성자는 매개 변수가 없고 그냥 인스턴스를 선언만 함: 나중에 값을 넣어줘야 함
    - 초기화는 되어 있는데 기본 값으로 되어 있음(int면 0)
    - 지역 변수는 선언만 하면 초기화되지 않지만 멤버변수는 생성되면 초기화는 됨

- 생성자 만들기

  - **this**의 이해

    - this는 인스턴스 자신의 메모리를 가리킴

      1. 생성자는 파라미터로 들어온 값을 이용해 인스턴스를 만든다
      2. 그런데 일반적으로 파라미터는 멤버 변수와 이름을 동일하게 지음
      3. `studentNumber = studentNumber`와 같은 상황이 발생
      4. this를 붙여서 "이" 인스턴스의 멤버변수에 파라미터 studentNumber를 대입한다는 의미를 부여
      5. `this.studentNumber = studentNumber`

    - 생성자 내에서 또 다른 생성자를 호출할 때 사용

    - 자신의 주소를 반환할 때 사용

      - ```java
        public Person getPerson(){
            return this;
        }
        ```

  - 생성자 **오버로딩**

    - **메서드는 같고 매개변수가 다른 것**을 오버로딩이라 함
    - 클라이언트 코드(생성자를 호출하는 코드)에서 여러 생성자 중 필요에 따라 호출할 수 있음



참조 자료형 변수

- 변수의 자료형은 다음과 같이 분류됨
  - 기본 자료형(int, long, float, double) 등: 메모리 크기가 정해져 있는 타입
  - 참조 자료형(String, Date, UserClass): 클래스에 따라 메모리 크기가 다름
    - 참조 자료형을 사용할 때는 해당 변수에 대해 객체를 생성해야 함(String 제외)
- 참조 자료형 변수의 사용
  - **하나의 클래스에 정보가 너무 많이 들어가지 않도록** 클래스를 분리하여 해당 클래스의 객체를 사용
  - 예) 학생의 과목별 성적: 학생 클래스 + 성적 클래스로 분리하고 학생이 성적 객체(의 배열)을 가짐



접근 제어 지시자

- **클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지** 지정하는 키워드
  - default: 지정하지 않으면 디폴트로 같은 패키지에서만 접근 가능
  - public: 어디에서나 접근 가능
  - private: 같은 클래스 내부에서만 접근 가능
  - protected: 같은 패키지나 상속관계의 클래스에서 접근 가능
- 접근 제어 지시자는 왜 필요한가? **정보 은닉**
  - 최소한의 정보를 오픈함으로써 객체의 오류를 방지
  - private으로 제어한 멤버 변수는 public method(get, set)를 통해 접근을 제한하여 최소한의 정보를 오픈
    - 예) month의 값이 1부터 12 사이일 때만 set 가능하게 함
- 멤버 변수를 사용하는 방법 **get, set**
  - private으로 제어된 멤버 변수에 대해 접근/수정할 수 있는 public method



캡슐화

- 정보 은닉을 활용하여 **꼭 필요한 정보와 기능만 외부에 오픈하는 것**을 말함
  - 대부분의 멤버 변수와 메서드를 감추고 외부에 통합된 인터페이스만 공개하여 일관된 기능을 제공함
  - 메서드와 멤버 변수에 접근할 때 발생하는 오류를 최소화



객체 협력 collaboration

- 객체 간에 필요한 메세지를 전송하고 처리하는 것
  - 예) 학생 객체가 버스 객체에 탑승하여 버슷 객체의 승객 수가 변화
- 매개 변수로 객체가 전달될 수 있음



### 1.1. Static



static 변수

![static](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-16/img/mem.png)

- 여러 인스턴스에서 **공통으로 사용하는 변수**
  - 여러 인스턴스가 공유하는 기준 값이 필요한 경우 사용
  - 예) 학번, 카드 번호, 사원 번호 등
  - 프로그램이 메모리에 로딩될 때 Data(Static)영역에 할당됨
- static변수 선언과 사용
  - `static int serialNum;`
  - 클래스 변수, 정적 변수라고도 함
    - 클래스 이름으로 직접 참조 `Student.serialNum = 100;`
    - 인스턴스 이름으로도 참조할 수 있긴 한데 권장하진 않음



static 메서드

- 인스턴스 생성과 무관하게 클래스 이름으로 호출 가능함
  - **static 메서드 내부에서는 멤버 변수 사용이 불가능**하게 되어 있음
  - 인스턴스 생성 전에 static 메서드가 호출될 수 있기 때문



변수의 Scope와 메모리

![scope](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-17/img/variable.png)

- 멤버 변수는 적게 하는 것이 좋음
  - 너무 많으면 인스턴스 생성 시 메모리를 많이 차지
  - 너무 적어도 문제인데, 필요할 때마다 인자로 전달해야해서 복잡해짐
- static 변수에 큰 자료형은 피하는 것이 좋음
  - 배열 등 메모리를 많이 먹는 자료형이 계속 메모리를 점유하고 있으면 안 됨



static의 활용: Singleton Pattern

- 디자인 패턴이란?
  - 어떤 방식으로 OOP에 적합하고 효율적이고 재사용이 용이하게 코딩할 것인지 정리한 것
  - 23가지 종류가 있음
- 싱글톤 패턴이란?
  - 프로그램 내에서 **인스턴스가 단 한 개만 생성되어야 하는 경우** 사용하는 디자인 패턴
  - static 변수와 메서드를 활용하여 구현
  - 회사-사원 등 1:N 관계를 갖는 객체를 구현할 때 좋음
- 싱글톤 패턴의 구현
  - 인스턴스를 1개만 만들 수 있도록 **생성자를 private으로 만들어야 함**
  - 생성자 구현 안 하면 default constructor가 생기는데 이건 public이라 까먹지 말고 구현해야됨



클래스 다이어그램

*cf) UML notation?*

![클래스 다이어그램](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-18/img/singleton.png)

- 맨 위는 클래스 이름
  - 아래는 순서대로 변수, 생성자, 메서드
- `-`는 private이라는 뜻, `+`는 public이라는 뜻



## **2. OOP 핵심**

> 클래스 간의 관계, 인터페이스를 어떻게 설계할 것인가?
>
> 객체 지향이 왜 유지보수에 좋은지?



### 2.1. 상속



상속이란?

- 다른 클래스의 기능(메서드), 속성을 받아서 확장하는 것을 상속이라 함
- A클래스를 B클래스가 상속받는다면
  - `class B extends A { ... }`
  - A를 상위 클래스(super class), B를 하위 클래스(subclass)라고 함
  - 상위 클래스는 단 하나만 존재할 수 있음
    - **모호성**을 방지하기 위함: Java는 초기부터 안정성, 심플함을 추구했기 때문
  - 상위 클래스가 하위 클래스보다 일반적인 개념과 기능을 가짐 



상속 클래스 생성

- private과 protected
  - 외부에서는 참조 못하지만 상속받은 하위 클래스에서는 참조할 수 있도록 protected를 이용함
- `super()`
  - 하위 클래스에서 **상위 클래스의 기본 생성자를 호출**함
    - 생성자를 작성하지 않으면 컴파일러가 기본 생성자를 만들듯이 하위 클래스의 생성자에는 자동으로 super()가 들어감
    - 이 때 상위 클래스에는 반드시 기본 생성자가 존재해야 하고, 기본 생성자 없이 다른 생성자만 있다면 하위 클래스에서 super()를 이용해 명시적으로 상위 클래스의 생성자를 호출해야 함
    - super()를 이용해 상위 클래스의 메서드 및 멤버 변수에 접근 가능
- 상속이 일어날 때 메모리의 상태
  - 힙 메모리에 상위 클래스의 인스턴스가 생기고 그 밑에 하위 클래스의 속성이 추가됨
  - ![상속 메모리](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter3/3-03/img/memory.png)
- 상속과 **형 변환**
  - 상위 클래스로 변수를 선언하고 하위 클래스 생성자로 인스턴스 생성이 가능함
    - `Customer vc = new VIPCustomer();`
    - 이걸 업캐스팅이라고 하며, 역은 성립하지 않음(모든 Customer가 VIPCustomer는 아니므로)
    - **업캐스팅**한 다음 다시 자기 클래스로 형 변환 가능한데, 이는 **다운 캐스팅**이라 함
    - 물론 업캐스팅한 인스턴스는 **하위 클래스의 속성과 메서드 사용 불가**함



#### Overriding

- **재정의** 라는 뜻 : 상위 클래스에서 구현된 코드를 하위 클래스에서 재정의 하는 것
  - 메서드나 생성자에 대해서 가능
  - 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우
  - 이클립스에서 우클릭 > Source > Override로 구현 가능
- Annotation
  - 오버라이딩한 메서드 위에는`@Override`가 붙음
  - 컴파일러에게 정보를 주는 위 표기법을 annotation이라 함

**가상 메서드**

- 인스턴스를 업캐스팅하고 오버라이딩된 메서드를 호출하면 **하위 클래스의 메서드가 호출됨**
  - 왜? **자바의 모든 메서드는 가상 메서드**로, 항상 인스턴스의 메서드가 호출되기 때문
  - 업캐스팅하는 경우 변수 vc의 타입은 Customer이지만 인스턴스의 타입은 VIPCustomer임

- 가상 메서드 원리
  - ![가상 메서드](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter3/3-05/img/virtual.png)
  - 메서드는 Code영역에 저장되고, 메서드의 이름은 그 주소값을 나타냄
  - 각 클래스는 **가상 메서드 테이블**(자신이 갖는 메서드의 주소 테이블)을 가짐
  - 하위 클래스로 생성된 인스턴스는 오버라이딩된 메서드의 주소를 갖기 때문에, 업캐스팅을 하더라도 하위 클래스의 메서드를 호출함



#### 다형성

다형성이란?

- 같은 코드에서 여러 다른 결과가 나오는 것
  - 하나의 코드가 여러 자료형으로 구현되어 실행
  - 예제에서 animal.move()가 
- 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나
- 다형성을 잘 활용하면 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있음
  - 다형성을 쓰지 않으면 코드 확장을 할 때 if-else문을 계속 추가해야 함