# Java



참고자료

- 이것이 자바다
- fastcamp 한번에 끝내는 Java/Spring 웹 개발 마스터 패키지
- Softbank 신입사원 OJT



[TOC]

## **1. 자바 기초**

> 자바 관련 개념 및 기초 문법



### 1.1. 자바란?



자바의 특징

- 안정적임
  - 시스템 메모리를 건드려 다운될 수 있는 C와 달리 안정적인 언어의 필요성에 의해 개발됨
- 플랫폼에 영향을 받지 않음
  - OS에 따라 다른 컴파일러와 실행 파일을 갖는 C와 달리 가상머신([JVM](#6.7. JVM)) 상에서 돌아가기 때문에 플랫폼에 독립적
- **객체 지향 언어**임



객체 지향이란?

- Object Oriented Programming
- **객체**간의 관계와 협력을 기반으로 프로그래밍 하는 것
  - 현실의 사물을 객체로 모델링: **속성과 행위**를 정의해 사물이 동작하는 방식대로 프로그래밍
  - **절차 지향**(procedural prigramming)은 함수를 활용해 시간 순으로 프로그래밍하는 방식
- 장점
  - 재사용성, 유지보수, 코드 관리, 고신뢰성
- 단점
  - 실행속도 느림, 개발속도 느림(객체 설계에 시간이 소요), 코드의 복잡성



자바가 주로 사용되는 곳

- 웹 서버 구현
- 안드로이드 프로그래밍



실행 환경 관련

- 패키지 이름은 소문자로만
  - 프로젝트랑 클래스는 PascalCase
- 클래스 실행
  - 저장하면 자동으로 빌드가 되어 class 파일이 생성됨 -> 실행되는 것은 class 파일



### 1.2. 변수와 자료형



변수란?

- 변화하는 수: 변화하는 값을 나타낼 때 필요함
- 표현하려는 수에 맞는 데이터 타입을 이용하여 변수를 **선언**



변수의 선언

- **자료형** + 변수명으로 선언
- 변수명은 다음의 규칙을 따라야 함
  - 숫자로 시작하면 안됨
    - 숫자는 애초에 안 넣는 것이 좋음
  - 자바의 reserved word를 사용하면 안 됨(while 등)
  - 가독성 좋게: camelCase를 준수



자료형

- 변수는 선언될 때 해당하는 **자료형의 크기만큼 메모리가 할당됨**
- 종류
  - 정수
    - byte, short, int(기본)
    - long: 선언하고 숫자 뒤에 **L을 붙임**
  - 실수
    - float : 선언하고 숫자 뒤에 **F를 붙임**
    - double: 실수는 기본적으로 double
  - 문자
    - char: 문자열과는 다르다!
    - **문자는 `'A'`로 선언**하고 문자열은 `"A"`로 선언함



상수

- 변하지 않는 수
  - 변하지 않는 값을 반복하여 사용할 때
  - 값을 변경할 수 없기 때문에 **초기화를 해주지 않으면 오류 발생**
  - 수 뿐만 아니라 클래스와 객체도 상수로 지정 가능
    - 이러한 참조 변수가 상수인 경우에는 메모리의 주소값이 변하지 않음
    - **주소가 가리키는 데이터들이 변하지 않는 것은 아님**
- final 예약어를 이용하여 선언
- 대문자와 언더바를 이용하여 이름을 선언함
  - `final MATH_PI;`



리터럴

- 값이 변하지 않는 데이터: 프로그램에서 사용하는 숫자, 문자, 논리 **값**
  - 정수 리터럴은 int, 실수 리터럴은 double, 문자열 리터럴은 String으로 저장됨
- 리터럴은 **상수 풀 constant pool**에 존재함
  - 프로그램이 실행되자마자 메모리에 올라와서 종료될 때까지 존재함
  - **Runtime Constant Pool**
    - String, Integer, Double 등의 reference type을 리터럴로 생성할 때 constant pool에 저장됨
    - constant pool은 heap 위에 있으나 조금씩 다를 수 있음
    - 자세한 것은 [String 클래스](#String-클래스) 참고



형변환

- 서로 다른 자료형 간의 연산 등을 하기 위해 하나의 자료형으로 **통일**하는 것
- 묵시적(자동) 형 변환
  - 바이트 크기가 **작은 자료형에서 큰 자료형으로 형 변환은 자동**으로 이루어짐
  - 덜 정밀한 자료형(정수)에서 더 정밀한 자료형(실수)으로 형 변환은 자동으로 이루어짐
  - double에서 int로 형 변환하면 소숫점 아래 부분은 짤림(truncate)
- 명시적(강제) 형 변환
  - 변수 명 앞에 괄호 치고 타입을 써 주면 강제 형 변환



### 1.3. 연산자



항과 연산자

- 항(operand): 연산에 사용되는 값
- 연산자(operator): 항을 이용하여 연산하는 기호



대입 연산자

- 이항 연산자: 변수에 다른 변수나 값을 대입하는 연산자 `=`
- 왼쪽을 l value, 오른쪽을 r value라 하며 오른쪽엔 변수, 식, 값이 들어감
- 이항 연산자 중 **가장 우선순위가 낮음**
  - 오른쪽에서 모든 계산을 다 수행하고 마지막에 대입해야 하기 때문



부호 연산자

- 단항 연산자: 변수의 부호를 유지하거나(+) 바꿈(-)
- 변수의 내용물의 부호가 바뀌는 것은 아님: 그러려면 대입 연산자 사용해야 함 `num = -num;`



산술, 관계 연산자: pass



논리 연산자

- `&&` : and
- `||` : or
- `!` : not
- **short circuit evaluation**(단락 회로 평가)
  - &&에서 앞의 항이 false이면 뒤는 보지 않음(수행되지 않음)
  - ||에서 앞의 항이 true이면 뒤는 보지 않음



비트 연산자

- 마스크: 특정 비트를 가리고 몇 개의 비트 값만 사용할 때
  - 비트 켜기: 특정 비트들만 1로 설정해서 사용
    - 예) `&00001111` : 하위 4비트 중 1인 비트만 꺼내기
  - 비트 끄기: 특정 비트들만 0으로 설정해서 사용
    - 예) `|11110000` : 하위 4비트 중 0인 비트만 0으로 만들기
- 나머지 bit shift나 and, or not은 C와 동일



연산자 우선순위

- 일차식(괄호) → 단항 → 산술 →  비트 이동 → 관계 → 비트 → 논리 → 조건(3항) → 대입



### 1.4. 제어문



#### 조건문

if문 

 ```java
if(conditional statements) {
    statement1;
}
else if(conditional statements 2){
    statement2;
}
else{
    statement3;
}
 ```

위처럼 **한 줄만 쓸 때는 중괄호를 쓰지 않아도 됨** (들여쓰기 해서 나쁠 것 없으니 웬만하면 쓰자)



switch-case 문

- 전통적인 방식

  - ```java
    int day;
    switch(month) {
    	case 1: case 3: case 5: case 7: case 8: case 10: case 12: 
    		day = 31;
    		break;
    	case 2: day = 28;
    		break;
    	case 4: case 6: case 9: case 11: 
    		day = 30;
    		break;
    	default:
    		System.out.println("존재하지 않음");
    		day = -1;
    }
    ```

- yield 키워드를 사용한 새로운 방식

  - ```java
    int day = switch(month){
            case 1, 3, 5, 7, 8, 10, 12 ->
                yield 31;
            case 4, 6, 9, 11 ->
                yield 30;
            case 2 ->
                yield 28;
            default -> {
                System.out.println("존재하지 않음")
                yield -1;
            }
    };
    //마지막 세미콜론에 주의
    ```

  - Java 14부터 사용 가능



#### 반복문

for문

```java
for(초기화; 조건문; 증감식){
    statement;
}
```

- 초기화, 조건문, 증감식 안에 여러 식이 들어갈 수 있음
  - 세미콜론으로 구분하여 넣으면 됨
  - `for(int i = 0, int count = 0; i < 10; i++, count++)` 이런 식으로
- 초기화식, 조건식, 증감식은 각각 생략 가능함
  - 모두 생략 시 무한 루프 	



while, do-while, for문 의 비교

- while은 조건의 결과나 변수가 true, false인 경우에 주로 사용
  - 수행문을 먼저 할지 나중에 할지에 따라 while, do-while 중 무엇을 할지 결정할 것
- for는 특정 수의 범위나 횟수와 관련하여 반복되는 경우(배열 관련)에 주로 사용



## **2. OOP**



### 2.1. 객체와 클래스



객체란?

- 사전적 의미 : 의사나 행위가 미치는 대상
- **속성과 행위**를 갖는 구체적, 추상적 **데이터의 단위**
  - 물리 객체 : 실제 존재하는 사물을 모델링한 것
  - 개념 객체 : 비즈니스로직을 처리하는 부분
    - ATM 시스템에서 계좌(물리 객체)의 속성(잔고)를 변경하는 입-출금 처리
- 객체의 3가지 요소
  - 상태 유지
    - 객체는 속성을 변수로써 정의하여 저장하고 유지함
    - 속성값이 바뀜으로 인해 객체의 상태가 변경될 수 있어야 함
  - 기능 제공(method)
  - 고유 식별자 제공
    - 각 객체는 고유 식별자가 있어야 함 : DB에서는 PK로 표현됨



객체 지향 프로그래밍 vs 절차 지향 프로그래밍

- 객체 지향 프로그래밍
  - **객체 사이의 interaction에 따라 프로그래밍**
    - 객체의 정의 -> 각 객체가 제공하는 기능 구현 -> 메세지 전달을 통해 **상호작용 구현**
    - 비즈니스 로직을 처리하는 서비스에서 객체의 **메서드를 활용**하여 속성을 변경하는 작업이 주된 코딩
- 절차 지향 프로그래밍
  - **시간이나 사건 흐름에 따라 프로그래밍**
  - 일어난다 - 씻는다 - 밥먹는다 - 버스 탄다
- 절차 지향의 구현이 쉬워보이나 프로그램이 복잡해지면 객체 지향이 훨씬 간단



객체와 클래스

- **클래스는 객체의 blueprint**다
  - 각 객체가 가지는 속성을 클래스의 **멤버 변수**로 선언함
  - 프로그램을 짜기 전에 필요한 객체들을 정의하고, 각각을 클래스로 설계함
    - 클래스를 만든다는 것은 **추상화 작업**
    - 학생 클래스, 주문 클래스, 회원 클래스...
- 클래스 코딩
  - 클래스 이름은 PascalCase
    - 멤버 변수와 메서드는 camelCase
  - **하나의 java 파일에는 하나의 public 클래스가 있어야** 하며 파일명과 클래스명이 동일해야 함
    - 하나의 자바 파일 안에 클래스가 여러 개 들어갈 수 있지만 `public class` 는 하나 뿐



함수와 메서드

- 함수란?

  - **하나의 기능을 수행**하는 일련의 코드

  - 정의된 함수는 **호출하여 사용하고, 기능이 끝나면 제어가 반환됨**

    - 함수는 여러 곳에서 동일한 방식으로 호출되어 사용될 수 있음
    - 함수가 호출되면 **스택**에 함수가 사용할 메모리 공간이 생성되고, 지역 변수가 저장됨
    - 함수가 끝나면 메모리 공간이 해제되면서 반환

  - 함수의 정의: 반환 값 + 이름 + 매개 변수 + 함수 몸체

    - ```java
      int add(int num1, int num2){
          int result;
          result = num1 + num2;
          return result;
      }
      ```

- 메서드란?

  - 객체의 기능을 구현하기 위해 **클래스 내부에 구현되는 함수**
    - 멤버 변수를 매개 변수로 사용하여 멤버 함수라고 하기도 함
  - 메서드 이름은 객체에 맞춰서 지음
    - 예) `getStudentName()` 



인스턴스

- **특정 클래스 기반으로 생성된 객체**를 클래스의 인스턴스라고 함
  - 인스턴스는 해당 클래스의 멤버 변수, 메서드를 사용할 수 있음
  - 생성은 `new 생성자()`로 함
- 생성된 인스턴스는 **heap에 할당됨**
  - 하나의 클래스는 여러 인스턴스를 생성할 수 있는데, 각각 다른 메모리 주소를 가리키기 위해 힙 사용
  - 사용되지 않는 인스턴스는 GC가 자동으로 메모리에서 해제함
  - 메모리에 생성된 인스턴스를 가리키는 변수를 **참조 변수**, 해당 메모리 주소 값을 **참조 값**이라 함



생성자

- 어떤 클래스에서 **인스턴스를 생성하는 함수**를 생성자라고 함

  - 클래스에는 반드시 하나 이상의 생성자가 있고, 구현하지 않으면 컴파일러가 **기본 생성자**를 넣음
    - 생성자가 있는데 기본 생성자를 호출하면 에러: 만들어줘야 함
  - 기본 생성자는 매개 변수가 없고 그냥 인스턴스를 선언만 함: 나중에 값을 넣어줘야 함
    - 초기화는 되어 있는데 기본 값으로 되어 있음(int면 0): 지역 변수와 달리 **멤버변수는 생성되면 초기화는 됨**
  
- 생성자 만들기

  - **this**의 이해

    - this는 **인스턴스 자신의 메모리를 가리킴**

      1. 생성자는 파라미터로 들어온 값을 이용해 인스턴스를 만든다
      2. 그런데 일반적으로 파라미터는 멤버 변수와 이름을 동일하게 지음
      3. `studentNumber = studentNumber`와 같은 상황이 발생
      4. this를 붙여서 **"이"** 인스턴스의 멤버변수에 파라미터 studentNumber를 대입한다는 의미를 부여
      5. `this.studentNumber = studentNumber`

    - 생성자 내에서 또 다른 생성자를 호출할 때 사용

    - 자신의 주소를 반환할 때 사용

      - ```java
        public Person getPerson(){
            return this;
        }
        ```

  - 생성자 **오버로딩**

    - **메서드는 같고 매개변수가 다른 것**을 오버로딩이라 함
    - 클라이언트 코드(생성자를 호출하는 코드)에서 여러 생성자 중 필요에 따라 호출할 수 있음



참조 자료형 변수

- 변수의 자료형은 다음과 같이 분류됨
  - 기본 자료형(int, long, float, double) 등: 메모리 크기가 정해져 있는 타입
  - 참조 자료형(String, Date, UserClass): 클래스에 따라 메모리 크기가 다름
    - 참조 자료형을 사용할 때는 해당 변수에 대해 객체를 생성해야 함(String 제외)
- 참조 자료형 변수의 사용
  - **하나의 클래스에 정보가 너무 많이 들어가지 않도록** 클래스를 분리하여 해당 클래스의 객체를 사용
  - 예) 학생의 과목별 성적: 학생 클래스 + 성적 클래스로 분리하고 학생이 성적 객체(의 배열)을 가짐



객체 협력 collaboration

- 객체 간에 필요한 메세지를 전송하고 처리하는 것
  - 예) 학생 객체가 버스 객체에 탑승하여 버슷 객체의 승객 수가 변화
- **매개 변수로 객체가 전달**될 수 있음



static 변수란?

![static](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-16/img/mem.png)

- 여러 인스턴스에서 **공통으로 사용하는 변수**
  - 여러 인스턴스가 공유하는 기준 값이 필요한 경우 사용
  - 예) 학번, 카드 번호, 사원 번호 등
  - 프로그램이 메모리에 로딩될 때 Data(Static)영역에 할당됨
- 선언과 사용
  - `static int serialNum;`
  - 클래스 변수, 정적 변수라고도 함
    - **클래스 이름으로 직접 참조** `Student.serialNum = 100;`
    - 인스턴스 이름으로도 참조할 수 있긴 한데 권장하진 않음



static 메서드

- 인스턴스 생성과 무관하게 클래스 이름으로 호출 가능함
  - **static 메서드 내부에서는 멤버 변수 사용이 불가능**하게 되어 있음
  - 인스턴스 생성 전에 static 메서드가 호출될 수 있기 때문



변수의 Scope와 메모리

![scope](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-17/img/variable.png)

- 멤버 변수는 적게 하는 것이 좋음
  - 너무 많으면 인스턴스 생성 시 메모리를 많이 차지
  - 너무 적어도 문제인데, 필요할 때마다 인자로 전달해야해서 복잡해짐
- static 변수에 큰 자료형은 피하는 것이 좋음
  - 배열 등 메모리를 많이 먹는 자료형이 계속 메모리를 점유하고 있으면 안 됨



static의 활용: Singleton Pattern

- 디자인 패턴이란?
  - 어떤 방식으로 OOP에 적합하고 효율적이고 재사용이 용이하게 코딩할 것인지 정리한 것
  - 23가지 종류가 있음
- 싱글톤 패턴이란?
  - 프로그램 내에서 **인스턴스가 단 한 개만 생성되어야 하는 경우** 사용하는 디자인 패턴
  - static 변수와 메서드를 활용하여 구현
  - 회사-사원 등 1:N 관계를 갖는 객체를 구현할 때 좋음
- 싱글톤 패턴의 구현
  - 인스턴스를 1개만 만들 수 있도록 **생성자를 private으로 만들어야 함**
  - 생성자 구현 안 하면 default constructor가 생기는데 이건 public이라 까먹지 말고 구현해야됨



클래스 다이어그램

*cf) UML notation?*

![클래스 다이어그램](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-18/img/singleton.png)

- 맨 위는 클래스 이름
  - 아래는 순서대로 변수, 생성자, 메서드
- `-`는 private이라는 뜻, `+`는 public이라는 뜻



### 2.2. OOP 4대 특성

> 캡슐화, 상속, 다형성, 추상화



#### 캡슐화



캡슐화란?

- 변수와 함수를 하나의 단위로 묶는 것
  - 데이터의 번들링(Bundling)
  - 자바에서 번들링은 클래스를 통해 구현되고, 클래스의 인스턴스 생성을 통해 클래스 안에 포함된 멤버 변수와 메소드에 접근
- 캡슐화를 통해 객체의 속성을 보호: **정보 은닉**



정보은닉

- **꼭 필요한 정보와 기능만 외부에 오픈하는 것**
  - 프로그램(클래스)의 세부 구현을 외부로 드러나지 않도록 감춤
  - 대부분의 멤버 변수와 메서드를 감추고 외부에 통합된 인터페이스만 공개하여 일관된 기능을 제공함
  - 이는 **추상화**와도 연결됨
- 정보 은닉의 필요성
  - 메서드와 멤버 변수에 접근할 때 발생하는 **오류를 최소화**
  - 유연함과 유지보수성을 높임
    - 모듈 내에서의 **응집도**는 높이고
    - 모듈 간의 **결합도**는 떨어뜨림
- 정보 은닉을 위해 **접근 제어 지시자**가 사용됨



접근 제어 지시자

- **클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자를 사용할 수 있는지** 지정하는 키워드
  - default: 지정하지 않으면 디폴트로 같은 패키지에서만 접근 가능
  - public: 어디에서나 접근 가능
  - private: **같은 클래스 내부에서만** 접근 가능
  - protected: **같은 패키지나 상속관계의 클래스에서** 접근 가능
- private으로 제어한 멤버 변수 어떻게 접근하는가? **get, set**
  - private으로 제어된 멤버 변수에 대해 접근/수정할 수 있는 public method
    - 외부에서 직접 객체의 속성에 접근해 변경하는 것이 아니라 **객체가 제공하는 메서드**로 기능이 제공됨
    - **객체 안의 메서드는 객체 안의 속성을 처리해야 함**
  - 이를 통해 **객체의 무결성**을 확보함
    - public method는 입력된 매개변수를 validation한 후에 실행
    - 속성이 타당한지(예: 잔고가 있는지 확인 후 출금) 확인 후에 변경하기 때문에 무결성이 깨지지 않음
  - 예) month의 값이 1부터 12 사이일 때만 set 가능하게 함
- 접근 제어 지시자를 통해 **높은 재사용성**을 달성
  - 절차적 프로그래밍에서는 함수 재사용을 위해 전역변수 등을 다 체크해야 함
  - OOP에서는 메서드가 단일 객체에만 영향을 주기 때문에 재사용성이 높고, 유지보수의 효율성이 향상됨



응집도와 결합도

- 응집도
  - 하나의 모듈 내부에 존재하는 기능들의 관련성
  - 응집도가 높은 모듈은 **하나의 책임**에 집중하고 독립성이 높아져 유지보수에 용이함
- 결합도
  - 모듈(클래스) 간의 상호 의존성
  - 결합도가 높으면 코드 수정이 복잡해지므로 낮게 유지하는 것이 좋음



#### 상속

상속이란?

- 자식 클래스가 **부모 클래스의 특성과 기능(메서드)을 그대로 물려받아 확장하는 것**
  - 기능의 일부분을 변경해야 할 경우 '**오버라이딩(Overriding)**'을 함
  - 자식 클래스에서 상속받은 그 기능만을 수정해서 다시 정의하는 것
    - 상위 클래스가 하위 클래스보다 일반적인 개념과 기능을 가짐 
- 상속의 효과
  - 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 줌
    - 매번 해당 클래스의 속성 및 메서드를 정의하지 않고도 상속을 통해 사용
    - 유지보수성 확보 : 객체들이 공통된 메서드를 가지고 있어 수정이 용이함
  - 프로그램의 확장성
    - 일관된 형태의 클래스를 추가할 수 있음 : 유닛 클래스를 정의하여 새로운 유닛을 추가하는 등



상속 예시

- A클래스를 B클래스가 상속받는다면
  - `class B extends A { ... }`
  - A를 상위 클래스(super class), B를 하위 클래스(subclass)라고 함
  - **상위 클래스는 단 하나만 존재**할 수 있음
    - **모호성을 방지**하기 위함: Java는 초기부터 안정성, 심플함을 추구함
    - Diamond Problem 참조



상속은 언제 사용하는가?

- **Is-A 관계**
  - 일반적 개념 - 구체적 개념 (예: 고객 - 골드 고객)의 관계가 존재할 때 **상속함**
  - 하위 클래스에서 상위클래스에 구체적인 개념들을 더해 나감
  - 계층 구조가 복잡하거나 depth가 크면 좋지 않음
- Has-A 관계
  - 클래스가 다른 클래스를 포함 (예 : 학생이 과목을 포함)
  - 코드 재사용의 일반적인 방법임: 여기서는 **상속하지 않음**
  - 라이브러리를 구현할 때 ArrayList 생성하여 사용함



상속 클래스 생성

- private과 protected
  - 외부에서는 참조 못하지만 상속받은 하위 클래스에서는 참조할 수 있도록 protected를 이용함
- `super()`
  - 하위 클래스에서 **상위 클래스의 기본 생성자를 호출**함
    - 생성자를 작성하지 않으면 컴파일러가 기본 생성자를 만들듯이 하위 클래스의 생성자에는 자동으로 super()가 들어감
    - 이 때 상위 클래스에는 반드시 기본 생성자가 존재해야 하고, 기본 생성자 없이 다른 생성자만 있다면 하위 클래스에서 super()를 이용해 명시적으로 상위 클래스의 생성자를 호출해야 함
    - super()를 이용해 상위 클래스의 메서드 및 멤버 변수에 접근 가능
- 상속이 일어날 때 메모리의 상태
  - 힙 메모리에 상위 클래스의 인스턴스가 생기고 그 밑에 하위 클래스의 속성이 추가됨
  - ![상속 메모리](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter3/3-03/img/memory.png)
- 상속과 **형 변환**
  - 상위 클래스로 변수를 선언하고 하위 클래스 생성자로 인스턴스 생성이 가능함
    - `Customer vc = new VIPCustomer();`
    - 이걸 업캐스팅이라고 하며, 역은 성립하지 않음(모든 Customer가 VIPCustomer는 아니므로)
    - **업캐스팅**한 다음 다시 자기 클래스로 형 변환 가능한데, 이는 **다운 캐스팅**이라 함
    - 물론 업캐스팅한 인스턴스는 **하위 클래스의 속성과 메서드 사용 불가**함



다운캐스팅

- 업캐스팅된 인스턴스를 다시 **원래의 타입으로** 형 변환 하는 것

  - 업캐스팅은 Implicit하게 변환되지만 다운캐스팅은 명시적으로(explicit) 해야 함

  - ```java
    Customer vc = new VIPCustomer();              //묵시적
    VIPCustomer vCustomer = (VIPCustomer)vc;      //명시적
    ```

  - 당연한 얘기지만 VIPCustomer를 Customer로 업캐스팅한 뒤 GoldCustomer로 다운 캐스팅은 불가

- `instanceof` 키워드

  - 원래 인스턴스 타입이 맞는지 체크하는 키워드
  - 체크하지 않은 채로 Customer로 업캐스팅된 VIPCustomer를 GoldCustomer로 다운 캐스팅하려고 하면 에러 발생
  - **다운 캐스팅을 하기 전에는 반드시 instanceof로 체크**를 할 것



Overriding

- **재정의** 라는 뜻 : 상위 클래스에서 구현된 코드를 하위 클래스에서 재정의 하는 것
  - 메서드나 생성자에 대해서 가능
  - 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우
  - 이클립스에서 우클릭 > Source > Override로 구현 가능
- Annotation
  - 오버라이딩한 메서드 위에는`@Override`가 붙음
  - 컴파일러에게 정보를 주는 위 표기법을 annotation이라 함



**가상 메서드**

- 인스턴스를 업캐스팅하고 오버라이딩된 메서드를 호출하면 **하위 클래스의 메서드가 호출됨**
  - 왜? **자바의 모든 메서드는 가상 메서드**로, **항상 인스턴스의 메서드가 호출**되기 때문
  - 업캐스팅하는 경우 변수 vc의 타입은 Customer이지만 인스턴스의 타입은 VIPCustomer임

- 가상 메서드 원리
  - ![가상 메서드](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter3/3-05/img/virtual.png)
  - 메서드는 Code영역에 저장되고, 메서드의 이름은 그 주소값을 나타냄
  - 각 클래스는 **가상 메서드 테이블**(자신이 갖는 메서드의 주소 테이블)을 가짐
  - 하위 클래스로 생성된 인스턴스는 오버라이딩된 메서드의 주소를 갖기 때문에, 업캐스팅을 하더라도 하위 클래스의 메서드를 호출함



#### 다형성



다형성이란?

- **하나의 객체가 여러 형태로 변화** : 변수 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것
  - 하나의 코드가 여러 자료형으로 구현되어 실행
    - 상위 클래스에서 공통적인 부분을 제공하고 하위 클래스에서 각 클래스의 기능을 구현
  - 예) 상위 클래스인 Unit을 통해 객체를 생성하고, 공통 메서드인 move()를 객체별로 다르게 구현
    - **오버라이딩과 업캐스팅**을 활용하여 Unit 객체가 여러 형태(하위 유닛 : 저글링 등)로 변화함
- 다형성을 잘 활용하면 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있음
  - 다형성을 쓰지 않으면 코드 확장을 할 때 if-else문을 계속 추가해야 함
  - **한 클래스에 조건분기가 너무 많으면 리팩토링**을 통해 클래스를 나누는 것을 권장



다형성의 종류

- 서브타입 다형성(Subtype Polymorphism)
  - 가장 일반적으로 접하는 다형성
  - 상위 클래스와 해당 클래스를 상속받는 다수의 하위 클래스들을 만들어 **상위 클래스의 포인터나 참조변수 등이 하위 클래스의 객체를 참조**하게 하는 것
    - 각각의 하위 클래스는 메서드 오버라이딩(Method overriding)을 수행
    - 상위 클래스의 참조변수가 어떤 하위 클래스의 객체를 참조하느냐에 따라 호출되는 메소드가 달라짐
- 매개변수 다형성(Parametric Polymorphism)
  - 타입을 매개변수로 받아 **새로운 타입을 리턴**함
  - 타입 매개변수를 정의한 클래스 혹은 메소드는 사용할 때 매개변수에 타입을 지정하게 되며, 컴파일 시 지정한 타입에 따라 해석됨
  - Java에서는 **제네릭(Generic)**을 이용해 매개변수 다형성을 구현
    - 지정한 타입 매개변수에 **해당하는 타입만을 사용하겠다고 약속**하는 방식
    - 타입 매개변수가 특정 객체를 상속할 경우 상속하는 객체의 함수는 호출할 수 있지만 그렇지 않을 경우 타입 매개변수로 지정된 객체의 멤버에는 접근할 수 없다.
    - C++에서는 템플릿을 이용해 구현하는데 생략
- 임시 다형성(Ad hoc Polymorphism)
  - 함수 오버로딩(Function overloading)
    - 동일한 이름의 함수를 매개변수에 따라 다른 기능으로 동작하도록 할 수 있음
    - 전체적인 코드의 유지보수가 어려워지므로 템플릿 or 제네릭으로 대체하는 것이 권장됨
  - 연산자 오버로딩(Operator overloading)
    - C++, C# 등에서는 연산자를 오버로딩해서 기본 연산자가 해당 클래스에 맞는 역할을 수행
- 강제 다형성(Coercion Polymorphism)
  - 형 변환(Implicit, Explicit type coercion)을 통해 변수의 다형성을 구현



#### 추상화



추상화란?

- 모델링이 곧 추상화
  - 어떤 종류의 대상들에 대해 그것이 가져야 할 핵심적인 특징들을 가지는 **모델**을 만드는 것
- **공통적인 부분 혹은 특정한 특성을 분리하여 재조합하는 것**이 추상화
  - 구현 측면 : 해당하는 것을 구현할 때 그것이 어떤 특징들을 가지도록 만들어야 하는지에 대한 **명세**
  - 이용 측면 : 어떻게 동작하는지 모르더라도 다른 것을 만들 때 활용할 수 있게끔 하는 **인터페이스**





### 2.3. OOP 설계 5대 원칙 : SOLID



Single Responsibility Principle

- 어떠한 클래스를 변경하는 이유는 한가지 뿐이어야 함
  - 클래스에 책임(기능)이 너무 많으면 응집도가 떨어져 유지보수가 어려워짐
  - 높은 응집도를 가져가기 위해 상속과 다형성을 활용



Open Closed Principle

- 클래스(모듈)는 확장에 대해서는 열려 있고 수정에 대해서는 닫혀 있어야 함
  - 어플리케이션의 요구사항이 변경될 때 이에 맞게 새로운 행위를 추가해서 **모듈을 확장**할 수 있음
  - 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스코드나 바이너리 **코드의 변경을 초래하지 않음**
- 예) JDBC Interface
  - 어플리케이션은 JDBC를 통해 DB와 통신함
  - 외부적으로는 새로운 DB가 얼마든지 추가될 수 있고(확장에 열려 있음)
  - 내부적으로는 JDBC Interface하고만 통신하여 수정에 닫혀 있음



Liskov Substitution Principle

- 서브 타입은 언제나 자신의 상위 타입으로 교체될 수 있어야 함
  - 자식 클래스가 부모 클래스를 상속 받아 특성과 기능(메서드)을 그대로 갖고 있어야 함
  - 부모 클래스의 개념이 자식 클래스를 포함해야 함
  - **업캐스팅**이 가능함



Interface Segregation Principle

- 클라이언트는 자신이 사용하지 않는 메서드의 의존 관계를 맺으면 안 됨
  - **인터페이스 오염**이란?
    - 서브 클래스를 편하게 이용하기 위해 사용하지 않는 메서드가 포함된 인터페이스를 상속
    - 해당 서브 클래스를 상속하는 클래스가 새로운 메서드를 필요로 함
    - 상위 인터페이스에 점점 불필요한 메서드가 추가됨
  - 인터페이스를 분리하거나 다중 구현을 통해 해결
    - 여러개의 클라이언트가 사용하는 인터페이스를 만들지 말고, **하나의 인터페이스가 하나의 기능만을 담당하도록** 설계 : **인터페이스의 SRP**라고 할 수 있음
    - 자전거 내비는 자전거 길 안내, 자동차 내비는 자동차 길 안내 인터페이스만을 상속



Dependency Inversion Principle

- 자신보다 변하기 쉬운 것에 의존하면 안 됨
- 인터페이스를 통해서 이 원칙을 준수할 수 있음
  - 고수준인 클라이언트는 저수준의 클래스에서 추상화한 인터페이스만을 바라보기 때문에, 이 인터페이스를 구현한 클래스는 클라이언트에 어떤 변경도 없이 얼마든지 나중에 교체될 수 있음
  - **전략 패턴**



### 2.4. 추상클래스, 인터페이스



#### 추상 클래스

추상 클래스란?

- **추상 메서드를 포함한 **클래스

  - 추상 메서드란 구현부(body) 없이 선언만 된 메서드: 앞에 abstract를 붙여서 구분함

    - 반대로 추상 메서드가 없는 클래스는 Concrete Class라 함

  - ```java
    int add(int x, int y); 		// 선언만 되어 있음 
    int add(int x, int y){ } 	// 구현부가 있음, 추상 메서드 아님
    ```

  - 추상 메서드를 선언하면 eclipse가 body를 추가하거나 abstract를 추가하라고 함

    - abstract를 추가하면 추상 메서드가 되기 때문에, 클래스에도 abstract를 추가하라고 함

  - 추상 클래스는 **new로 인스턴스를 생성할 수 없음**

    - 추상 메서드를 다 구현했어도 클래스 앞에 abstract가 붙으면 new로 생성 불가
    - 인스턴스를 생성해서 기능을 제공하는 것이 목적이 아님 : **상속만을 위해 만들어졌기 때문**

- 추상 클래스의 필요성

  - 공통적으로 작성되어야 하는 필드, 메서드를 추출하여 유지보수성을 높이고 통일성을 유지
  - 설계의 규격만을 만듦으로써 다른 소스의 영향도를 줄이고 변화에는 유연하게 함
  - 상속만을 위해 만들어짐 : **기능은 subclass에서 구현**함

- 추상 클래스, 추상 메서드는 클래스 다이어그램에서 이탤릭체로 표현함

  ![추상](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter3/3-09/img/notebook.png)



템플릿 메서드 패턴

- 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
  - "특정 단계"에 해당하는 작업을 처리하는 부분을 **서브 클래스로 캡슐화**해서 구현
  - 추상 클래스를 활용하여 캡슐화
  - 프레임워크에서 굉장히 많이 사용되는 설계 패턴임
- 템플릿 메서드
  - abstract 메서드 + concrete 메서드를 이용하여 코드의 흐름을 정의하는 메서드
  - final로 선언하여 **하위클래스에서 재정의할 수 없게 함** : 변하면 안 되는 시나리오(템플릿)기 때문
  - 템플릿 메서드에 포함되는 추상 메서드들은 하위 클래스에서 구현
    - 꼭 추상 메서드가 아니더라도 하위 클래스에서 재정의해서 쓰기도 함



#### 인터페이스

인터페이스란?

![interface](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter3/3-15/img/book.png)

- **추상 메서드만으로 구성된** 클래스
  - 자바 8 이후에 default method와 static method가 제공되면서 일부 구현 코드도 들어가게 되었음
  - 하지만 인터페이스 메서드를 선언하면 기본적으로 public abstract가 됨
- 인터페이스는 **클래스에 의해 구현됨**
  - 상속이랑은 다름: 상속은 `extends`, 구현은 `implements`
    - `public abstract class Calculator implements Calc{ ... }`
  - 모든 추상 메서드를 다 구현하면 (fully implemented) 추상 클래스가 아니지만, 일부분만 구현하면 추상 클래스가 됨
- 인터페이스는 **다중 상속**이 가능
  - 한 클래스가 여러 인터페이스를 구현할 수 있음
  - 정확히는 상속이 아니기 때문에 "여러 타입을 내포할 수 있다"라고 함
    - 타입 상속이라고도 함: `Calculator`는 `Calc` 타입이다
- 클래스는 왜 다중 상속이 안 될까?
  - **Diamond Problem**
  - 추상 클래스 a에 추상 메서드 aa가 있고, 클래스 b와 c가 이를 각각 구현했다고 할 때 클래스 d가 b, c를 상속한다면 d에서 aa를 어떻게 호출해야 되는가?
  - 이런 모호성 때문에 자바에서는 클래스의 다중 상속을 막았음
  - **인터페이스는 구현이 안 되어있기 때문에 다중 상속(정확히는 구현)이 가능**한 것
- 인터페이스의 상속은 클래스 다이어그램에서 점선으로 표현함



인터페이스의 필요성

- 인터페이스가 하는 일
  - 클래스나 프로그램의 기능을 명시적으로 선언: 명세(specification)라고 할 수 있음
  - 클라이언트 코드가 서비스의 구현을 알 필요 없이 **메서드의 명세만 보고 사용**할 수 있도록 함
    - 예) 리모콘을 쓸 때 기능만 알고 쓰지 작동 원리는 모르는 것처럼
- 인터페이스의 사용
  - 어떤 객체가 하나의 인터페이스 타입이라는 것은 해당 인터페이스가 제공하는 모든 메서드를 구현했다는 뜻임
  - 하나의 인터페이스를 여러 객체가 구현하여 사용할 수 있음: 다형성
    - 예) JDBC 인터페이스



인터페이스의 요소

- 상수
  - 모든 변수는 상수로 변환됨: public static final
- 추상 메서드
  - 모든 메서드는 추상 메서드가 됨: public abstract
- 디폴트 메서드
  - 구현을 가지는 메서드, 인터페이스를 구현하는 클래스들에서 공통으로 사용할 수 있는 기본 메서드
  - 구현하는 클래스에서 재정의할 수 있음
  - 인스턴스 생성 후에 사용 가능
- 정적 메서드
  - 인스턴스가 없어도 인터페이스 타입으로 사용 가능한 메서드
- private 메서드
  - default method나 static method에서만 사용함
  - 인터페이스를 구현한 클래스에서 사용하거나 재정의할 수 없음



인터페이스의 상속

- 다중 구현
  - 하나의 클래스가 여러 인터페이스는 구현 할 수 있음
  - 디폴트 메서드가 중복되는 경우는 구현하는 클래스에서 재정의 필요
  - 여러 인터페이스를 구현한 클래스는 특정 인터페이스로 형 변환 되는 경우 **해당 인터페이스에 선언된 메서드만 사용 가능** 함
- 인터페이스 간 상속
  - 이 때는 extends를 이용해서 상속



## **3. 디자인 패턴**



[디자인 패턴 정리](https://realzero0.github.io/study/2017/06/12/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%A0%95%EB%A6%AC.html)

디자인 패턴이란?

- 자주 사용되는 설계 패턴을 유형별로 정형화한 것
- 명확히 정답이 있는 것이 아니라 프로젝트 특성에 맞춰 적용 가능함
- GoF(Gag of Four)의 23가지 디자인 패턴이 최초로 제안되었고 가장 유명함
- 디자인 패턴 활용의 장점
  - 개발자 간의 원활한 의사소통
  - 소프트웨어 구조 파악의 용이성
  - 재사용 및 유지보수 편리성
- 단점으로는 개발자들이 객체 지향 설계에 대해 잘 알고 있어야 하며 초기 비용이 든다는 점이 있음



### 3.1. GoF의 23가지 디자인 패턴



#### 생성 패턴

> 객체를 생성하는 것과 관련된 패턴
>
> **객체의 생성 - 변경이 전체 시스템에 미치는 영향을 최소화**하여 코드의 유연성 향상



- Factory Method
  - 생성할 객체의 클래스를 국한하지 않고 객체를 생성
- Singleton
  - 한 클래스에 한 객체만 존재하도록 제한 
    - 멤버 변수로 자신의 객체를 갖고, 생성자에 private을 걸어서 생성을 제한함
    - `getInstance()`를 구현해 객체를 이용할 수 있게 함
  - 서로 **자원을 공유하는 경우**에 사용됨
    - TCP socket 통신에서 서버에 연결된 connector 객체에 주로 사용함
- Prototype
  - 기존 객체를 복제함으로써 객체를 생성
- Builder
  - 생성(construction)과 표기(representation)를 분리해 복잡한 객체를 생성
- Abstract Factory
  - 동일한 주제의 다른 팩토리를 묶어줌
- Chaining



#### 구조 패턴

> **클래스, 인터페이스의 구성을 통해 프로그램의 구조를 설계**하는 데 활용하는 패턴
>
> 대규모 프로젝트에서의 클래스 간 복잡한 의존성을 파악하기 쉽게 해주어 유지 보수성을 높임



- Adapter
  - 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움
  - **인터페이스가 호환되지 않는 클래스들을 함께 이용**할 수 있도록 함
    - 개방 폐쇄 원칙(OCP)을 따름 : 
    - 예) 110V를 구현하면서 220V 가전 객체를 인자로 받는 Adapter 클래스 : 220V가전이 adapter를 이용해 110V의 메서드 사용할 수 있게됨
- Composite
  - N개의(N >= 0) 객체를 묶어 하나의 객체로 이용할 수 있음
- Bridge
  - 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있음
- Decorator
  - 기존 객체의 매서드에 새로운 행동을 추가하거나 오버라이드 함
  - 확장이 필요할 때 상속 대신에 활용할 수 있음
  - 개방 폐쇄 원칙(OCP), 의존 역전 원칙(DIP)을 따름
- Facade
  - 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공함
  - 여러 객체와 실제 사용되는 서브 객체 간 복잡한 의존도가 있을 때 Facade의 인터페이스만을 활용하여 기능을 사용하는 방식
    - Facade는 자신을 구현하는 각 클래스의 기능을 명확히 알아야 함
    - 여러 **객체를 합쳐서 특정 기능을 사용**할 때
    - 예) FTP Client에서 FTP, Reader, Writer에 대해 일일이 연결/해제를 구현하지 않고 이 객체들을 모두 감싸는 Facade 객체를 이용하여 코드 양을 줄이고 의존성은 안쪽으로 숨김
- Flyweight
  - 다수의 유사한 객체를 생성·조작하는 비용을 절감
- Proxy
  - 접근 제어, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공
  - 클라이언트가 Proxy 객체를 통해 대신 결과를 받음
    - Cache 기능으로 활용 가능
    - 스프링에서는 Proxy 패턴을 활용하여 AOP를 사용함
  - 개방 폐쇄 원칙(OCP), 의존 역전 원칙(DIP)를 따름



#### 행위 패턴

> **객체 간의 상호 작용을 패턴화**하여 상호 작용의 방법과 책임을 분산하는 방법을 제공하는 패턴
>
> 행위 관련 패턴을 사용하여 독립적으로 일을 처리하고자 할 때 사용함



- Template Method
  - 상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위 클래스에서 결정
- Interpreter
  - 문법 규칙을 클래스화한 구조를 갖는SQL 언어나 통신 프로토콜 같은 것을 개발할 때 사용
- Iterator
  - 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근
  - 메서드를 이용해 자료구조를 활용할 수 있도록 해줌
- Observer
  - 어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보
  - Swing, GUI 프로그래밍, 안드로이드에서 사용하는 event listener가 Observer를 사용하는 대표적 예
- Strategy
  - 객체의 행위를 동적으로 바꾸고 싶은 경우 직접 **행위를 수정하지 않고** **전략만 변경함**
    - OCP 원칙을 지키면서 행위를 유연하게 확장할 수 있음
  - 전략 객체, 전략 객체를 사용하는 컨텍스트, 전략 객체를 컨텍스트에 주입하는 클라이언트가 필요
    - 객체들이 할 수 있는 행위 각각에 대해 전략 클래스를 생성해야 함
    - 유사한 행위들을 캡슐화 하는 전략 인터페이스를 정의함
    - 예) main에서 인코딩 전략(Normal, Base64) 클래스를 인코더 클래스에 주입
  - 개방 폐쇄 원칙(OCP)와 의존 역전 원칙(DIP)를 따름 
- Visitor
  - 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스를 생성
  - Visitor 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행
- Chain of responsibility
  - 책임들이 연결되어 있음
  - 한 책임자가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조
- Command
  - 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행
- Meditator
  - 클래스간의 복잡한 상호작용을 캡슐화하여 한 클래스에 위임해서 처리
- State
  - 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용
- Memento



## **4. 자바의 유용한 클래스들**



Object 클래스

- 모든 자바 클래스의 root 클래스
  - 모든 클래스는 Object 클래스를 (자동으로) 상속받음
  - Object 클래스 내에 final로 선언되지 않은 메서드들은 재정의하여 사용 가능: `toString()` 등
- Object 클래스는 java.lang 패키지 안에 들어있음
  - java.lang 패키지는 자동으로 import 됨



Object 클래스의 메서드들

- `toString()`
  - **객체의 정보를 String으로 표현**할 때
  - 객체를 println해보면 메모리 주소가 나오는데 String 객체에 대해서는 문자열의 내용물이 나옴
  - String, Integer 클래스에 대해서는 이미 재정의가 되어 있다
- `equals()`
  - 두 인스턴스의 **주소값을 비교하여** true/false를 반환함(물리적으로 동일한지 판단)
  - 재정의하여 두 인스턴스가 논리적으로 동일한지 구현**할 수 있음**
    - 메모리 내부에 저장된 "값"이 동일한지 판단
    - equals() 메서드의 원형은 물리적 판단만 하지만 보통 재정의해서 논리적으로도 판정함
    - `==` 연산자는 주소값만 비교 : 재정의 불가
- `hashCode()`
  - heap에 저장된 **객체의 메모리 주소를 반환**함
    - 다른 방식도 있음: 객체의 모든 attribute에 대하여 각각의 hashcode를 구하여 최종적으로 다시 하나의 hashcode를 구하도록 하여 서로 다른 객체인지 판명
  - JVM이 힙 메모리를 관리할 때 해시 함수를 이용함
  - equals()를 재정의한다면 hashCode()도 재정의해야 함
    - 두 객체가 동일하다면 두 객체의 hashCode값도 일치해야 하기 때문
    - equals 재정의로 다른 곳에 저장된 두 객체가 같다는 판정이 나올 수 있으니 이를 보정하기 위해 hashCode재정의 필요
- `Clone()`
  - 객체의 원본을 복제하는 데 사용
  - 사용이 권장되지는 않음
    - 정보 은닉, 객체 보호 관점에서 안 좋음
    - cloneable 인터페이스를 명시해 준 경우에 사용
    - `public class Student implements Cloneable{ ... }`
- 재정의 불가한 메서드들
  - 스레드 관련
    - `wait()`
    - `notify()`
  - `finalize()`: GC가 인스턴스를 메모리에서 해제할 때 사용. 이제는 사용되지 않지만..
  - `getClass()`



#### String 클래스

- 선언하기

  - 인스턴스로 생성: `String str1 = new String("abc");`
    - char Array를 만들어 그 안에 문자를 집어넣음
    - 내부적으로 final로 선언되기 때문에 변경 불가
    - **추천하지 않는 방법**: 기존에 이미 같은 문자열이 있어도 heap에 새롭게 생성됨
  - 리터럴로 생성: `String str2 = "abc";`
    - Heap 내부의 string constant pool 안에 생성
    - 마찬가지로 변경 불가

- 한 번 선언된 **String은 불변**(immutable)




String constant pool

![string pool](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCZS5V%2FbtqFPrKJ713%2F7k48Gu8Hr6mdNmGO9wtTMK%2Fimg.png)

- literal로 생성된 string은 string pool안에 저장되어 재사용됨
  - JVM이 String constant pool 영역에서 이전에 같은 값을 갖고있는 String 객체가 있는지 찾음
  - 같은 값을 갖고있는 String 객체가 존재 하면 해당 객체의 주소값을 반환하여 참조하도록 함
- `String.intern()`
  - 호출하는 String 객체의 문자열 값이 string pool 안에 있는지 찾아보고 있으면 주소값을 반환하는 메서드
  - 리터럴을 이용해서 String 객체를 생성하면 내부적으로 intern() 메소드가 호출됨



String의 연결

- `+`로 연결
- `concat()`로 연결: 기존의 String에 연결되는 것이 아닌 **새로운 문자열이 생성됨** (메모리 낭비)
- StringBuilder, StringBuffer 사용을 권장
  - 가변성 : `.append()`,  `.delete()` 등의 API를 이용하여 **동일 객체내에서 문자열을 변경**하는 것이 가능
  - 둘 다 내부적으로 **가변적인 char[]를 멤버 변수로 가짐**



기타

- StringBuilder vs StringBuffer
  - StringBuffer는 멀티쓰레드 프로그래밍에서 유리
    - synchronizd를 지원하지만 느림
  - StringBuilder는 싱글쓰레드에서 사용하는 것을 권장
    - 동기화를 지원하지 않는 대신 빠름
    - 그냥 string은 동기화 지원하고 빠름
  - buffer에 문자열을 넣고, 출력할 때는 `toString()`을 이용함

- text block

  - Java 13부터 지원하는 기능으로 문자열을 """ """ 사이에 이어서 만들 수 있음

  - html, json 문자열을 만드는데 유용함

    - ```java
      String strBlock = """
      				This 
      				is 
      				text
      				block
      				test.""";
      ```



Class 클래스

- 컴파일 된 **class 파일**을 로드하여 객체를 **동적으로 로드**(바인딩)하고 정보를 가져오는 메서드를 제공함
  - 자바의 모든 클래스, 인터페이스는 컴파일 후 class 파일을 생성함
  - `Class.forName(String className)` 메서드를 이용해 클래스를 로드
    - `Class c = Class.forName("java.lang.String");`
  - 동적으로 로드: 컴파일 시가 아니라 실행 중에(runtime) 데이터 타입을 바인딩 함
    - 프로그래밍 시에는 문자열 변수로 처리, 런타임시에 원하는 클래스를 로딩
    - 오류가 발생하면(Class Not Found) 심각한 장애가 될 수도 있음
- Class 클래스의 메서드
  - 클래스의 정보 알아보기(**reflection 프로그래밍**)
    - 로컬 메모리에 객체 없는 경우, 원격 프로그래밍, 객체의 타입을 알 수 없는 경우에 사용
    - `.getConstructors()`
    - `.getMethods()`
  - 인스턴스 생성
    - `.newInstance()`
    - 이것도 로컬에 해당 객체가 없을 때 사용



## **5. 자바와 자료구조**



### 5.1. Array



배열이란?

- **동일한 자료형**의 **순차적** 자료구조
  - 인덱스를 이용하여 O(1)에 빠르게 탐색
  - 단 삽입-삭제는 O(n)으로 느림
- 물리적 위치와 논리적 위치가 같음
  - 실제 메모리 상에도 순차적으로 저장됨: `arr[i]` 옆에 `arr[i+1]`가 있음
  - 선언할 때 자료형과 크기에 따라 메모리를 차지하는 공간 결정
- jdk 클래스로 **ArrayList**, Vector가 있음



배열 선언 및 초기화

- 선언하기

  - **자료형과 길이를 명시**해줘야 함

  - ```java
    int[] arr1 = new int[10];
    int arr2[] = new int[10];
    ```

- 초기화 하기

  - 선언과 동시에 초기화 하는 경우엔 new를 쓸 수도 안 쓸 수도 있음

  - ```java
    int[] numbers = new int[] {10, 20, 30};
    int[] numbers = {10, 20, 30};
    ```

  - 선언 후 초기화 하는 경우에는 new 생략 불가

  - ```java
    int[] ids;
    ids = new int[] {10, 20, 30};
    ```

- 2차원 배열의 선언 및 초기화

  - `int[][] arr = {{1,2,3}, {4,5,6}};`



배열의 사용

- `arr.length`와 배열 안에 있는 데이터의 갯수는 다름
  - 배열의 길이는 초기화 때 정해짐
- 향상된 for문: **for each**
  - `for(int num : arr) { ... }`
    - 파이썬의 `for num in nums`랑 같은 방식으로 사용 가능
  - 괄호 뒤의 iterate 객체에 한개씩 순차적으로 괄호 뒤의 var가 대입되어 루프를 순회함
    - for each문을 사용할 수 있는 iterate 객체는 iterator 인터페이스를 상속받음
    - 자세한 내용은 [5.5. Collection Framework](# 5.5.-Collection-Framework) 참고



객체 배열

- 객체를 요소로 갖는 배열

  - int, double 등의 primitive type의 원소를 갖는 것은 기본 자료형 배열이라고 함
  - 객체 배열은 선언될 때 객체의 **주소가 들어갈 메모리만 할당**됨
    - 각 요소 객체는 생성해서 저장해야 함

- 객체 배열 복사

  - 얕은 복사

    - 복사 메서드`System.arrayCopy(src, srcPos, dest, destPos, length)` 이용
    - **주소가 복사**되기 때문에 한쪽 배열의 요소를 수정하면 복사한쪽에도 반영됨

  - 깊은 복사

    - 각각의 객체를에 대해 생성한 후 똑같은 값으로 복사하고 배열에 넣어줌

    - **일일이 반복문으로** 해주거나

    - ```java
      for(int i = 0; i< library.length; i++) {
      			copiedLibaray[i].setTitle(library[i].getTitle());
      			copiedLibaray[i].setAuthor(library[i].getAuthor());
      		}
      ```
      
    - 2차원 배열의 경우`System.arraycopy`를 이용하여 가능
    
    - ```java
      for (int i = 0; i < result.length; i++)
          System.arraycopy(library[i], 0, copiedLibaray[i], 0, library[i].length);
      ```



ArrayList

- `java.util` 패키지 내에 **객체 배열**을 구현해 둔 클래스

- 많은 메서드들이 최적의 알고리즘으로 구현되어 있어 사용 방법만 익히면 유용하게 사용할 수 있음

  - 주요 메서드

    ![메서드](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-23/img/method.png)

  - E는 뭐냐?

    - 객체 배열의 element(인스턴스)에 해당하는 클래스를 E로 표기함

- 선언 및 초기화

  - `ArrayList<Book> library = new ArrayList<Book>(); `
  - 객체 타입에 해당하는 Class를 import해야 함(위에서는 Class Book)



### 5.2. LinkedList



연결 리스트란?

- **동일한 데이터 타입**을 순서에 따라 관리하는 자료 구조
- 데이터를 저장하는 노드에는 **자료와 다음 요소를 가리키는 링크**(포인터)가 있음
  - 데이터가 추가 될때 노드 만큼의 메모리를 할당 받고 이전 노드의 링크로 연결함 (정해진 크기가 없음)
  - 연결 리스트의 i 번째 요소를 찾는데 걸리는 시간은 요소의 개수에 비례 : O(n)
  - 삭제/추가는 O(1)이지만 삭제할 곳을 찾는 데 O(n)이 걸리기 때문에 전체적으로 느리다
- jdk 클래스 : LinkedList



### 5.3. Stack, Queue



스택의 특징

- 맨 마지막 위치(top)에서만 자료를 추가,삭제, 꺼내올 수 있음 ( 중간의 자료를 꺼낼 수 없음)
  - Last In First Out ( 후입선출 ) 구조: 택배 상자가 쌓여있는 모양
  - 응용: 가장 최근의 데이터를 찾아오거나 게임에서 히스토리를 유지하고 이를 무를때
- 함수의 메모리는 호출 순서에 따른 stack 구조로 되어 있음
- jdk 클래스 : Stack



Queue의 특징

- 맨 앞(front) 에서 자료를 꺼내거나 삭제하고, 맨 뒤(rear)에서 자료를 추가 함
  - Fist In First Out (선입선출) 구조: 일렬로 줄 서 있는 모양
  - 순차적으로 입력된 자료를 순서대로 처리하는데 많이 사용됨
  - 응용: 콜센터에 들어온 문의 전화, 메세지 큐 등
- jdk 클래스 : ArrayList



### 5.4. Generic



제네릭이란?

- 자료형을 지정하지 않고 프로그래밍하는 것
  - 클래스에서 사용하는 변수의 자료형이 여러개 일수 있고, 그 **기능(메서드)은 동일한 경우**
  - 자료형을 특정하지 않고 **추후 해당 클래스를 사용할 때 지정** 할 수 있도록 선언
- 제네릭의 장점
  - 실제 사용되는 자료형의 변환은 컴파일러에 의해 검증되므로 안정적임
    - **잘못된 타입이 사용될 수 있는 문제**를 컴파일 과정에서 차단
  - 불필요한 casting을 제거하여 **성능을 향상**
    - 여러 타입을 받는 경우에(다형성) non-generic의 경우 객체를 얻을 때마다 casting이 필요
    - 이런 이유에서 컬렉션 프레임워크에서 많이 사용되고 있음



자료형 매개변수

- T(type parameter)를 사용하여 **클래스를 사용하는 시점에 실제 타입을 지정**함
  - E : element, K: key, V : value 등 여러 알파벳을 의미에 따라 사용 가능
- 선언: `public class GenericPrinter<T> { ... }`
- 사용: `GenericPrinter<Powder> powderPrinter = new GenericPrinter<>();`
  - 다이아몬드 연산자를 생략해도 되지만 인스턴스를 사용할 때 형변환 `(Powder)` 필요
- static 변수는 사용 불가



`<T extends Class>` 

- **T 자료형의 범위를 제한** 할 수 있음
  - 상위 클래스에서 선언하거나 정의하는 메서드를 활용할 수 있음
  - 상속을 받지 않는 경우 T는 Object로 변환되어 Object 클래스가 기본으로 제공하는 메서드만 사용가능
- 구현하기
  - `public class GenericPrinter<T extends Material>`
  - GenericPrinter 에 material 변수의 자료형을 상속받아 구현
  - T에 들어가는 것을 Material 클래스를 **상속받은 클래스로 한정**지음



제네릭 메서드

- 말 그대로 제네릭을 이용한 메서드
  - `public <자료형 매개 변수> 반환형 메서드 이름(자료형 매개변수.....) { }`
  - 자료형 매개 변수가 하나 이상인 경우도 있음
- 제네릭 클래스가 아니어도 내부에 제네릭 메서드는 구현하여 사용 할 수 있음  



Generic vs non-Generic

![non-generic](https://kottans.org/csharp-slides/presentations/9-collections-generics/images/generic_vs_nongeneric.png)



### 5.5. Collection Framework



컬렉션 프레임워크란?

- 자바에서 사용되는 자료구조를 구현해 놓은 JDK 라이브러리
  - `java.util` 패키지에 구현되어 있음
- Collection과 Map으로 나뉨
  - ![collection framework](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter5/5-09/img/collection.png)
  - Collection 인터페이스
    - 하나의 객체를 관리함: 이름, 주민번호, 아이디 등 
    - 하위에 List, Set 인터페이스가 있음: **중복을 허용하는지** 아닌지
  - Map 인터페이스
    - 쌍(key-value)로 이루어진 객체를 관리함
    - key는 중복을 허용하지 않음



List 인터페이스

- 멤버를 순차적으로 관리하는 자료형으로 배열과 비슷함
  - 구현하기에 따라 ArrayList나 LinkedList가 될 수 있음
  - ArrayList는 Vector를 개선하여 배열로 구현한 List
  - LinkedList는 다음 노드의 주소를 기억하고 있는 List
- 기본적으로 object 10개가 들어가고, 길이 지정 가능
  -  `add()`하게 되면 `ensureCapacity`로 체크한 후 10개를 **다 썼다면 새로운 ArrayList를 파서 복사**함



Set 인터페이스

- 중복을 허용하지 않도록 관리: **인스턴스의 동일성을 확인**하고 add해야 함
  - 동일성 구현을 위해 필요에 따라 equals()와 hashCode()메서드를 재정의
- 순차적으로 관리하지 않기 때문에 **저장된 순서와 출력 순서가 다를 수 있음**
  - TreeSet은 값에 따라 순서가 결정되고 HashSet은 순서 없음
    - 근데 LinkedHashSet은 또 입력한 순서에 따라 출력됨
- 많은 자료를 관리할 때는 HashSet 클래스를 사용해야 함
  - List보다 검색 속도가 훨씬 빠르기 때문: O(1)



Tree 인터페이스

- 이름에 Tree가 붙은 인터페이스는 BST로 구현되어 있음
  - 정확히는 균형을 유지하기 위해 레드-블랙 트리로 되어 있음
  - BST에 객체를 저장하기 위해 **객체의 비교가 필요**함: Comparable, Comparator 인터페이스 필요
  - String, Integer에 대해서는 Comparable 인터페이스가 이미 구현되어 있음



Iterator

![iterable](https://3.bp.blogspot.com/-q6R4oRfsx9E/WhfwSinEwZI/AAAAAAAAFgk/68bQD-J0T90nIYn5NBWp-aONvEnoe_dMQCLcBGAs/s1600/Screenshot-2017-11-24%2BUntitled%2BDiagram%2B-%2Bdraw%2Bio.png)

- Iterator: **Collection 요소를 순회하게 해주는 인터페이스**
  - 선언 : `Iterator<Member> ir = arrayList.iterator();`
  - Iterator 내부에는 `hasNext()`, `next()`, `remove()`가 있고 이는 각 컬렉션의 특성에 맞게 구현됨
- Itertor의 메서드
  - `boolean hasNext()`: 이후에 요소가 더 있는지를 체크하는 메서드, 요소가 있다면 true를 반환
  - `E next()` : 다음에 있는 요소를 반환
- Iterator의 이용
  - Set에는 Get(i)가 없기 때문에 Iterator를 이용하여 순회함
- Iterator vs Iterable
  - **Iterable은 Collection의 상위 인터페이스**
    - Iterable 인터페이스를 implement하면 객체는 for-each loop를 사용할 수 있음
  - Iterable은 `iterator()` 메서드를 추상 메서드로 선언하고 있음
    - 따라서 컬렉션의 하위 클래스들은 iterator()를 구현해야 함
    - Iterable은 iterator() 메소드가 호출이 될 때마다 Iterator의 새로운 instance를 생성
    - Iterator instance는 iteration 상태를 모아둔 곳으로 현재 element에 대해 다음 element로 이동하는 메소드를 제공



```java
private ArrayList<Member> arrayList;  // ArrayList 선언 

public MemberArrayList(){
	arrayList = new ArrayList<Member>();  //멤버로 선언한 ArrayList 생성
}
```



Map 인터페이스

- 검색을 위한 자료구조로 key - value를 쌍으로 관리하는 메서드를 구현함
- HashMap
  - 가장 많이 사용되는 Map 인터페이스 기반 클래스
  - HashTable을 사용하며 **key 값에 hash 알고리즘을 적용해 얻은 index를 이용**하여 값을 저장하고 꺼내오는 방식
    - key가 되는 객체는 중복을 허용하지 않음:  `equals()`와 `hashCode()` 메서드를 구현
    - 순서가 없음
- HashTable
  - HashMap과의 차이는 **동기화 보장을 해주느냐**(Table) 안해주느냐(Map), **key-value에 null이 가능한가**(Table) 아닌가(Map)
- TreeMap
  - key-value 쌍의 자료를 **key값 기준으로 정렬**하여 관리
    - Red-Black Tree를 이용하여 구현
    - key가 되는 클래스에 Comparable이나 Comparator인터페이스를 구현
- LinkedHashMap
  - LinkedList로 구현한 HashMap
  - List로 구현되어 있어 순서가 보장되지만 **랜덤 접근이 느림**



## **6. 자바 고급**



### 6.1. 내부 클래스



내부 클래스란?

- 클래스 내부에 선언한 클래스
  - 외부 클래스와 밀접한 연관이 있으면서 다른 **외부 클래스에서 사용할 일이 거의 없는 경우**에 선언
  - 주로 **private으로 선언**해서 사용함
- 중첩 클래스라고도 함
- 내부 클래스의 종류
  - 인스턴스 내부 클래스
  - 정적 내부 클래스
  - 지역 내부 클래스
  - **익명 내부 클래스**
  - 익명 내부 클래스를 제외하면 선언 위치, 라이프 사이클이 **변수와 똑같음** 



인스턴스 내부 클래스
- 외부 클래스가 생성된 후 생성됨
  - 인스턴스 내부 클래스에서는 **정적 변수 선언 불가**
  - 클래스가 생성이 되어야 정적 변수도 할당할 수 있기 때문
- private으로 선언하는 것을 권장
  
  - private이 아닌 경우 다른 외부 클래스에서도 생성 가능
  
  - 이론적으로 가능은 하지만 굳이 그렇게 하지는 않음
  
  - ```java
    OutClass outClass = new OutClass();
    OutClass.InClass inner = outClass.new InClass();
    ```



정적 내부 클래스

- 외부 클래스 생성과 무관하게 생성될 수 있음
  - **정적 변수, 정적 메서드 사용 가능**
- 정적 내부 클래스에서는 **외부 클래스의 인스턴스 변수 사용 불가**
  - 외부 클래스의 인스턴스가 생성되지 않아도 내부 클래스가 생성될 수 있기 때문
  - 내부 클래스의 정적 메서드에서는 내-외부 클래스의 정적 변수만 호출 가능
  - 내부 클래스의 일반 메서드에서는 추가로 내부 클래스(본인)의 인스턴스 변수 호출 가능



지역 내부 클래스

- 지역 변수와 같이 **메서드 내부에서 정의**하는 클래스

- 지역 내부 클래스에서 사용하는 **지역변수 및 매개변수는 final로 선언**됨

  - 메서드가 끝나면 지역 변수는 Stack에서 해제되는데, 지역 내부 클래스는 다시 호출될 수 있기 때문
  - 컴파일러가 자동으로 final로 선언해줌

- 예시) 지역 내부 클래스로 생성된 MyRunnable 객체를 리턴하는 메서드 getRunnable()

  - ```java
    Runnable getRunnable(int i){
        
        class MyRunnable implements Runnable{
            
            @Override
            public void run(){
                System.out.println("i = " + i);		// OK
                i = 50;								// 수정은 불가: final이기 때문       
            }
            
        }
        
        return new MyRunnable();
    }
    ```

  - 외부에서 `Runnable runner = out.getRunnable(100);`하면 메서드는 객체를 넘겨주면서 끝나는데, 스택에서 해제되며 매개변수가 사라지면 runner 를 사용할 수 없기 때문에 final로 선언해주는 것



익명 내부 클래스

- 지역 내부 클래스의 이름은 호출될 일이 없기 때문에 **이름을 없애고 바로 리턴**을 때림
  - ```java
    Runnable getRunnable(int i){
        
        return new Runnable() {
        
            @Override
            public void run(){
                System.out.println("i = " + i);		// OK
                i = 50;								// 수정은 불가: final이기 때문       
            }     
            
        }
        
    }
    ```
  
  - 클래스의 이름을 생략하고 주로 **하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환**
  
    - 예시에서는 Runnable 인터페이스를 구현하여 반환함
    - 인터페이스나 추상 클래스 자료형의 변수에 직접 대입하여 클래스를 생성하거나 지역 내부 클래스의 메서드 내부에서 생성하여 반환
- 내부 클래스 중에 **가장 많이 활용됨**
  
  - Android 프로그래밍에서 widget **이벤트 핸들러**에 많이 활용됨



### 6.2. Lambda expression



함수형 프로그래밍이란?

- **함수의 구현과 호출만**으로 이루어지는 프로그래밍 방식
- **순수함수**를 이용하여 외부 자료에 대한 side effect를 없앰(동기화 이슈 등)
  - 순수함수란?
    - 함수가 외부의 변수를 사용하지 않고 **인자로 전달된 변수만을 사용**함
    - **동일한 인자를 주었을 때 항상 같은 값을 리턴**하고, 다양한 자료에 대해 같은 기능을 수행
    - 자료 처리를 **수학적 함수**의 계산으로 취급하는 것으로 수학에서 말하는 함수와 동일한 것
  - 외부 자료를 이용하지 않으므로 **병렬 처리가 가능**함
  - 함수의 기능이 자료에 독립적임을 보장함



람다식이란?

- 자바에서 **함수형 프로그래밍**을 지원하기 위해 사용하는 표현
  - 자바 8부터 지원됨
- 소스가 간결해지나 가독성이 떨어진다는 단점이 있음



람다식 문법

- 함수의 이름이 없음
- (매개 변수) -> {실행문;} 으로 구성됨
  - `(int x, int y) -> {return x+y;}`
  - 매개 변수가 하나인 경우 자료형과 괄호 생략 가능
    - `str->{System.out.println(str);}`
  - 실행문이 한 문장인 경우 중괄호 생략 가능
    - `str-> System.out.println(str); `
  - 실행문이 한 문장이더라도 return문은 중괄호 생략 불가
    - `str-> return str.length();  //오류 `
  - 실행문이 한 문장의 반환문인 경우엔 return, 중괄호 모두 생략 가능
    - `str -> str.length;`
    - `(x, y) -> x + y;`



람다식의 구현

- 함수형 인터페이스

  - 람다식을 선언하기 위한 인터페이스
    - 람다식은 구현에 인터페이스가 필요함 : 자바에서 함수만 갖고 코딩할 수는 없기 때문
    - main에 람다식 add만 쓰면 당연히 컴파일이 안되고, Add 인터페이스를 선언해야 함
  - `@FunctionalInterface` 어노테이션을 붙여서 선언
    - 안 붙여도 되긴 함
  - 인터페이스는 **단 하나의 메서드만을 선언**해야함
    - 익명 함수를 구현해야 하는데 메서드가 여러 개면 뭘 구현할지 모르기 때문
    - 인터페이스에 메서드가 여러 개 있을 때 어노테이션을 붙이면 구현에서 에러 표시가 나고 안 붙이면 호출하는 곳에서 에러 표시가 남
- 람다식은 가능하면 짧게 구현하자
- 조건문은 삼항 연산자를 활용하여 짧게 할 수 있음
  - `LargerNumber largerNumber = (x, y) -> x > y ? x : y;`



OOP와의 비교

- OOP: 인터페이스 선언 → 인터페이스를 구현한 **클래스 작성 → 인스턴스 생성 후** 메서드 호출
- 람다식: 함수형 인터페이스 선언 → 람다식 구현하고 메서드 호출
  - 내부적으로는 **anonymous class가 생성되고 익명 객체가 만들어져** OOP와 동일하게 작동하는 것



변수처럼 사용되는 람다식

- 변수가 선언 후 대입되고, 매개변수로 전달되고, return값으로 반환되는 것처럼 람다식도 같은 방식으로 사용될 수 있음

- 선언과 대입

  - ```java
    interface PrintString{
    	void showString(String str);
    }
    public class PrintStringTest{
        //람다식을 변수 lambdaStr에 대입
    	PrintString lambdaStr = s -> System.out.println(s);
    	lambdaStr.showString("hello lambda_1");    
    }
    ```

- 매개변수 전달과 사용

  - ```java
    public static void showMyString(PrintString p){
        p.showString("hello lambda_2");
    }
    
    showMyString(lambdaStr);	// 람다식을 가리키는 변수 lambdaStr을 매개변수로 전달
    ```

- return값으로 돌아옴

  - ```java
    // 람다식을 반환하는 함수 returnString
    public static PrintString returnString(){
        return s -> System.out.println(s + "world");
    }
    PrintString reStr = returnString();		// returnString의 반환값을 reStr에 저장
    reStr.showString("hello ");				// reStr은 람다식을 가리키는 객체가 되는 것
    ```



### 6.3. Stream



스트림이란?

- 자료의 **대상과 관계없이 동일한 연산을 수행하는 객체**
  - 배열, 컬렉션을 대상으로 연산을 수행 함
- 스트림 객체 선언
  - 예) `Stream<String> stream = sList.stream();`
    - Collection 객체들은 (sList) 스트림을 호출할 수 있음
- 스트림 객체 사용 
  - 예) `sList.stream().forEach(s->System.out.println(s));`
  - stream에 점을 찍어서 다양한 메서드(sum, map, forEach 등) 사용 가능
  - 메서드 내부에 **람다식을 사용**하여 연산을 수행
  - 객체 선언 없이 선언과 사용을 한 줄로 처리할 수 있음
    - 예) `Arrays.stream(arr).forEach();`
- 스트림을 사용하는 이유
  - **일관성 있는 연산**으로 자료의 처리를 쉽고 간단하게 함
  - 자료 처리에 대한 추상화를 구현



스트림 특징

- **재사용 불가**
  - 스트림을 생성해 연산을 수행하면 스트림이 **소모됨**
    - 스트림은 오직 한 번만 사용할 수 있고 다른 연산하려면 스트림을 다시 생성해야 함
    - 재사용 못하기 때문에 굳이 객체 생성하는 코드를 쓸 필요가 없음
- 자료 변경 없음
  - **스트림이 사용하는 메모리 공간은 별도로 생성됨**: 연산이 수행돼도 자료 변경은 발생하지 않음
  - 이거 뭔가 중요할거 같지 않음?
- **중간연산과 최종연산**으로 구분됨
  - 중간 연산은 여러 개의 연산이 적용될 수 있지만 최종 연산은 마지막에 한 번만 적용됨
  - 최종연산이 호출되어야 중간 연산에 대한 수행이 이루어 지고 그 결과가 만들어짐
  - 따라서 중간 연산에 대한 결과를 연산 중에 알수 없음: **지연 연산**



중간연산과 최종연산

- 중간연산의 종류

  - `filter()` : 조건에 맞는 요소를 추출
  -  `map()` : 요소를 변환함
  -  `sorted()` : 정렬함
  - 기타 등등

- 최종연산

  - `forEach()` : 각 요소에 대해 연산을 수행 
  - `count()` : 요소의 갯수를 구함
  - `sum()` : 요소들의 합을 구함
  - 기타 등등

- 예1) 문자열 리스트에서 문자열의 길이가 5 이상인 요소만 출력

  - ```java
    sList.stream().filter(s->s.length() >= 5).forEach(s->System.out.println(s));
    ```

  - filter()는 중간 연산이고, forEach()는 최종 연산

- 예2) 고객 클래스 배열에서 고객 이름만 가져오기

  - ```java
    customerList.stream().map(c->c.getName()).forEach(s->System.out.println(s)); 
    ```

  - map()은 중간 연산이고, forEach()는 최종 연산



스트림의 활용 : `reduce()` 연산

- 정의된 연산이 아닌 **프로그래머가 직접 구현한 연산**을 적용

- reduce는 **최종 연산**임

  - 스트림의 요소를 소모하며 연산을 수행함

- reduce의 사용

  - ```java
    T reduce(T identify, BinaryOperator<T> accumulator) 
    ```

    - 첫 번째 parameter는 기본 값(초기값)으로 안 받을 수도 있음(parameter가 하나면 연산식만 들어감)
    - 두 번째에는 **BinaryOperator 인터페이스를 구현한 클래스를 넣거나 직접 람다식을 넣음**

  - 예) 배열의 모든 요소의 합을 구하는 reduce() 연산

    - `Arrays.stream(arr).reduce(0, (a,b)->a+b));`
    - 값을 더하기 위해 첫 번째 파라미터에 초기값으로 0을 넣음
    - 이후에 스트림의 각 요소를 소모하면서 연산 : 더한 결과를 반환하고, 반환값에 다음 요소를 더함
    - 최종적으로는 `sum()`과 똑같음



### 6.4. 예외 처리

> 자바의 안정성을 보장하기 위해서는
>
> 1. 시스템이 죽지(abort) 않도록 예외 처리를 반드시 할 것
> 2. 로그를 잘 남길 수 있도록 해서 bug fix를 용이하게 할 것

![error](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F996116375B30B71404DE0D)

오류란?

- JVM실행에 문제가 생긴 것
  - 컴파일 자체가 안 되거나(컴파일 에러) 프로그램이 비정상 종료될 수 있음(런타임 에러)
- **발생시 시스템 및 프로그램을 불능**상태를 야기함 : 시스템에 심각한 장애가 발생할 수 있음
  - **예외 처리**를 통해 런타임 에러를 최대한 피해야 함



예외처리란?

- 오류가 발생할 상황을 미리 예측하여 처리하는 것
  - 예외처리된 코드에서 오류가 발생하는 경우 **오류 메시지**만 남기고 다음코드로 넘어감
  - **로그**를 남김으로써 원인을 파악하고 방어코드를 구현하여 문제를 해결할 수 있게 함
    - 오류의 과정을 재현하는 것은 현실적으로 어렵고 로그 분석하는 것이 중요
- 처리 가능한 오류를 모아서 **Exception 클래스**를 만들었음
- 처리 불가능한 오류 : 개발자가 미리 예측하여 처리할 수 없음
  - 동적 메모리가 없는 경우, 스택 메모리 오버플로우 등



오류의 종류

- Compile Error
  - 프로그램 **코드 작성 중 발생**하는 문법적 오류
  - 처리하지 않으면 애초에 **컴파일이 안 됨** : 반드시 예외처리 해야 함
    - 안정성 확보 : 시스템이 죽어버리는 것(abort)을 미연에 방지함
    - 대부분 개발 환경(eclipse)에서 detection 됨
  - 컴파일 에러 예외처리하는 것을 Checked Exception(일반 예외) 라고 함
    - ClassNotFoundException, IOException 등
- Runtime Error
  - **실행 중인 프로그램이** 의도 하지 않은 동작(bug)을 하거나 프로그램이 중지 되는 경우
  - 런타임 에러의 예외처리를 Unchecked Exception(실행 예외)이라 함
  - RuntimeException의 자식 클래스들이 실행 예외에 포함됨
    - NullPointerException : 객체 참조가 없는 상태
    - ArrayindexOutOfBoundsException : 배열의 인덱스 범위를 초과할 때
    - NumberFormatException : 숫자로 변환 불가능한 문자열을 변환하려고 할 때
    - ClassCastException : 허용되지 않는 형 변환을 시도할 때



#### 예외 처리하기와 미루기

> 예외가 발생하는 문장에서 try-catch 블록으로 처리하는 방법
>
> 발생하는 문장에서 일단 throws하고 사용하는 부분에서 try-catch로 처리하는 방법



try-catch

- 예외를 처리하는 구문

  - try 블록에는 예외가 발생할 가능성이 있는 코드를 작성하고 **예외가 발생하면 catch 블록이 수행**됨

  - ```java
    int[] arr = {1,2,3,4,5};
    try{
    	for(int i=0; i<=5; i++){
    		System.out.println(arr[i]);
    	}
    }catch(ArrayIndexOutOfBoundsException e){
    	System.out.println(e);
    }
    ```

- catch 안에서는 로그를 찍을 수 있게 해야 함

  - e.toString() 은 해당 exception의 이름 + 메세지로 구성됨
    - `java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5`
  - 로그를 통해 왜 오류가 났는지 파악하고 버그를 수정
    - e.printStackTrace() 는 어디서 에러가 났는지 볼 수 있게 해줌

- **catch에서 예외를 처리해주지 않으면 abort** 발생

  - try-catch를 통해 예외를 처리하면 다음 코드도 정상적으로 수행됨

- throw

  - 에러를 발생시킴: `throw new Exception();`
  - throws와는 다르다!



finally

- try-catch에서 예외 발생 여부에 관계 없이 실행됨
  - 무조건 호출됨: 리턴이 있어도 호출됨
- 파일를 닫거나 네트웍을 닫는 등 **오픈된 리소스를 해제**하는 역할을 함
  - catch가 여러 개 있을 때 유용함
  - 각각의 catch에 대해 닫아주는 것보다 finally에 한 번만 작성 



try-with-resource문

```java
// 기존 방식
FileInputStream fis = null;
try{
    fis = new FileInputStream("a.txt");
}

// resource문 이용
try(FileInputStream = new FileInputStream("a.txt")){...}
```

- try() 내부에서 리소스를 선언하는 경우 close()하지 않아도 자동으로 해제됨
  - 단, **해당 리소스 클래스가 AutoCloseable 인터페이스를 구현해야** 함
  - FileInputStream의 경우에는 AutoCloseable을 구현하고 있음
- try() 외부에서 리소스를 선언하더라도 try(obj)와 같이 써주면 자동으로 해제됨
  - 이건 java 9부터 가능
  - 위 예시의 경우 그냥 `try(fis){...}`와 같이 쓰면 자동 해제 가능



throws

- 예외가 발생할 수 있는 부분(메서드 정의)에서는 미루고 사용하는 부분(메서드 호출)에서 try-catch로 처리

  - 무슨 차이가 있는가?

    - main에서 해당 메서드를 여러차례 호출하는 경우를 생각해보자

    - ```java
      public static void main(String[] args) {
          Test test = new Test();
          try {
              test.sayNick("fool");
              test.sayNick("genious");
          }
      ```

    - sayNick() 메서드 선언 시 예외처리를 하면 예외가 발생해도 다음 메서드가 실행됨

    - throws한 뒤 위의 예제처럼 main에서 try-catch 처리하면 예외 발생시 다음 메서드 실행되지 않음

  - **트랜잭션 처리할 때 throws가 이점을 가짐**

    - 메서드 중 하나라도 예외가 발생하면 모두 취소해야하기 때문

- 하나의 try{} 블록에서 예외가 여러개 발생하는 경우

  - 발생하는 부분에서 throws로 미룬 뒤 사용하는 부분에서 각각 처리

  - ```java
    public class ThrowsException {
    
    	public Class loadClass(String fileName, String className) throws FileNotFoundException, ClassNotFoundException{
    		FileInputStream fis = new FileInputStream(fileName);
    		Class c = Class.forName(className);
    		return c;
    	}
    
    	public static void main(String[] args) {
    
    		ThrowsException test = new ThrowsException();
    		
    		try {
    			test.loadClass("a.txt", "java.lang.String");
    		} catch (FileNotFoundException e) {
    			e.printStackTrace();
    		} catch (ClassNotFoundException e) {
    			e.printStackTrace();
    		} catch (Exception e) {
    			e.printStackTrace();
    		}
    	}
    }
    ```

  - 이 때 Exception으로 처리하는 블록은 맨 마지막에 위치해야 함

    - 명시해준 예외 이외에 모든 예외가 들어가기 때문
    - 이게 위에 있으면 아래에 있는 블록에 Unreachable이 뜸



사용자 정의 예외

- 개발자가 직접 정의하여 만드는 예외
- 기본적으로 Exception 클래스를 상속
  - 기존 예외 클래스중 가장 유사한 예외 클래스에서 상속 받아서 작성함
- 회원가입 시 규칙에 맞는 패스워드를 입력하지 않으면 에러를 발생시키는 등 응용 가능



#### 로그 남기기



logging이란?

- 시스템 운영에 대한 기록: 주로 오류가 발생 했을 때 그 **오류에 대한 기록**을 남겨 디버깅을 용이하게 함
  - 디버깅, 시스템 에러 추적, 성능, 문제점 향상들을 위해 사용
  - **로그 파일에 기록**하는 코드를 추가하여 필요한 정보가 로그로 남을 수 있도록 한다
- 어느정도까지 로그를 남길 것인가?
  - 회사마다 로그 정책이 있음: **로그 레벨**을 정의
    - severe, warning, info, config, fine, finer, finest 등
  - 너무 적은 로그 : 정확한 시스템의 상황을 파악하기 어려움
  - 너무 많은 로그 : 빈번한 file I/O의 오버헤드와 로그 파일의 백업 문제등...



로그 패키지

- log4j(오픈소스)
- java.util.logging(자바 기본 제공)
  - 파일이나 콘솔에 로그 내용을 출력할 수 있음
    - Logger가 Handler를 이용하여 로그를 남김
    - ConsoleHandler, FileHandler를 편집해서 로그의 출력 방식, 레벨 변경 가능
    - ConsoleHandler는 jre/lib/logging.properties 파일에서 편집 가능
  - logging 패키지에서 제공하는 로그 레벨은 severe, warning, info, config, fine, finer, finest
    - warning 이상은 exception이 발생하는 경우
    - config 밑으로는 별 문제 없고 info부터는 정보를 남김 
    - 처음에는 모든 레벨에 대해 다 로그를 남기고 시스템이 안정화되면 info부터 남기거나 함



### 6.5. 입출력



입출력 스트림이란?

- 스트림(네트워크용어): 자료의 흐름. 물의 흐름과 같다는 비유에서 유래됨
- 자바에서 입출력 스트림은 **다양한 입출력 장치에 독립적으로 일관성있는 입출력을 제공**
  - 파일 디스크, 키보드, 마우스, 네트웍, 메모리 등 모든 자료가 입력되고 출력되는 곳



입출력 스트림의 구분

- 대상 기준
  - 입력 스트림 : 대상으로부터 자료를 읽어 들이는 스트림
    - FileInputStream, FileReader, BufferedInputStream, BufferedReader 등
  - 출력 스트림 : 대상으로 자료를 출력하는 스트림
    - FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등
- 자료의 종류
  - 바이트 단위 스트림 : 동영상, 음악 파일, 실행 파일등의 자료를 읽고 쓸 때 사용
    - FileInputStream, FileOutputStream, BufferedInputStream, BufferedOutputStream 등
  - 문자 단위 스트림 : 인코딩에 맞게 2바이트 이상으로 문자를 처리하도록 구현된 스트림
    - 바이트 단위로 문자를 처리하면 깨지기 때문
    - FileReader, FileWriter, BufferedReader, BufferedWriter 등
- 기능
  - 기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림
    - FileInputStream, FileOutputStream, FileReader, FileWriter 등
  - 보조 스트림 : 직접 읽고 쓰는 기능은 없이 추가적인 기능을 더해주는 스트림
    - 기반 스트림이나 또 다른 보조 스트림을 생성자의 매개 변수로 포함함, Wrapper Stream이라고도 함
    - InputStreamReader, OutputStreamWriter, BufferedInputStream, BufferedOutputStream 등



표준 입출력 스트림

- System 클래스에 static으로 정의되어 있어 인스턴스 생성 없이 불러올 수 있음

  - System.out : 표준 출력 스트림

    - `System.out.println("출력 메세지");`

  - System.in : 표준 입력 스트림

    - ```java
      int d = System.in.read() // 한 바이트 읽기
      ```

    - **바이트 단위로 읽기** 때문에 한글을 읽어서 출력하면 깨짐

    - 이럴 때 보조 스트림을 쓰면 됨!

    - 이 경우엔 InputStreamReader(바이트를 문자로 바꿔주는 Class)로 System.in을 감싼다 

  - System.err : 표준 에러 출력 스트림

    - `System.err.println("에러 메세지");`



바이트 단위 입출력 스트림

- InputStream
  - 바이트 단위 입력 스트림 최상위 추상 클래스
  - 많은 추상 메서드가 선언되어 있고 이를 하위 스트림이 상속받아 구현함
  - 주요 하위 클래스
    - FileInputStream : 파일에서 바이트 단위로 자료를 읽음
    - ByteArrayInputStream byte : 배열 메모리에서 바이트 단위로 자료를 읽음
    - FilterInputStream : 자료를 읽을 때 추가 기능을 제공하는 모든 보조 스트림의 최상위 클래스
  - 주요 메서드 : 사용할 때 파라미터와 리턴 값의 의미를 잘 이해하고 쓰자
    - `int read()` : 입력 스트림으로부터 한 바이트의 자료를 읽고, 읽은 데이터 or -1를 반환(EOF인 경우)
    - `int read(byte b[])` : b[] 크기의 자료를 b[]에 읽고, 읽은바이트 수를 반환
    - `int read(byte b[], int off, int len)` : b[] 크기의 자료를 b[]의 **off변수 위치부터 저장**하며 len 만큼 읽고, 읽은 바이트 수를 반환
    - `void close()` : 입력 스트림과 연결된 대상 리소스를 닫음
    - close하지 않으면??
- OutputStream
  - 바이트 단위 출력 스트림 최상위 추상 클래스
  - 주요 하위 클래스
    - FileOutputStream : 파일에서 바이트 단위로 자료를 씀
      - 생성자 2번째 파라미터로 true를 받으면 파일 뒤에 이어쓰고 **default는 overwrite**임
    - ByteArrayOutputStream byte : 배열 메모리에서 바이트 단위로 자료를 씀  
    - FilterOutputStream : 자료를 쓸 때 추가 기능을 제공하는 모든 보조 스트림의 상위 클래스
  - 주요 메서드
    - `int write()` : 한 바이트를 출력
    - `int write(byte b[])` : b[] 크기의 자료를 출력
    - `int write(byte b[], int off, int len)` : b[] 배열의 off 위치부터 len 개수만큼 출력
    - `void flush()` : **출력 버퍼**를 강제로 비워 자료를 출력합니다. 
      - 소켓에서 많이 쓰임 : 기본적으로 버퍼가 꽉 차야 출력되는데 덜 찼을 때도 출력 가능하게 해줌
    - `void close()` : 출력 스트림과 연결된 대상 리소스를 닫고 출력 버퍼를 비움(flush() 동시 호출)



문자 단위 입출력 스트림

- Reader와 Writer를 이용하면 됨



보조 스트림

- 실제 읽고 쓰는 스트림이 아닌 보조 기능을 제공하는 스트림으로 **Decorator Pattern**으로 구현 됨
  - 생성자의 매개변수로 또 다른 스트림(기반 스트림이나 다른 보조 스트림)을 가짐
  - 기반 스트림과 보조 스트림을 감싸서 decorate함
- 예시
  - InputStreamReader와 OutputStreamWriter
    - 바이트 단위로 읽거나 쓰는 자료를 문자로 변환해주는 보조 스트림
    - `InputStreamReader isr = new InputStreamReader(new FileInputStream("reader.txt"))`
  - BufferedInputStream과 BufferedOutputStream
    - 입출력을 빠르게 하는 기능이 제공되는 보조 스트림, 문자용으로는 BufferedReader/Writer가 있음
    - buffer의 크기는 기본 8k이며 변경 가능함
    - `BufferedInputStream bis = new BufferedInputStream(new FileInputStream("a.zip"));`
    - BufferedReader는 `br.readLine()` 메서드를 가지는데 한 줄씩 읽을 때 많이 사용됨
  - DataInputStream과 DataOutputStream
    - 자료가 **메모리에 저장된 상태 그대로** 읽거나 쓰는 스트림



Decorator Pattern

![decorator](https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter6/6-19/img/decorator.png)

- 상속보다 유연하고 **기능확장에 용이함**
  - 데코레이터를 추가하면 기능이 추가되고, 빼면 기능도 삭제됨
  - 데코레이터를 추가할수록 기능이 더해짐: 위의 그림을 보면 Decorator에서 Operation을 구현하고 추가로 다른 데코레이터를 덧붙일때마다 다른 기능(AddedBehavior)을 할 수 있음
  - 여러 데코레이터를 조합하여 다양한 기능을 할 수 있음
- 데코레이터는 component를 하나 포함해야 함: object일 수도 있고 다른 decorator일 수도 있음



직렬화

- 어떤 데이터 구조나 객체를 **저장될 수 있는 상태로 전환**하고 나중에 재구성 가능한 포맷으로 변환하는 것

  - 역직렬화(deserialization) : 직렬화된 데이터를 다시 복원하는 것

- 직렬화는 왜 해야 하는가?

  - Reference Type 데이터들은 재사용이 불가 : 프로그램이 종료되면 메모리에서 해제되기 때문
  - 따라서 이를 전부 끌어모아서 **Value Type 데이터로 변환**해야 함

- 자바에서는 ObjectOutputStream으로 직렬화, ObjectInputStream으로 역직렬화를 수행

  - 직렬화를 하기 위해서는 Serializable 인터페이스를 구현해야 함

  - Socket등 직렬화 할 수 없는 객체에서는 직렬화 하지 않으려는 멤버 변수에 `transient`를 사용

  - 프로그래머가 직접 직렬화/역직렬화 하려면 Externalizable 인터페이스를 구현하면 됨

    - `writerExternal()`과 `readExternal()`메서드를 구현

    - ```java
      @Override
      public void writeExternal(ObjectOutput out) throws IOException {
      	out.writeUTF(name);
      }
      ```



기타 입출력 클래스들

- File 클래스
  - **파일의 속성**을 알 수 있음: 파일의 이름, 경로, 읽기 전용 여부 등
  - C언어와 달리 입출력 기능은 없음
- RandomAccessFile 클래스
  - 입출력 클래스 중 유일하게 **파일에 대한 입력과 출력을 동시에 할 수 있는** 클래스
  - 파일포인터를 움직여서 데이터를 읽고 쓰는 위치의 이동이 가능함
    - `seek()` 메서드를 이용



### 6.6. Tread



스레드란?

- 프로세스와 스레드
  - process : 실행 중인 프로그램. 프로그램이 실행되면 OS로 부터 메모리를 할당받아 프로세스 상태가 됨
  - thread : 프로세스에서 실제 작업을 수행하는 단위. 하나의 프로세스는 하나 이상의 thread를 가짐
- 멀티 스레딩
  - 여러 thread가 동시에 실행되는 것처럼 보임 : 사실 **context switching**을 통해 번갈아서 실행되는 것
  - thread는 각각 자신만의 작업 공간을 가짐 ( context )
  - thread 간 공유하는 자원이 있을 수 있음 (자바에서는 static instance)
    - 자원을 공유하여 작업이 수행되는 경우 서로 자원을 차지하려는 race condition이 발생할 수 있음
    - 경쟁이 발생하는 부분을 critical section 이라고 함
    - critical section에 대한 **동기화 구현**이 필요



스레드 생성

- Thread 클래스를 상속 extends
- Runnable interface를 구현 : 이미 다른 클래스를 상속받은 상황에서는 Thread를 상속할 수 없기 때문
  - 스레드를 생성할 때는 runnable 객체를 먼저 생성한 뒤 이를 Thread 생성자의 인자로 넣어줌
- 두 경우 모두 `run()`을 구현해야 함
  - 스레드가 시작되면(`start()`) 불리는 메서드



Thread Status

- 스레드가 생성되면(start) 스레드 풀 안에서 CPU 배분을 기다림(Runnable)
  - CPU를 배분받으면 Run, 스레드가 종료되면 Dead, 대기 상태로 들어가면 Not Runnable
- 자바에서 Not Runnable 상태로 진입하는 방법
  - sleep(time)
    - time만큼 잠들었다가 Runnable로 재진입 가능한 상태로 바뀜
  - wait()
    - 동기화 이슈가 있을 때 (공유 자원을 사용할 수 없을 때) 재움
    - resource가 available해지면 프로그램에서 `notify()`나 `notify all()`로 깨움
  - join()
    - 특정 스레드의 결과가 필요할 때 해당 스레드가 끝날 때까지 Not Runnable 상태에 들어감
    - `th1.join();`을 호출하면 **호출한 스레드에서** th1 스레드를 기다리는 것
- Thread가 not runnable 상태일 때 `interrupt()` 메서드를 호출하면 다시 runnable 상태가 될 수 있음



Thread 우선순위

- 우선 순위가 높은 Thread가 CPU의 배분을 받을 "확률이" 높음
  - 우선순위가 비슷한 경우에는 높아도 늦게 끝날 수 있음
  - `Thread.MIN_PRIORITY(=1)`부터 `Thread.MAX_PRIORITY(=10)` 까지 있음



Thread 종료

- 과거에는 `stop()` 메서드를 사용했으나 현재는 사용되지 않음
- while(flag)의 flag 변수값을 false로 바꾸는 식으로 종료시킴



#### 동기화

critical section 과 semaphore

- critical section : 두 개 이상의 thread가 동시에 접근할 수 없는 영역
- semaphore : 스레드가 critical section에 진입할 수 있게 하는 시스템 객체
  - get/release 두 개의 기능이 있음
  - semaphore를 얻은 thread만이 critical section에 진입하고 나머지 thread들은 대기(blocking) 



동기화 (synchronization)

- 자바에서는 synchronized 메서드나 synchronized 블럭을 사용하여 공유자원에 lock을 건다
- synchronized 블럭 : **현재 객체 또는 다른 객체에 lock을 걸어 접근을 제어**
- synchronized 메서드 : 객체의 메소드에 synchronized 키워드를 사용해 메서드가 속해있는 객체에 lock
  - **자바는 deadlock 방지가 없어** synchronized 메서드에서 다른 synchronized 메서드를 호출하면 안 됨
  - 상호배제, 점유대기, 비선점, 순환대기 4가지 조건 중 일부가 성립되지 않게 코드를 짜야 함



wait()과 notify()

- 리소스가 유효하지 않은 경우 Thread를 `wait()` 시키고, 유효해지면`notify()`로 깨움 
  - `notify()`는 대기중인 Thread 중 무작위로 하나를 재시작
  - `notifyAll()`이 호출되는 경우 wait() 하고 있는 모든 Thread가 재시작
    - 이 때 유효한 리소스만큼의 Thread만이 수행 : 자원을 갖지 못한 Thread는 다시 wait() 상태로
    - 자바에서는 notifyAll() 메서드의 사용을 권장



ThreadSafe

- 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 **각 스레드에서의 함수의 수행 결과가 올바르게 나오는 것**
- 애초에 공유 자원을 사용하지 않거나, 락을 걸어서 해결할 수 있음



### 6.7. JVM

![jvm](https://w.namu.la/s/1eb7f7a28c018c5f01e585756e72aa9dd3a7d87344754f0a6fd20dc7590ea7dc349477a930ed223f717f5599e49930adffb5bdf87a35dff38bce1b940a9ddfb6e56e3d695591725839b9c1e74b2b0de79ecad244a1b537221f8aea90c6e8dddc)

JVM(Java Virtual Machine)이란?

- Java로 개발한 프로그램을 컴파일한 바이트코드(`.class`)를 실행시키기 위한 **가상머신**

  - 어디서든(JVM이 실행가능한 환경이라면) Java 프로그램이 실행될 수 있도록 함
    -  JVM을 통해 Write once, Run anywhere를 가능하게 함
  - JVM은 운영체제에 종속적인 가상머신임

- Java가 아닌 언어로 쓰인 바이트코드도 인식 가능

  - Kotlin이나 Scala, Groovy 등

  

JVM의 구조

- Class Loader
  - JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치함
  - 런타임에 동적으로 클래스를 로드한다는 특징이 있음
- Runtime Data Area
  - JVM의 메모리 영역 : 자바 애플리케이션을 실행할 때 사용되는 **데이터들을 적재**함
  - Method Area, Heap, Stack, PC Register, Native Method Stack으로 나뉨
- Execution Engine
  - Runtime Data Area에 배치된 바이트 코드들을 instruction 단위로 읽어서 실행함
  - 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 **JIT 컴파일러** 방식으로 실행
    - 과거엔 순수하게 인터프리트만 하였으나 성능 개선을 위해 JIT 컴파일을 도입
  - JIT 컴파일 : 런타임에 **필요한 부분을 즉석으로 컴파일**하는 방식
    - 자주 쓸만한 코드들을 기계어로 변환해 저장해 두고 필요시 이미 변환된 기계어 코드를 재사용함
    - 빠르지만 변환 비용이 발생하기 때문에(초기엔 느림) 모든 코드를 JIT 방식으로 실행하지 않는 것
- Garbage Collector
  - 힙 메모리 영역에 생성된 객체들 중에서 **참조되지 않은 객체들을 탐색 후 제거**함
  - GC가 garbage를 수거하는 시간은 언제인지 정확히 알 수 없음



JVM의 성능

- 같은 기능의 네이티브 언어보다는 **느림**
  - 바이트코드가 기계에서 직접 실행되는 것이 아니라 JVM의 해석 단계를 거쳐 실행되고, 가비지 컬렉션을 위한 시간 등이 필요하기 때문
  - 인터프리터 방식으로 매우 느렸으나 JIT컴파일의 도입과 하드웨어의 발전으로 성능이 개선됨
- 일부 기능에 대해서는 네이티브 언어보다 **빠를 수 있음**
  - 메모리의 접근을 가상 머신 차원에서 관리하고 있으므로 런타임에 최적화가 가능하기 때문



JVM의 메모리

- Method Area
  - 모든 쓰레드가 공유하는 메모리 영역
  - 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 보관
- Heap
  - 모든 쓰레드가 공유하는 메모리 영역
  - new 키워드로 생성된 객체와 배열을 보관
    - **Garbage Collector**가 참조되지 않는 메모리를 확인하고 제거하는 영역
    - Method Area에 로드된 클래스만 생성이 가능함
  - Heap 메모리 해제는 오로지 Garbage Collection에 의해 수행됨
- Stack
  - 메서드 호출 시 각각의 메서드만을 위한 공간(**스택 프레임**)을 생성하는 영역
  - 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장
  - 메서드 수행이 끝나면 프레임별로 삭제
- PC Register
  - 쓰레드마다 하나씩 존재하는 영역
    - 쓰레드가 시작될 때 생성됨
  - 현재 수행중인 JVM instruction의 주소를 보관
    - 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 수행
- Native Method Stack
  - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역



heap 영역(심화)

![heap](https://mirinae312.github.io/img/jvm_memory/JVMObjectLifecycle.png)

- Young(nursery) space
  - 새로운 객체를 할당하기 위해 힙에 확보된 공간
    - 새로 생성된 객체는 Eden에 저장됨
  - Eden이 가득 차면 **Minor GC**(young collection)를 실행하여 **오래 머문 객체**들을 수집함
    - 참조되고 있는 Live Object는 Suvivor 영역으로 이동시킴
    - 참조되고 있지 않은 객체들은(garbage) 버림(메모리 해제)
    - 모든 Live Object가 Survivor 영역으로 넘어간다면 Eden 영역을 clear함
  - Survivor영역
    - 둘 중 한 영역은 비워져 있어야 함
    - 한 영역이 가득 차면 Minor GC를 수행하여 살아 남은 객체는 다른 survivor로 이동시킴
    - garbage는 버리고 해당 survivor 영역을 clear함
- Old space
  - Survivor에서도 계속 살아 남은 오래된 객체들이 old space로 이동됨
  - Old Space의 메모리가 충분하지 않으면 **Major GC**를 수행함
    - 메모리 사이즈도 크고, 워낙 오래 잘 참조된 객체들만 있어서 GC가 자주 일어나진 않음
- Permanent
  - 객체에 대한 메타 데이터와 Static Object, String Constant Pool, JIT의 최적화 정보 등이 저장되었었음
  - JVM에 의해 크기가 강제되던 Perm 영역의 사이즈 제한을 없애기 위해 Java8에서 **공중분해됨**
    - 기존에 객체를 Perm에 할당하지 못하는 OOM(Out Of Memory)문제가 자주 발생했기 때문
    - String Constant Pool, Static Object는 Heap 영역으로 이동하여 **GC가 더 잘 일어날 수 있게 됨**
    - 메타 데이터는 OS가 관리하는 영역(Native Memory)으로 이동



## **7. 예상 질문 리스트**



- 자료구조 관련
  - HashTable, HashMap이 어떻게 구현되어 있고 어떤 연산을 하는지?
- Spring
  - bean의 생성 주기
  - filter, intercepter가 언제 어떤 순서로 호출되는지
  - MVC의 탄생 배경
  - Spring framework의 탄생 배경과 목적
- JPA
  - 연관관계 매핑: N+1 문제가 언제 발생하고 어떻게 해결하는지?