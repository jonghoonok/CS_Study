# Network

네트워크이론 기초부터 심화까지



참고서적

- 그림으로 배우는 네트워크 원리
- Computer networking - Top down approach 
  - [이화여대 강의](http://www.kocw.net/home/cview.do?mty=p&kemId=1046412) "컴퓨터 네트워크" - 이미정



[TOC]

## **1. 네트워크 개요**



### 1.1. 네트워크 기초 지식

네트워크란?

- 컴퓨터끼리 **데이터를 주고 받는** 시스템(computer network)
- 인터넷은 **사용자 제한 없이** 전 세계의 컴퓨터를 연결한 네트워크
  - **사설 네트워크**의 경우 사용자가 제한됨



LAN과 WAN

|           |         LAN         |    WAN     |
| --------- | :-----------------: | :--------: |
| 역할      | 거점 내 기기간 연결 | LAN간 연결 |
| 구축/관리 |        직접         | 통신사업자 |



데이터 통신 개요

- 통신의 주체는 **어플리케이션**
- 통신은 **양방향**
  - 서버를 거치는 통신
    - 클라이언트 애플리케이션이 서버 애플리케이션에 request
    - 서버 애플리케이션이 reply
  - 서버를 거치지 않는 통신(Peer to Peer)
    - 클라이언트 애플리케이션끼리 직접 데이터 통신
- 데이터 교환을 원활히 하기 위한 통신 규칙: **프로토콜**
  - 통신 상대(주소) 설정, 순서 제어, 데이터 형식 등의 통신의 다양한 분야에 대한 규칙
    - **구문/의미/타이밍**의 3가지 요소로 구성됨
    - 구문(syntax): 데이터의 포맷, 형식
      - 전송되는 비트의 어느 부분이 무엇을 표현하는가?
      - 예) 데이터의 첫 8bit를 송신자의 주소, 나머지를 message로 정의
    - 의미(semantic): 데이터 각 항목의 의미와 같은 내용적 측면
      - 각각의 패턴이 어떤 식으로 해석되어야 하는가?
      - 데이터 제어 및 처리 방법, 에러 처리를 위한 정보
    - 타이밍: 언제 얼마나 빠르게 전송되는가?
      - 통신 속도 조절과 순서 관리를 위한 기법을 포함
  - HTTP(웹상에서 뭘 주고받는가?), TCP(어떻게 전송하는가?), IP(어디로 전송하는가?), 이더넷 등이 있음
  - 프로토콜의 집합이 **네트워크 아키텍처**
    - 프로토콜 스택이라고도 함
    - **TCP/IP**, OSI, Appletalk 등이 있음



네트워크 기기

- 데이터를 전송하는 기기
  1. 데이터 **수신**: 물리 신호를 디지털 신호로 변환
  2. 데이터 **수신처 결정**
     - 데이터의 **제어 정보**를 참조하여 전송할 곳을 결정: 제어정보는 각 계층의 헤더에 존재
     - 네트워크 기기의 차이는 여기에 있음: 어느 제어 정보를 참조하느냐에 따라 달라짐
  3. 데이터 **송신**: 디지털 신호를 물리신호로 변환하여 발신
- 기기의 종류
  - 라우터
  - 레이어2 스위치
  - 레이어3 스위치(내부 라우터 + 레이어2 스위치)



네트워크의 구성

- 구성 요소
  - 네트워크 기기
  - 인터페이스(포트)
    - 전기신호와 물리 신호의 경계(인터페이스): **네트워크 기기와 전송 매체의 접점**
    - 이더넷 인터페이스가 가장 일반적(컴퓨터 뒤의 LAN 포트)
  - 전송 매체
    - 인터페이스를 서로 연결하는 것
    - 유선 케이블 or 무선 전파
- 네트워크 구성도
  - 물리구성도: 각 기기의 물리적 배치와 인터페이스의 연결을 나타냄
  - 논리구성도: 네트워크간 연결을 표현 
    - 몇 개의 네트워크가 어느 라우터/레이어3 스위치로 연결되는지 정리
    - **하나의 네트워크는 라우터(레이어3 스위치)로 구분**되기 때문



### 1.2. 인터넷 기초 지식

인터넷은 어떻게 구성되는가?

- TCP/IP 프로토콜을 기반으로 전 세계의 **다양한 네트워크**(좁게는 AS)를 연결한 것: 

  - **Autonomous System** 자율 시스템

    - 독립적인 네트워크로 한 조직에 의해 관리됨
    - AS 내의 라우터들은 단일한 **라우팅 프로토콜**을 사용함
  
- ISP(Internet Service Provider)
  
    - 집이나 사업장에 유료료 **인터넷을 제공하는 공급자**
    - 각 ISP는 고유한 ASN(AS Number)를 갖고 있음: ASN은 BGP라우팅에서 사용됨
      
    - Border Gateway Protocol: AS간을 연결하는 Exterior Router Protocol의 한 예
    
  - 인터넷 상의 모든 ISP는 **Tier1**를 경유하여 연결됨
  
    - Tier 1: a network that **can reach every other network** on the Internet **without purchasing** [IP transit](https://en.wikipedia.org/wiki/Internet_transit) or **paying** for peering(대륙-국가 간 인터넷 트래픽 교환)
  
      ![tier1](https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Internet_Connectivity_Distribution_%26_Core.svg/825px-Internet_Connectivity_Distribution_%26_Core.svg.png)
      
    - Tier2는 1과 3을 연결해주며, Tier3이 개인이 흔히 사용하는 인터넷을 제공하는 ISP



인터넷은 어떻게 동작하는가? [MDN](https://developer.mozilla.org/ko/docs/Learn/Common_questions/How_does_the_Internet_work)

1. 서버 쪽 호스트가 **DNS 서버**에게 IP를 이름으로 바꿔달라는 요청을 보냄
   - **호스트**란 네트워크에 연결된 "컴퓨터"를 말함
     - 네트워크에 연결된 장치를 **노드**라 하고 **IP주소가 할당된 노드를 호스트**라 함
   - Domain Name System
     - IP가 아니라 **이름으로 연결하기 위한 서버**
     - DNS서버에 질의하는 기능은 "DNS 리졸버"라고 하며 OS에 내장되어 있음
       - 질의한 서버에 호스트명이 없으면 루트에서부터 **재귀질의**함
       - 질의한 정보는 한동안 서버와 리졸버의 캐시에 저장
2. 사용자는 먼저 ISP와 계약하고 로컬 네트워크의 라우터를 ISP의 라우터와 연결함
3. **웹 브라우저** 작동
4. 클라이언트 로컬에서(호스트 파일) 접속할 도메인 이름을 찾음
5. 없으면 DNS에 해당 이름의 IP 주소를 요청, 응답을 받음
6. DNS서버의 주소는 인터넷에 연결하는 순간 **DHCP**가 세팅해줌
   - **DHCP**(Dynamic Host Configuration Protocol)란?
     - 호스트의 IP주소와 각종 TCP/IP 프로토콜의 기본 설정을 자동 제공
     - 자동이므로 편리하나 DHCP 서버가 다운되면 IP 할당이 안됨
     - 할당된 IP주소는 임시적임
7. DNS가 제공한 IP주소를 이용해서 접속하여 통신



### 1.3. Web



웹이란?

- 인터넷상에서 **문서들**을 **연결**하여(HyperText) 정보 검색을 빠르게 할 수 있게 한 것
  - 웹사이트는 복수의 웹페이지(HTML 파일)로 구성됨
  - 문서의 레이아웃 및 디자인은 스타일 시트로 정의되며 **CSS**언어로 기술됨
- 클라이언트-서버 간 **HTTP 프로토콜** 을 사용하여 **HTML을 주고받는 시스템**



HTTP 프로토콜

- 웹상에서 데이터를 빠르게 교환하기 위해 TCP를 기반으로 개발된 통신 프로토콜
  - 원래 하이퍼텍스트 교환이 목적이었으나 최근에는 JSON, pdf등 이런저런 데이터를 다 이용함
  - HTTP 통신은 **Request**와 **Response**를 주고받으며 이루어짐
- Request
  - 요청라인 + 메시지 헤더 + (공백) + entity 바디
  - 리퀘스트 라인: **HTTP method** + URL + version
    - HTTP method: GET, POST, PUT, PATCH, DELETE 등
    - version은 그냥 HTTP의 버전을 나타냄
  - 메시지 헤더는 웹브라우저 종류/버전, 대응하는 데이터 타입 등을 기술
  - entity 바디는 **POST에서 데이터를 담아 보낼 때** 사용
- Response
  - 상태라인(status) + 메시지 헤더 + (공백) + entity 바디
  - 리스폰스 라인: 버전 + 상태 코드 + 설명문
    - [Response Code](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)
    - 설명문은 상태 코드의 의미를 간단히 보여줌
  - entity 바디에는 브라우저에 돌려보낼 데이터 포함: 주로 HTML
- 특징: **비연결성, 무상태**
  - 비연결성: 리소스를 아끼기 위해 비연결성을 띔
    - 잦은 연결/해제는 오버헤드를 초래함
  - 무상태: 비연결성으로 인해 클라이언트를 식별할 수 없는 것
    - 그럼 어떻게 식별하냐? : **쿠키/세션/토큰**을 이용하여 기억함



**웹 브라우저란?**

- **웹 기반 컨텐츠**(웹페이지)를 검색 및 열람하기 위한 어플리케이션

  - 서버에서 **컴포넌트 파일**(코드 파일 + 자원)을 가져옴
  - 코드 파일: HTML, CSS, JavaScript
  - 자원: 웹사이트를 만드는 모든 다른 것들 - 이미지, 음악, PDF 등

- 구성: UI - 브라우저 엔진 - 렌더링 엔진, 통신, JS해석기, 임시파일저장소

  ![ㅇ](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)

- 렌더링 동작 과정

  - html가져옴 - **DOM트리 작성** - CSSOM트리 작성 - 2개 결합해 렌더트리 생성
    - DOM트리는 HTML태그들의 계층관계를 나타낸 것
    - 문서객체모델(DOM)에서 모든 HTML 태그는 객체로 취급
    - JS를 통해 페이지를 조작할 때 객체를 사용함
  - 객체들에게 위치,크기 지정(레이아웃) - CSS속성 적용 - 화면 업데이트
  - 도중에 JS를 발견하면 JS엔진 실행했다가 다시 DOM 생성함



#### 클라이언트의 식별(인증)

서버 기반 인증

- 서버에서 **세션**을 이용해 사용자의 정보를 기억하고 인증을 처리함
- 대규모 시스템에 부적합함
  - 세션이 서버의 메모리를 과도하게 차지하여 서버 확장의 부담이 있음
  - **CORS** 이슈 있음
    - 세션 관리에 사용되는 **쿠키**를 여러 도메인에서 관리하려면 CORS 설정이 필요함
    - 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문



쿠키, 세션, 캐시

- 쿠키
  - **사용자 인증**을 위해 사용됨 : 주로 자동 로그인에 이용됨
  - 키-값의 데이터 파일, **웹서버에서 PC로 **보내주는 파일을 로컬에 저장
  - 웹사이트 접속시 발생, 유출돼도 큰 일 없을 정보들(로그인 정보, 열람 이력)
    - 쿠키는 변조 등 **보안상 취약**하기 때문에 잘 쓰지 않음(사실 작은 사이트에서는 잘 쓰고 있음)
  - **만료기간**이 있어 자동 삭제됨
    - 저장할 때 expires 속성을 정의하여 삭제될 날짜 지정 가능
- 세션
  - 사이트와 브라우저 사이의 상태를 유지시킴
    - 연결 그 자체를 세션이라 하기도 하고 통신을 마칠 때까지의 기간을 뜻하기도 함
  - 클라이언트는 세션 아이디(클라이언트 식별자)를 **쿠키**를 이용해 저장
  - **세션 자체는 서버에 저장**
    - 서버의 메모리를 차지하고 과부하의 원인이 됨
  - 언제 삭제될지 알 수 없음
- 캐시
  - **웹페이지를 빠르게 렌더링**하기 위해 사용됨
  - 웹페이지요소(Response), 그림파일 등
  - 수동 삭제 필요, 캐시가 너무 많이 쌓이면 브라우저 속도 저하됨



토큰 기반 인증

- 사용자에게 **토큰**을 발급하고, 서버에 요청할 때 토큰을 헤더에 포함시키도록 해 토큰으로 인증함
  1. 사용자가 아이디와 비밀번호로 로그인
  2. 서버 측에서 해당 정보를 검증
  3. 정보가 정확하다면 서버 측에서 사용자에게 Signed 토큰을 발급
     - Signed : 토큰이 서버에서 정상적으로 발급된 것임을 증명하는 Signature를 가지고 있다는 뜻
  4. 클라이언트는 토큰을 저장해두고, 서버에 요청을 할 때마다 Http request 헤더에 토큰을 포함시켜 전달
  5. 서버는 토큰을 검증하고, 요청에 응답
- 장점
  - 클라이언트에서 들어오는 요청만으로 처리하므로 Stateless함  
  - 쿠키 사용에 의한 취약점이 사라짐
  - Extensibility : 로그인 정보가 사용되는 분야(OAuth 등)의 확장성을 가짐
  - CORS를 해결하여 여러 플랫폼 및 도메인에 대해 확장할 수 있음



CORS(Cross-Origin Resource Sharing)

- 한 출처에서 실행중인 웹 애플리케이션이 **다른 도메인의 리소스에 접근할 수 있게**하는 보안 메커니즘
  - 현대 웹 브라우저에서는 기본적으로 다른 도메인 리소스에 접근 불가 : CORS 에러 발생
  - 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 **CORS 요청**을 실행
- CORS 동작 방식
  - 브라우저가 리소스를 요청할 때 추가적인 HTTP 헤더에 자신의 정보를 담음
    - 브라우저의 origin, 사용할 메소드, 포함할 헤더들 등
  - 서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 전송
  - 브라우저는 해당 리스트에 자신이 포함되어 있다면 리소스 전송 허용하고 불가능하다면 에러 발생시킴
- CORS 등장의 배경
  - **동일 출처 정책**(Same Origin Policy) : **CSRF**를 방지하고자 HTTP 요청을 동일한 출처로 제한하게 됨
  - 허용한 origin들만 요청할 수 있도록 하여 외부 피싱 사이트 등이 세션을 획득하지 못하게 막음



CSRF(Cross Site Request Forgery)

- **유저를 가장**해서, **해커가 원하는 요청을 보내 서버를 공격**하는 것
  - 유저가 타겟 사이트에(예 : 은행) 로그인이 되어있는 상황에서 (쿠키에 세션 아이디가 저장되어 있는 상황) 
  - 해커는 위변조한 가짜 사이트나 이메일을 통해서 **유저가 타겟 사이트에 요청을 보내게**끔 함(XSS)
  - 권한이 필요한 HTTP 요청이 타겟 사이트 서버에 전송되어 공격이 실행됨
- 이를 막기 위해 난수를 발행하여(**CSRF 토큰**) 해당 난수가 없는 요청이 온다면 요청을 거부함
  - 유저가 정말 변경을 원하는 경우에만 변경시키는 것



토큰의 종류

- 요청 토큰: 소비자가 사용자에게 접근권한을 인증받기 위해 필요한 정보
- 접근 토큰: **인증 후**에 사용자가 소비자를 통해 보호 자원에 접근하기 위한 키 값
- CSRF 토큰
  - 랜덤한 수를 사용자 세션에 저장하고, 요청 페이지에 CSRF 토큰을 담아 전송함



## **2. OSI 7계층**

> Open Systems Interconnection Reference Model
>
> 국제 표준화기구에서 개발한 것으로 **네트워크 아키텍처의 개념을 계층별로 정의하는 모델**임



계층이란?

- 상하 관계를 이루는 하나 이상의 엔티티가 기능을 구현하는 단위
  - 각 계층은 **하위 계층의 기능을 이용하여 상위 계층에 기능을 제공**
- 계층별로 헤더가 붙음
- 계층 목록
  - Application, Presentation, Session, Transport, Network, Datalink, Physical



계층 분할의 필요성

- **표준화**를 통해서 다양한 환경과 프로토콜로 인해 발생할 수 있는 문제를 해결, 비용을 절감
- 계층별로 기능과 통신 과정을 나누어 이해하기 쉬움
- 문제가 발생했을 때 해당 단계만 수정할 수 있어 편리함



물리 계층

- 단위: bit
- 장치: 허브(리피터), 케이블
  - 허브 : 중계기로써 장비를 다른 네트워크 기기(허브, 라우터)와 연결해주고 네트워크 상태 점검도 수행함
  - 리피터 : 신호를 증폭해 줌
- 통신 **케이블로 데이터를 전송**하기 위한 계층
  - 물리적 연결의 성립 및 종료, 전기 신호 변조/복조
  - 장치들을 연결하기 위해 필요한 전기적, 물리적 세부 사항들을 정의 : 핀들의 배치나 전압, 전선의 명세 등



데이터 링크 계층

- 단위: 프레임(데이터+헤더+트레일러)
- 장치: 스위치/브리지
  - 브릿지 : 이더넷 장비를 물리적으로 연결하는 장치로 리피터의 상위 기기(리피터의 기능을 모두 가짐)
  - 스위치 : 브리지의 기능을 모두 가지나 스위칭 속도가 더 빠름
- **프레임에 MAC주소를 부여**하고 이를 통해 통신함
  - 데이터 링크 계층에서는 해당 네트워크 안에서만 통신이 가능(직접 이어진 곳에만 연결 가능)
- 포인트 투 포인트 간 **신뢰성 있는 전송 보장**: 오류 제어/흐름 제어/ 회선 제어
  - 오류제어: 검출은 여기서 하고 수정은 전송 계층에서
  - 흐름제어: 전송 데이터의 양을 제한하는 기술([흐름제어와 혼잡제어](#흐름제어/혼잡제어) 참고)
  - 회선제어: 신호 간 충돌이 발생하지 않도록 제어하는 기술



네트워크 계층

- 단위: **패킷**
  - 네트워크 상에서 데이터를 전송하는 기본 단위
  - 패킷
    - 전송 경로를 확립한 이후에 **TCP 프로토콜로 전송**되는 단위
    - 복잡하고 큰 헤더를 가지며 ACK, FIN, SYN 등 다양한 정보를 포함함
  - 데이터그램
    - 비연결성으로 신뢰성이 중요하지 않은 경우에 (주로) **UDP 프로토콜로 전송**되는 패킷
- 장치: **라우터**
  - 라우터는 컴퓨터간 연결 수를 줄이기 위한 근거리 허브
  - ISP: 원거리의 라우터를 연결함
- 다른 네트워크에 있는 상대 호스트까지의 **경로를 찾아주는 역할**
  - 전송 계층이 요구하는 서비스 품질을 제공하기 위한 기능적, 절차적 수단을 제공
  - IP주소를 지정하고 라우팅 프로토콜을 사용하여 최적의 경로를 선택함
  - 해당 경로를 따라 패킷을 전달



전송 계층

- 단위: 세그먼트
- 프로토콜: TCP, UDP
  - 이외에 다른 프로토콜도 있으나 이 둘이 인터넷 상의 거의 모든 트래픽을 구성함
- **신뢰성있는 데이터를 주고 받을 수 있도록** 하여 상위 계층들이 유효성이나 효율성을 생각하지 않도록 함
  - 오류검출 및 복구 : 시퀀스 넘버 기반의 오류 제어 방식을 사용함
  - TCP의 경우 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송해 유효성을 확보함



세션 계층

- 단위: 메세지, 데이터
- 장치: L5 스위치
- 양측 **응용 프로세스가 통신을 관리하기 위한 방법을 제공**
  - TCP/IP 세션을 만들고 없앰
  - 통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 수행



표현 계층

- 단위: 메세지, 데이터
- 사용자 시스템에서 **데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어줌**
  - 코드 간의 번역을 담당함
  - 데이터 부호화, 변환: 파일 인코딩이나 명령어 포장/압축/암호화 등을 진행



어플리케이션

- 단위: 메세지, 데이터
- 프로토콜: HTTP, FTP, POP3 등
- **직접적으로 응용 프로세스와 관계**하여 여러 가지 프로토콜 개체에 대해 UI 제공
  - 프로세스는 **소켓**에 데이터를 담아서 전달함(웹소켓과는 다름)
    - 소켓은 프로세스가 데이터를 내보내고 받는 창구
    - 한 프로세스가 여러 소켓을 가질 수 있음
    - 소켓은 전송 프로토콜(TCP/UDP), IP주소, **포트 넘버**로 정의됨



## **3. TCP/IP**

> TCP와 IP를 중심으로 하는 프로토콜의 집합으로 가장 많이 이용되는 네트워크 아키텍처



### 3.1. TCP/IP 계층구조

TCP/IP 아키텍처는 4계층으로 구성되고, 상위 3계층은 통신 상대와 같은 프로토콜을 사용함

![model](https://www.guru99.com/images/1/093019_0615_TCPIPModelW3.png)

- 애플리케이션층
  - 애플리케이션에서 다룰 **데이터 형식과 절차를 결정**함
    - 인간이 인식할 수 있는 형태(문자, 이미지 등)로 데이터를 표현
  - 프로토콜: HTTP, SMTP, DHCP, DNS 등
  - 데이터 명: 메시지
- 트랜스포트층
  - 애플리케이션에 **데이터를 분배**하거나 분할/조립을 수행함
    - 여러 애플리케이션의 데이터를 수신하여 각 애플리케이션으로 할당함
  - 프로토콜: TCP/UDP (두 개밖에 없음)
  - 데이터 명: 세그먼트(TCP), 데이터그램(UDP)
- 인터넷층
  - 엔드투엔드 통신: **네트워크 간**의 데이터 전송
    - 네트워크끼리 연결하고 데이터를 전송하는 기기가 **라우터**
  - 프로토콜: IP, ICMP, ARP 등
  - 데이터 명: **패킷** 또는 데이터그램
    - 패킷: 정보를 **일정한 크기**로 분할한 뒤 각 데이터에 송수신 주소 및 부가 정보 입력
    - 패킷 교환: 원거리 통신망의 연결 기술로 전체 메시지를 **각 노드가 수용 가능한 크기(패킷)으로 잘라서** 송수신
- 네트워크 인터페이스층
  - **같은 네트워크** 내 **인터페이스 간**에 데이터를 전송함
    - 한 네트워크는 **레이어2 스위치**에 의해 구성됨: 스위치에 의해 **이더넷 프레임**이 교환됨
  - 프로토콜: **이더넷**, 무선LAN, PPP 등
  - 데이터 명: 프레임



TCP/IP에서 송수신의 흐름

- 캡슐화
  - 송신시 각 **계층별로 헤더를 추가**하는 것
  - 수신시 각 계층별로 헤더를 참조하여 처리하고 벗기는 것은 역캡슐화
- FCS(Frame Check Sequence)
  - 네트워크 인터페이스층에서는 이더넷 헤더 및 에러체크정보 FCS를 추가함
  - FCS가 추가되면 캡슐화 완료: 송신 준비 끝
- 목적지로 송신
  - **IP 주소**를 지정하여 목적지의 인터페이스까지 IP 패킷을 송신
  - 인터페이스는 **MAC주소**로 구분됨
    - IP주소에 대응하는 MAC주소를 대응시키는 **주소 해석** 필요
    - **Address Resolution Protocol**: 목적지 IP 주소 설정시 자동으로 실행되어 **같은 네트워크 내**에서 목적지의 MAC주소를 반환
    - 자세한 사항은 인터넷 계층 참고



IP 주소

- IP란?
  - 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 **정보 위주**의 규약
  - 엔드 투 엔드: 즉 **호스트 간** 통신을 하는 것
- IP주소란?
  - 호스트의(인터페이스) 식별 정보
    - 각 인터페이스별로 IP주소 지정 가능(안할수도 있음)
  - IPv4의 경우 32비트로 **도트형 10진표기**로 나타냄
    - `255.192.10.1` 같이 10진수로 표시하는 것
- IP주소의 구성
  - **유니캐스트**의 경우 네트워크부와 호스트부 2가지로 구성됨
    - 유니캐스트: 단 한 곳으로 데이터를 전송
    - 어디까지가 네트워크부인지 명시한 것이 **서브넷 마스크**
      - 보통 prefix표기를 이용: 192.168.1.1/24 (앞의 24비트가  네트워크부)
    - 호스트부를 모두 0으로 채우면 **네트워크 주소**, 1로 채우면 **브로드캐스트 주소**
  - **브로드캐스트**는 255.255.255.255를 사용하거나 호스트부의 비트를 모두 1로 한 주소를 가짐
    - 브로드캐스트: 같은 내트워크 내 모든 호스트에게 똑같은 데이터를 전송
  - **멀티캐스트**는 224.0.0.0 ~ 239.255.255.255로 범위가 정해져 있음
    - 멀티캐스트: 특정 그룹에 포함되는 호스트들에 똑같은 데이터를 전송
- 이용범위에 따른 구분
  - 퍼블릭 IP 주소: 인터넷에서 사용하는 주소
    - 인터넷 통신을 위해서는 반드시 퍼블릭 IP주소가 필요
  - 사설 IP 주소: 사설 네트워크에서 이용하는 IP주소
    - 지정된 범위가 있으며 다른 네트워크와 겹치더라도 네트워크 내에서의 통신에는 문제 없음
  - **NAT**(Network Address Translation)
    - 사설네트워크 - 인터넷 통신에 필요: 목적지가 사설 주소로 된 IP패킷은 폐기됨
    - **라우터가** 출발지 IP주소를 퍼블릭 IP주소로 변환하여 요청하고 응답을 받으면 해당 사설 IP 주소로 데이터를 보냄



MAC 주소

- **하드웨어의 고유한 식별번호**: OS에 "할당"되는 IP주소와 달리 불변하는 물리 주소임
  - 기기 자체를 식별함
    - IP주소는 "호스트가 네트워크 상에서 **어디 있는가**"를 나타냄
    - MAC주소는 **누구인가**를 나타냄: MAC주소만 있으면 통신이 매우 어려움
      - 통신을 위해 전화번호부를 계속 뒤지는 것과 같기 때문
  - 네트워크 인터페이스에 할당됨
    - Network Interface Controller 제작사에서 할당하며 48bit로 구성됨
  - 외부에서 내부의 사설 네트워크로 통신할 때 중요
    - 사설 IP를 외부에서 볼 수 없으나 MAC주소를 알고 있으면 도달가능하기 때문
- MAC주소의 구성
  - 24bit OUI + 24bit Serial Number
    - OUI: 이더넷 인터페이스 제조 벤더 식별 코드
    - 시리얼 넘버: 각 벤더가 하드웨어에 할당
  - 4bit씩 끊어서 16진수로 표기하여 '-'로 구분하는게 일반적
    - 내 노트북 bluethooth 이더넷 어댑터는 `3C-A0-67-A5-40-EA` 임



### 3.2. Transport Layer

> 데이터를 (분할하여) 송신하고, 수신한 후 어플리케이션이 사용할 수 있도록 조립 및 분배



등장 배경

1. 호스트 간 이동은 인터넷층(IP)에서 해결 되나 **한 장치 내 여러 프로그램이 통신**할 경우 IP로는 한계가 있음
2. IP는 **best effort**: 데이터 보내는 데에는 최선을 다하나 안 되면 말고ㅎ
3. 이를 보완하기 위해 **ICMP**가 나왔지만 오류 보고만 하지 대응은 못함
4. 1을 해결하기 위해 **포트 번호**가 등장했고 2, 3을 해결하기 위해 **전송 계층** 도입



포트 번호

- 어플리케이션에 데이터를 할당하기 위해서 **어플리케이션 식별**이 필요
  - TCP/UDP 헤더에 어플리케이션을 식별하는 포트번호를 지정
  - 포트번호는 16bit로 0~65535
- **well-known port number**
  - 주요 어플리케이션 프로토콜의 포트 번호로 미리 지정되어 있음(0~1023)
  - HTTP: 80, HTTPS: 443, SMTP: 25 등
- registered port number
  - well-known 이외에 자주 이용되는 서버 어플리케이션 식별용 포트번호
  - 나머지는 동적/사설 포트번호로 통신 시 동적으로 할당됨



Transmission Control Protocol

- 애플리케이션 간의 통신에서 **신뢰성 확보**가 필요할 때 사용됨

  - 전화를 거는 것처럼 연결, 안정적으로, 순서대로, 에러 없이

- 데이터 전송 절차는 커넥션 수립 - 송수신 - 커넥션 끊기

  - 커넥션 수립 단계에서 통신이 가능한지 **3-way handshake**로 확인

    ![3way](https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png)

    1. 통신하고 싶다는 메시지 보내기(SYN)
    2. 상대가 준비됐다고 보냄(SYN+ACK)
       - 서버의 해당 포트는 Listen 상태에서 syn데이터를 받고 syn_rcv상태로 변경
    3. ACK로 응답
       - syn+ack를 받은 클라이언트는 established 상태로 변경되고 ack를 전송
       - ack를 받은 서버도 established 상태로 변경됨

  - **4-way handshake**

    1. 통신하고 싶다는 메시지 보내기
       - 클라이언트가 서버에게 FIN을 보낸 후, FIN_wait 1 상태로 대기함
    2. 상대가 준비됐다고 보냄
       - 서버는 상태를 Close_wait로 변경, ack를 전송하는 동시에 **애플리케이션에 close()를 요청**
       - 클라이언트는 상태를 fin_wait 2 로 변경
    3. 상대가 추가로 FIN을 보냄
       - 어플리케이션이 종료되면 fin을 클라이언트에게 보낸 후 상태를 last_Ack로 변경
    4. ACK로 응답
       - fin_wait 2 상태에서 fin을 받으면 ack를 보낸 후 상태를 **time_wait**로 변경
       - ack를 받은 서버는 closed로 변경하고, 클라이언트도 일정 시간이 지나면 closed로 변경

  - 송신 시 **데이터 크기가 크면 분할**, 분할 방식을 TCP헤더에 기술(고유번호) 

    - 수신 시 이를 참조해 데이터를 조립하고, 확인응답(ACK) 회신
    - 일부 데이터가 제대로 도착하지 않으면 **재송신**
    - 네트워크 혼잡 시 속도 제한: **플로우 제어**



User Datagram Protocol

- TCP에서 신뢰성 기능을 뺀 것
  - **스트리밍** 하려고 만든 것임: 데이터가 다소 유실되는 것보다 속도가 중요
  - **실시간성**을 보장해 주는 **비연결형**임
  - 헤더가 아주 간단하기 때문에 TCP보다 용량이 적고 속도가 빠름
- DNS 는 request의 양이 적고 연결을 유지할 필요가 없기 때문에 UDP를 사용함
  - 신뢰성 문제는 어플리케이션층에서 해결가능(Timeout추가, resend 등)
  - 데이터가 512바이트를 넘거나(UDP segment) 연결을 못 받은 경우엔 TCP 사용



#### 흐름제어/혼잡제어

Flow Control: **송신측과 수신측**의 데이터 처리속도 차이 해결
- sender에게 **receiver가 자신의 상태를 feedback**하여 패킷을 지나치게 많이 받지 않도록 함
- 해결 방법
  - Stop & Wait: 매 패킷마다 확인 응답을 받아야 그 다음 패킷을 전송
  - Sliding Window: **수신측에서 설정한 윈도우 크기**만큼 송신측에서 확인응답 없이 세그먼트 전송, ACK를 받으면 버퍼의 범위가 한꺼번에 이동



Congestion Control: **송신측의 데이터 전달과 네트워크**의 데이터 처리 속도 차이를 해결

- 한마디로 많이보내면 혼잡해지니까 속도를 조절하는 것
- 해결방법
  - AIMD(Additive Increase Multicative Decrease, 합 증가 곱 감소)
    
    - 윈도우 크기를 선형적으로 증가시키고 혼잡을 감지하면 절반으로 줄임
    - 처음에 전송 속도를 올리는 데 시간이 너무 길다는 단점 존재
    - 공평함: 여러 호스트가 한 네트워크 공유시 평형상태로 수렴하게 됨
    - 반복되면 톱니모양처럼 보인다고 하여 AIMD Sawtooth라고 함
    
    ![aimd](https://mlga3gjkilfa.i.optimole.com/7hU5Bn8-edeag6dx/w:351/h:154/q:90/https://www.keyboardbanger.com/wp-content/uploads/2015/08/tcp-congestion-control-sawtooth-AIMD.png)
    
  - Slow Start
    
    - 패킷을 하나씩 보내고 **임계치에 도달할 때까지 윈도우 사이즈 2배씩 증가**시킴
    - Timeout 발생시 사이즈를 1로 만들고, 임계치가 될 때까지 지수적으로 증가
    - Congestion Avoidance: 임계치(혼잡이 발생했던 window size의 절반)를 넘으면 선형적으로 증가
    - Fast Retransmit: 중복된 패킷을 3개 받으면 혼잡으로 손실됐다고 간주, **즉시 재전송**
    - Fast Recovery: 패킷 손실 후 임계치와 윈도우 사이즈를 손실 당시의 절반으로 재설정
    
    ![slow](https://www.researchgate.net/profile/Romain_Delpoux/publication/267783414/figure/fig5/AS:669531638861835@1536640190532/Slow-start-fast-retransmit-and-fast-recovery-illustration.pbm)



### 3.3. Internet Layer

> 네트워크 간의 엔드 투 엔드 전송



IP: 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 **정보 위주**의 규약

- 호스트의 주소 지정, 패킷 분할 및 조립 기능 담당
  - 호스트란 네트워크에 연결된 "컴퓨터"를 말함
  - 네트워크에 연결된 장치를 노드라 하고 IP주소가 할당된 노드를 호스트라 함
- 특징
  - 비신뢰성/비연결형
  - 에러제어, 흐름제어 없음: 에러 검출은 하지만 보낸 내용을 보장하지 않음
- **MTU(Maximun Transfer Unit)** 때문에 IP패킷을 잘라서(단편화) 보냄
  - 패킷의 MTU는 1500 byte: 이더넷 프레임은 최대 1518 byte가 됨
- IPv6
  - IPv4가 가진 주소 고갈, 보안성, 이동성 지원 등을 해결하기 위해 등장
  - 보안성: 패킷 출처 인증, 데이터 무결서 및 비밀 보장 기능
  - 이동성: 네트워크의 물리적 위치에 제한받지 않음



ICMP: Internet Control Message Protocol

- 통신이 정상적으로 이루어졌는지 확인하기 위해 등장한 프로토콜
- 주요 기능: 에러 리포트, 진단
  - 에러리포트: 어떤 이유로 IP패킷이 폐기되면 폐기한 기기가 ICMP를 이용해 패킷의 출발지로 **도달불능 메시지**를 보냄
  - 진단: **ping command** 등으로 IP의 엔드투엔드 통신이 가능한지 체크
    - ICMP 헤더에 "에코 요청 메시지"를 기술하여 보낸 데이터를 그대로 돌려받음
    - 데이터를 수신하면 통신 가능함을 확인
    - **게임에서의 핑**은 클라이언트가 보낸 정보가 "다른 사용자들이 보낸 정보와 함께" 서버에서 처리되고 돌아오는데 걸리는 시간으로 ms 단위로 표기됨



#### 3.3.1. 라우팅

> 라우터가 IP패킷을 전송하는 것
>
> 어떤 경로로 보낼 것인가? 다음 라우터는 어떻게 찾는가?



라우팅이란?

- **다른 네트워크**에 데이터를 보내기 위해 **IP주소**를 기반으로 데이터의 목적지를 찾는 것
  - 라우팅의 반복을 통해 데이터를 목적지까지 송신하는 것이 가능
  - 라우터에서는 연결 대상인 네트워크의 IP주소를 이용해 인터페이스 IP주소를 설정
    - 예) 네트워크1(192.168.1.0/24) - 인터페이스1(192.168.1.254/24)
- 라우터는 **라우팅 테이블**을 이용하여 IP패킷을 전달



라우팅 테이블

- 라우팅 테이블에는 **Next Hop**(다음 라우터)와 그에 대응되는 IP 주소가 기록되어 있음
- 테이블에 경로 등록하는 방법은 3가지 존재
  - 직접 접속: **라우터가 직접 연결된** 네트워크의 경로정보
  - static routing(간접, 수동): 라우터에 직접 연결되지 않은 네트워크 주소를 수동으로 등록
  - dynamic routing(간접, 자동): **라우터끼리 정보를 교환**해 테이블에 필요한 경로를 등록
- 목적지 IP주소가 라우팅 테이블에 상에서 인식할 수 없으면 IP패킷은 **폐기**
  - 그럼 테이블에 수많은 IP 주소를 다 등록해야 하는가?
  - **경로요약**: Next Hop이 동일한 네트워크들의 경로 정보를 하나로 모아 등록
    - IP주소에서 겹치는 부분을 네트워크부로 처리하고 Next Hop을 등록
    - 예를 들어 10.2.0.0/24, 10.2.1.0/24의 Next Hop이 동일하다면 10.2.0.0/16으로 등록
    - 모든 네트워크를 집약하면 0.0.0.0/0 인 **디폴트 경로**가 됨
    - PC의 라우팅 테이블에는 직접 접속 경로 정보와 디폴트경로만(**기본 게이트웨이**) 등록



라우팅 순서

1. 라우터가 호스트로부터 IP 패킷을 수신
2. **테이블에서 Next Hop을 탐색**
3. 수신한 IP패킷의 이더넷 헤더에는 현재 라우터의 MAC주소가 목적지로 되어 있음
4. **ARP를 실행**하여 **Next Hop의 MAC주소를 얻고 이더넷 헤더 + FCS 교체**
5. IP헤더의 TTL(Time To Live, 패킷의 수명)에서 1을 빼준 후 송신
   - 라우팅 시에 IP주소는 변하지 않음: NAT로 변환하면 달라짐
6. 수신한 라우터는 다시 라우팅 테이블을 통해 라우팅 실시
   - Next Hop이 작접 접속되어 있다면 위와 같이 ARP를 거쳐 송신하고 종료



ARP: Address Resolution Protocol

- ARP의 원리
  - **브로드캐스트**를 통해 목적지 물리주소를 요청
  - 수신자 중 해당되는 수신자만 **유니캐스트**를 통해 논리주소와 물리주소를 응답
- ARP의 동작 순서
  1. 송신자는 목적지 IP 주소를 담아 패킷 제작
  2. IP프로토콜이 ARP 프로토콜에게 **ARP 요청 메시지**를 생성하도록 요청
  3. 메시지는 이더넷 프레임으로 캡슐화 후 브로드캐스트로 송신
  4. 모든 호스트 및 라우터는 수신한 프레임을 자신의 ARP 프로토콜로 전달
  5. 목적지 IP 주소가 일치하는 수신자는 자신의 물리주소를 담아 ARP 응답 메시지를 송신
  6. 송신자, IP 주소에 대응하는 물리주소 획득



게이트웨이란?

- 두 네트워크 간의(LAN 구간의 이더넷 - WAN) 인터페이스를 담당하는 네트워크 기기
  - 넓은 의미에서는 프로토콜 간의 변환을 담당하는 인터페이스 : 애플리케이션 간 상호작용을 맡기도 함
  - **Common Gateway Interface**가 넓은 의미에서의 게이트웨이를 뜻함
    - 웹 서버와 웹 어플리케이션 간의 통신 규칙
    - 웹 어플리케이션을 CGI 프로그램이라 하고, Java로 만들어진 CGI 프로그램은 Servelet이라 함
- 라우터의 상위 개념: 경로 탐색, 네트워크 간 연결 수행 가능
  - 최근에는 한 장비 안에 같이 탑재되는 경우가 많음
  - 라우터가 아니더라도 static routing이 가능하면 게이트웨이의 역할 수행 가능
  - 라우터는 여기에 더해 dynamic routing을 수행 가능



### 3.4. Network Interface Layer	

> 같은 내트워크 내 인터페이스간의 전송



이더넷

- 같은 네트워크 내에서 전송하는 프로토콜
  - 한 이더넷 인터페이스에서 다른 이더넷 인터페이스까지 전송
  - **레이어2 스위치**를 거쳐서 전송: 스위치는 **데이터에 변경을 가하지 않음**
- 이더넷의 규격 : 최대 전송속도 + 매체로 나타냄
  - 10BASE5: 최대 10Mbps로 베이스 밴드 방식을 이용해 최대 500m의 동축케이블로 전송
  - 1000BASE-**T**: 최대1000Mbps로 **UTP케이블**을 이용하여 전송
  - 10GBASE-**LX4**: 최대 10Gbps로 광섬유 케이블을 이용하여 전송
  - UTP 케이블: 일반적인 LAN 케이블로 **구리선을 2줄씩 꼬아** 4쌍으로 만들었음
    - 보통 100미터를 넘어가지 않음
    - ISI(Intersymbol Interference)를 줄이기 위해 꼬아 놓았지만 그래도 왜곡은 있음
- 이더넷 프레임 : **이더넷 헤더 + 패킷 + FCS**
  - 헤더 내에는 목적지/출발지 MAC 주소와 **타입 코드**가 포함
    - 타입 코드: 이더넷으로 운반할 대상의 데이터 패킷의 타입을 명시함
    - IPv4패킷은 0x0800, ARP 패킷은 0x0806
  - 데이터는 최대 1500byte (Maximun Transmission Unit)
    - 이를 넘는 데이터는 전송 계층에서 분할해 줌
    - IP헤더, TCP헤더 20바이트 씩을 제외하고 1460바이트가 넘는 메시지
  - FCS는 4byte로 **에러를 체크**함



토폴로지

- 기기들을 어떤 형태로 연결할 것인가? 버스형, 스타형, 링형
- 초기 이더넷은 **버스형**: 전송 매체 공유에 따른 충돌 문제 발생
  - 데이터 전송 타이밍 제어로 **CSMA/CD** 도입
    - Carrier Sense Multiple Access with Collision Detection
    - "선착순": 케이블이 비었으면 전송, 충돌하면 랜덤 시간 대기 후 다시 비었는지 보고 전송
  - 현재 이더넷은 **스타형**이 주류고 **전이중 통신**(Full Duplex) 도입으로 충돌 문제 없음
    - 전이중 통신: 전송매체를 **송신용/수신용으로 나누어** 송수신을 동시에 수행
    - UTP케이블 RJ45 인터페이스의 경우 1,2수신용 3,6송신용: 4개만 사용함



무선 LAN

- L2스위치에 연결된 **무선 LAN 액세스 포인트**가 무선 LAN 클라이언트와 연결
  - 통신 시 액세스 포인트 경유 여부에 따라 인프라스트럭처모드(O), Ad-Hoc모드(X)로 분류
  - 무선 LAN에 연결하는 것을 **어소시에이션**이라고 함
    1. 무선 LAN 클라이언트가 액세스 포인트의 제어신호(비콘) 중 이용 가능한 주파수 탐색
    2. **SSID**를 지정하여 어소시에이션 요청 보냄
    3. 액세스 포인트가 어소시에이션 응답으로 접속 가능 여부 통지
  - SSID
    - **무선 LAN의 논리적 그룹**을 식별하는 정보
    - 액세스 포인트에 32bit의 SSID가 지정되어 있음
    - 보안 설정은 SSID별로 실시
- 충돌 문제
  - 무선 LAN 액세스 포인트는 한번에 한 클라이언트의 전파만을 수신 가능
  - 충돌을 방지하기 위해 **CSMA/CA** 이용: Carrier Sense Multiple Access with Collision Avoidance
    1. 전파가 이용중인지 확인
    2. 이용중이 아니더라도 랜덤 시간 대기 후(동시에 미사용 판단 가능성) 다시 확인하고 송신
  - 대기 시간이 기본적으로 존재하기 때문에 **실효속도(throughput)는 규격상 전송속도의 절반** 정도가 됨
- 보안
  - 도청이 편리한 구조: 보안 대책 필수
  - 일반적으로 WPA2 보안 규격이(IEEE802.11i) 이용됨
    - WPA2는 AES 암호와 IEEE802.1X 인증을 이용함



레이어2 스위치(액세스 스위치, 스위칭 허브)

- 이더넷 헤더의 MAC 주소를 확인하여 동일 네트워크 내에서 데이터를 전송

  - 이더넷 프레임은 **전혀 변경하지 않음**
    1. 출발지 MAC주소를 **MAC주소 테이블**에 등록
    2. MAC주소 테이블에서 목적지 MAC주소를 찾아 프레임 전송
    3. 테이블에 없는 경우, **Flooding**: 수신 포트를 제외한 모든 포트로 전송
  - MAC주소 테이블: 스위치별로 **MAC주소와 포트의 대응 관계**를 기록해둔 표
    - 제한 시간 있음(5분 정도)
    - 하나의 포트에 여러 MAC주소가 기록될 수 있음
    - 포트에 연결된 것이 호스트가 아니라 스위치라고 생각해보자!

- 네트워크 분할: **VLAN**

  - L2스위치를 가상으로 분할, 같은 VLAN에 할당한 포트끼리만 프레임을 전송할 수 있도록 함

  - VLAN은 **보안/관리 측면에서 이점**이 있음

    - 데이터 전송 범위를 제한하여 보안 향상
    - 한 네트워크에 기기가 지나치게 많으면 불필요한 전송이 많아짐

  - 복수의 스위치에 걸쳐서 VLAN을 만드는 것도 가능함

    - 스위치 간 연결 효율화를 위해 **태그 VLAN**(트렁크)를 이용하기도 함

    - 태그 VLAN은 포트를 분할

      ![트렁크](https://blog.kakaocdn.net/dn/7P6UY/btqyAcBzKjt/AMBadrFtJ178vntXj4kam1/img.png)

  - **VLAN 간 통신**을 위해서는 라우터나 L3 스위치에 연결해야 함

    - 먼저 IP주소 설정: L3스위치 내부 VLAN 인터페이스 or 포트 자체에 설정
    - 설정한 IP주소로 네트워크 간 연결과 동일하게 라우팅을 거쳐 연결



## **4. 네트워크 보안**

> 공격으로부터 네트워크를 보호하기 위해 취약한 부분을 



### 4.1. 보안상 위협



### 4.2. 암호화



#### 인증

보안 대책에서 가장 기본적이고 중요한 수단

정식 사용자 외에는 네트워크나 시스템에 접근할 수 없도록 함



인증의 종류

- 사용자가 아는 **정보**를 이용
  - 패스워드
- 사용자가 소유한 **물건**을 이용
  - 사원증
- 사용자의 신체적 **특징**을 이용
  - 바이오메트릭스



#### 암호화

데이터를 도청될 위험으로부터 지키기 위해 데이터를 암호화 함

암호화하기 전의 데이터를 **평문**이라고 하며 **암호키**를 이용하여 암호문을 생성



대칭키 암호 방식

- 암호화와 복호화에 같은 키를 사용함
- 암호화와 복호의 처리 부하 작으나 **키 배송 문제**가 있음
  - 암호키를 어떻게 공유하고 갱신할 것인가?
  - 암호키를 갱신하지 않고 계속 사용하면 규칙성을 읽힐 수 있기 때문
- 주요 알고리즘: 3DES, AES



공개키 암호 방식

- **수학적 연관성을 갖는 공개키와 비밀키**를 이용함
  1. 공개키와 비밀키 쌍을 갖는 수신자가 공개키를 공개함
  2. 송신자는 공개키를 이용하여 암호화하여 전송
  3. 수신자는 비밀키를 이용하여 복호
- **디지털 서명**
  - **비밀키로 암호화하면 공개키로 복호할 수 있다**는 점을 이용해 **데이터 변조 여부 확인**
    1. 송신자는 데이터에서 해시값을 생성
    2. 해시값을 비밀키로 암호화: 서명
    3. 데이터와 서명을 전송
    4. 수신자는 공개키로 서명을 복호하여 해시값을 얻음
    5. 수신한 데이터에서 생성한 해시값과 서명의 해시값을 비교하여 일치 여부 판단
- 공개키는 인증이 필요함
  - 제3자가 송신자에게 의도적으로 잘못된 공개키를 전송한 후 암호문을 가로채 기밀을 얻을 수 있음
  - 디지털 서명을 이용하여 공개키의 진위 여부 판단
    - PKI(Public Key Infrastructure):신뢰할 수 있는 제3자 기관 CA(Certification Authority)에서 **디지털 인증서**를 발행
    - 디지털 인증서: 의뢰사의 공개키 및 디지털 서명(서명은 CA의 비밀키로 작성)
- 주요 알고리즘: RSA, 타원 곡선 암호



SSL(Secure Socket Layer): 하이브리드 암호 

- TCP/IP 암호화 통신에 사용되는 프로토콜로 넷스케이프에서 개발함 
- 암호화 방식
  1. A가 B의 공개키를 이용하여 대칭키를 암호화한 것을 B에게 보냄
  2. B는 자신의 비밀키로 복호화하여 대칭키를 입수
  3. 이후 대칭키를 이용하여 통신
-  HTTPS와 SSL
  - HTTPS: **SSL 인증서**를 이용해 클라이언트와 서버가 암호화된 데이터를 주고받는 것
    - 클라이언트와 서버간의 통신을 공인된 제3자(CA) 업체가 보증해주는 전자화된 문서
    - 통신에 사용할 공개키를 클라이언트에게 제공하고 신뢰할 수 있는 서버인지 확인 가능
  - HTTPS 통신 흐름
    1. 서버 소유 기업이 공개키와 비밀키를 제작
    2. CA가 공개키에 대해 디지털 인증서를 만들고 이를 다시 비밀키로 암호화해 전달
    3. 클라이언트가 서버에 요청을 보내면 **암호화된 인증서를 수신**
    4. 브라우저는 CA의 공개키를 이용해 이를 복호화하여 **서버의 공개키 획득**
    5. 브라우저는 **대칭키를 생성하고 서버의 공개키로 이를 암호화**
    6. 서버는 비밀키를 이용하여 브라우저의 대칭키를 입수
    7. 이후 **대칭키를 이용하여 통신**



VPN(Virtual Private Network)

- 인터넷을 가상으로 **사설네트워크처럼 다루는 기술**
- WAN 구축 비용을 아끼기 위해 인터넷을 사설 네트워크처럼 이용하는 방식
  - 터널링: 거점 LAN 라우터 사이를 가상으로 연결
  - 터널을 경유하는 데이터는 암호화

**내용 조금 보강하자 회사 VPN 이용 사례랑 엮어서**



Proxy

- 클라이언트와 서버 간의 **중계 서버**로 통신을 대리 수행함
  - 클라이언트 측의 프록시를 forward proxy, 서버 측의 프록시를 reverse proxy라 함
- Forward Proxy
  - 일반적으로 프록시라 하면 포워드 프록시를 지칭함
  - 캐싱을 통해 불필요한 외부 전송을 줄이고 네트워크 병목 현상을 감소시킬 수 있음
  - 익명성 확보 : 클라이언트의 IP를 감추고 프록시의 IP로 서버에 요청을 보냄
- Reverse Proxy
  - 캐싱 가능
  - 서버 보안 : 서버의 IP를 감추고 프록시의 IP로 클라이언트의 요청을 받음
  - **로드 밸런싱** 가능



로드 밸런싱

- 해야 할 작업을 나눠서 서버의 부하를 분산시키는 것
- 서비스가 대규모화되어 **Scale Out**이 이루어졌을 때 각 서버에 부하를 균등하게 주기 위해 고안됨
  - Scale Out : 서버의 갯수를 늘려서 처리 용량을 늘리는 것
  - Scale Up : 단일 서버의 성능을 높여서 처리 용량을 늘리는 것
- 로드 밸런싱은 load balancer가 담당하며 OSI level에 따라 다음과 같이 분류 가능
  - L2 : Mac 주소를 바탕으로 로드 밸런싱
  - L3 : IP 주소를 바탕으로 로드 밸런싱
  - L4 : IP & Port number를 바탕으로 정해진 정책에 따라 로드 밸런싱
    - 예) 80번 포트로 들어오는 요청은 백엔드 서비스 1,2,3,4에 라운드 로빈을 이용해 라우팅
    - 데이터 내용을 들여다보지 않기 때문에 빠름
  - L7 : 어플리케이션 레벨에서 로드 밸런싱
    - 예) 어떤 사이트를 기능별로(/category, /search) 나눠서 로드 밸런싱
    - 내용을 들여다보기 때문에 느리지만 더 **세밀하게 분산시킬 수 있다**는 장점이 있음
- 로드 밸런싱 알고리즘
  - Round Robin
    - 요청이 들어올 때 마다 일정한 순서대로 요청을 넘김
    - 서버가 5대라 가정하면 1번 요청은 A서버, 2번 요청은 B서버 ~ 6번 요청은 A서버에게 주는 식
    - 서버의 사양이 모두 동일하며 persistent connection이 별로 없을 때 적합
    - **비효율적인 부하 분산이 발생할 수도** 있음 : 서버 부하에 대한 고려는 없기 때문
  - Weighed Round Robin
    - 가중치를 매겨서 가중치가 높은 서버에 요청을 우선적으로 배분
    - A가 가중치 100, B가 가중치 400이라면 100개의 요청 중 20개는 A서버로, 80개는 B서버로 보냄
  - Least Connection Method
    - 가장 적은 active connection이 있는 서버로 요청을 보냄
    - 서버들이 persistent connection을 불균등하게 갖고 있을 때 유용함
    - **서버의 부하 상태가 고려**되는 장점이 있음
    - 서버를 새로 투입할 경우 해당 서버는 persistent connection이 0이기 때문에 요청이 몰릴 수 있음
  - Least Response Time Method
    - active connection이 가장 적고, 가장 낮은 평균 응답 시간을 보이는 서버에 요청을 전달
  - IP Hash
    - 해시 함수와 IP 주소를 이용하여 서버를 결정 : 동일한 IP는 동일한 서버로





## **5. 클라우드**

클라우드란?

일반 사용자가 복잡한 컴퓨터 통신망의 네트워크 및 서버 구성 등을 알 필요 없이 어디에서나 구름 속(에 있다고 생각하는) 컴퓨터 자원으로 자기가 원하는 작업을 할 수 있다는 것



여기서는 **클라우드 서비스**에 대해 다룸

- 서버를 직접 관리/운용하지 않고 인터넷을 통해 서버의 기능만 이용하는 것
- 서버의 어느 부분을 사용자가 이용하는지에 따라 IaaS, PaaS, SaaS로 분류함



### 5.1. IaaS, PaaS, SaaS



회사 이용 사례와 함께 보강할 것