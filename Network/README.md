# Network

네트워크이론 기초부터 심화까지



참고서적

- 그림으로 배우는 네트워크 원리
- Computer networking - Top down approach 
  - [이화여대 강의자료](http://www.kocw.net/home/cview.do?mty=p&kemId=1046412)
  - 



[TOC]

## 1. 네트워크 개요



### 1.1. 네트워크 기초 지식

네트워크란?

- 컴퓨터끼리 **데이터를 주고 받는** 시스템(computer network)
- 인터넷은 **사용자 제한 없이** 전 세계의 컴퓨터를 연결한 네트워크
  - **사설 네트워크**의 경우 사용자가 제한됨



LAN과 WAN

|           |         LAN         |    WAN     |
| --------- | :-----------------: | :--------: |
| 역할      | 거점 내 기기간 연결 | LAN간 연결 |
| 구축/관리 |        직접         | 통신사업자 |



데이터 통신 개요

- 통신의 주체는 **어플리케이션**
- 통신은 **양방향**
  - 서버를 거치는 통신
    - 클라이언트 애플리케이션이 서버 애플리케이션에 request
    - 서버 애플리케이션이 reply
  - 서버를 거치지 않는 통신(Peer to Peer)
    - 클라이언트 애플리케이션끼리 직접 데이터 통신
- 데이터 교환을 원활히 하기 위한 통신 규칙: **프로토콜**
  - 통신 상대(주소) 설정, 순서 제어, 데이터 형식 등의 통신의 다양한 분야에 대한 규칙
    - **구문/의미/타이밍**의 3가지 요소로 구성됨
    - 구문: 데이터 형식, 코딩 방식, 신호 레벨
    - 의미: 데이터 제어 및 처리 방법과 에러 처리를 위한 정보
    - 타이밍: 통신 속도 조절과 순서 관리를 위한 기법을 포함
  - HTTP(웹상에서 뭘 주고받는가?), TCP(어떻게 전송하는가?), IP(어디로 전송하는가?), 이더넷 등이 있음
  - 프로토콜의 집합이 **네트워크 아키텍처**
    - 프로토콜 스택이라고도 함
    - TCP/IP, OSI 7계층 등이 있음



네트워크 기기

- 데이터를 전송하는 기기
  1. 데이터 **수신**: 물리 신호를 디지털 신호로 변환
  2. 데이터 **수신처 결정**
     - 데이터의 **제어 정보**를 참조하여 전송할 곳을 결정: 제어정보는 각 계층의 헤더에 존재
     - 네트워크 기기의 차이는 여기에 있음: 어느 제어 정보를 참조하느냐에 따라 달라짐
  3. 데이터 **송신**: 디지털 신호를 물리신호로 변환하여 발신
- 기기의 종류
  - 라우터
  - 레이어2 스위치
  - 레이어3 스위치(내부 라우터 + 레이어2 스위치)



네트워크의 구성

- 구성 요소
  - 네트워크 기기
  - 인터페이스(포트)
    - 전기신호와 물리 신호의 경계(인터페이스): **네트워크 기기와 전송 매체의 접점**
    - 이더넷 인터페이스가 가장 일반적(컴퓨터 뒤의 LAN 포트)
  - 전송 매체
    - 인터페이스를 서로 연결하는 것
    - 유선 케이블 or 무선 전파
- 네트워크 구성도
  - 물리구성도: 각 기기의 물리적 배치와 인터페이스의 연결을 나타냄
  - 논리구성도: 네트워크간 연결을 표현 
    - 몇 개의 네트워크가 어느 라우터/레이어3 스위치로 연결되는지 정리
    - **하나의 네트워크는 라우터(레이어3 스위치)로 구분**되기 때문



### 1.2. 인터넷 기초 지식

인터넷은 어떻게 구성되는가?

- 전 세계의 다양한 네트워크가 연결된 것: Autonomous System

  - ISP(Internet Service Provider)는 AS의 한 예

  - 인터넷 상의 모든 ISP는 **Tier1**를 경유하여 연결됨

    - Tier 1: a network that **can reach every other network** on the Internet **without purchasing** [IP transit](https://en.wikipedia.org/wiki/Internet_transit) or **paying** for peering.

      ![tier1](https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/Internet_Connectivity_Distribution_%26_Core.svg/825px-Internet_Connectivity_Distribution_%26_Core.svg.png)



인터넷은 어떻게 동작하는가? [MDN](https://developer.mozilla.org/ko/docs/Learn/Common_questions/How_does_the_Internet_work)

1. 서버 쪽 호스트가 DNS 서버에게 IP를 이름으로 바꿔달라는 요청을 보냄
   - **호스트**란 네트워크에 연결된 "컴퓨터"를 말함
     - 네트워크에 연결된 장치를 **노드**라 하고 IP주소가 할당된 노드를 호스트라 함
   - **DNS**(Domain Name System)란?
     - IP가 아니라 이름으로 연결하기 위한 서버
     - DNS서버에 질의하는 기능은 "DNS 리졸버"라고 하며 OS에 내장되어 있음
       - 질의한 서버에 호스트명이 없으면 루트에서부터 **재귀질의**함
       - 질의한 정보는 한동안 서버와 리졸버의 캐시에 저장
2. 사용자는 먼저 ISP와 계약하고 로컬 네트워크의 라우터를 ISP의 라우터와 연결함
3. **웹 브라우저** 작동
4. 클라이언트 로컬에서(호스트 파일) 접속할 도메인 이름을 찾음
5. 없으면 DNS에 해당 이름의 IP 주소를 요청, 응답을 받음
6. DNS서버의 주소는 인터넷에 연결하는 순간 **DHCP**가 세팅해줌
   - **DHCP**(Dynamic Host Configuration Protocol)란?
     - 호스트의 IP주소와 각종 TCP/IP 프로토콜의 기본 설정을 자동 제공
     - 자동이므로 편리하나 DHCP 서버가 다운되면 IP 할당이 안됨
     - 할당된 IP주소는 임시적임
7. DNS가 제공한 IP주소를 이용해서 접속하여 통신



#### 1.2.1. Web

웹이란?

- 인터넷상에서 **문서들**을 **연결**하여(HyperText) 정보 검색을 빠르게 할 수 있게 한 것
  - 웹사이트는 복수의 웹페이지(HTML 파일)로 구성됨
  - 문서의 레이아웃 및 디자인은 스타일 시트로 정의되며 **CSS**언어로 기술됨
- 구체적으로는 클라이언트-서버 간 **HTTP 프로토콜**을 사용하여 HTML을 주고받는 시스템
  - HTTP 프로토콜: 하이퍼텍스트를 빠르게 교환하기 위한 프로토콜
    - HTTP 파일전송은 **Request**와 **Response**를 주고받으며 이루어짐
    - Request
      - 요청라인 + 메시지 헤더 + (공백) + entity 바디
      - 리퀘스트 라인: **HTTP method** + URL + version
        - HTTP method: GET, POST, PUT, PATCH, DELETE 등
        - version은 그냥 HTTP의 버전을 나타냄
      - 메시지 헤더는 웹브라우저 종류/버전, 대응하는 데이터 타입 등을 기술
      - entity 바디는 **POST에서 데이터를 담아 보낼 때** 사용
    - Response
      - 상태라인(status) + 메시지 헤더 + (공백) + entity 바디
      - 리스폰스 라인: 버전 + 상태 코드 + 설명문
        - [Response Code](https://developer.mozilla.org/ko/docs/Web/HTTP/Status)
        - 설명문은 상태 코드의 의미를 간단히 보여줌
      - entity 바디에는 브라우저에 돌려보낼 데이터 포함: 주로 HTML
  - 특징: **비연결성, 무상태**
    - 비연결성: 리소스를 아끼기 위해 비연결성을 띔
      - 잦은 연결/해제는 오버헤드를 초래함
    - 무상태: 비연결성으로 인해 클라이언트를 식별할 수 없는 것
      - **쿠키/세션/토큰**을 이용하여 기억함



쿠키, 캐시, 세션, 토큰

- 쿠키와 캐시의 [차이](https://zorba91.tistory.com/163)
  - 쿠키는 **사용자 인증**을 위해 사용됨
    - 키-값의 데이터 파일, **웹서버에서 PC로 **보내주는 파일 저장
    - 웹사이트 접속시 발생, 유출돼도 큰 일 없을 정보들(로그인 정보, 열람 이력)
    - 만료기간이 있어 자동 삭제됨
  - 캐시는 **웹페이지를 빠르게 렌더링**하기 위해 사용됨
    - 웹페이지요소(Response), 그림파일 등
    - 수동 삭제 필요, 캐시가 너무 많이 쌓이면 브라우저 속도 저하됨
- 세션
  - 사이트와 브라우저 사이의 상태를 유지시킴. 
    - 연결 그 자체를 세션이라 하기도 하고 통신을 마칠 때까지의 기간을 뜻하기도 함
  - 클라이언트는 세션 아이디(클라이언트 식별자)를 **쿠키**를 이용해 저장
  - **세션 자체는 서버에 저장**
    - 서버의 메모리를 차지하고 과부하의 원인이 됨
- 토큰
  - 쿠키와 세션의 문제점을 보완한 **본인 확인 수단**
  - 보호할 데이터를 토큰으로 치환하여 원본 대신 토큰을 이용함
  - **추후 보강**



웹 브라우저란?

- **웹 기반 컨텐츠**(웹페이지)를 검색 및 열람하기 위한 어플리케이션
  - 서버에서 **컴포넌트 파일**(코드 파일 + 자원)을 가져옴
  - 코드 파일: HTML, CSS, JS
  - 자원: 웹사이트를 만드는 모든 다른 것들 - 이미지, 음악, PDF 등
- 구성: UI - 브라우저 엔진 - 렌더링 엔진, 통신, JS해석기, 임시파일저장소
  - ![ㅇ](https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png)
- 렌더링 동작 과정
  - html가져옴 - **DOM트리 작성** - CSSOM트리 작성 - 2개 결합해 렌더트리 생성
    - DOM트리는 HTML태그들의 계층관계를 나타낸 것
    - 문서객체모델(DOM)에 따르면 모든 HTML 태그는 객체로, JS를 통해 접근하여 페이지를 조작할 때 객체를 사용함
  - 객체들에게 위치,크기 지정(레이아웃) - CSS속성 적용 - 화면 업데이트
  - 도중에 JS를 발견하면 JS엔진 실행했다가 다시 DOM 생성함



SSR, CSR, SPA, MPA

- 웹 브라우저가 문서를 어떻게 가져올 것인가? [그림 설명](https://medium.com/%EC%95%84%EB%AA%BD%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4/csr-ssr-spa-mpa-ede7b55c5f6f)
- SSR(Server Side Rendering)
  - 서버에서 view페이지를 렌더링해서 가져오고 브라우저는 이를 보여주기만 함
  - 매번 새로 렌더링하니 **느리고 서버에 부담**
  - CSR보다 **SEO가 뛰어나다**는 장점이 있음
- CSR(Client Side Rendering)
  - 서버에서 html, js등을 다운받은 후 클라이언트가(브라우저에서) 렌더링
- SPA(Single Page Application)
  - 서버에서 **처음 1회만 페이지를 받아오고** 이후에는 **동적으로 DOM을 구성하여** 렌더링 되는 화면이 바뀌게 함
    - SPA는 어플리케이션이고 CSR은 렌더링 방식으로 SPA구현을 위해 CSR이 사용됨
  - 사용자 경험(UX) 향상을 위해 도입
    - 좋아요 버튼을 누를 때마다 페이지 새로고침이 되지 않도록
  - SPA를 만드는 데 최적화된 라이브러리로 React.js, Next.js 등이 있음
- MPA(Multi Page Application)
  - 서버로부터 완전한 페이지를 받아오고 수정/조회시 다른 완전한 페이지로 이동
  - 동적이지 않은 페이지를 상황에 맞게 클라이언트에 뿌려줌
- SEO(Search Engine Optimization)
  - 검색엔진에 잘 노출될 수 있도록 **웹사이트를 각 엔진이 잘 읽을 수 있게끔** 최적화
  - 첫번째 페이지는 SSR로, 이후에는 CSR을 이용하면 속도와 SEO를 다 잡을 수 있음



REST API란?

- REST란?
  - REpresentational State Transfer: 웹의 장점을 활용하며 범용성을 보장한 아키텍처
  - 구성
    - 자원(URI), 행위(HTTP method), 표현(JSON, XML, txt)
    - 웹에 존재하는 모든 자원에 **URI**를 부여하고, **HTTP method**를 통해 해당 자원에 대한 CRUD operation을 적용한 결과를 JSON으로 표현
      - URI(Uniform Resource Identifier): 하나의 자원을 가리키는 문자열
      - URL이라고도 하는데 URI가 정식 표현이다
  - 특징
    - uniform: URI에 대한 조작은 HTTP method로 통일
    - statelss: 클라이언트의 context를 서버에 유지하지 않고 메시지로만 요청 처리
    - cacheable: HTTP가 가진 캐싱 기능을 적용
    - self-descriptiveness: REST API메시지만 보고도 이해 가능
    - client-server architecture
    - 계층형 구조: 클라이언트는 REST API만 호출하며 REST서버는 다중 계층으로 구성
- API란?
  - Application Programming Interface
  - 응용프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스
- 이해하기 쉽고, 모든 플랫폼 사용 가능하며(서버와 클라이언트가 같은 방식을 사용해서 요청해야) 별도의 인프라 구축 필요 없으나 메서드가 제한적이라는 단점 있음



웹 서버 vs WAS(Web Application Server)

- [추후 보강](https://gyoogle.dev/blog/web-knowledge/Web%20Server%EC%99%80%20WAS%EC%9D%98%20%EC%B0%A8%EC%9D%B4.html)
- 웹 서버
  - 기능: HTTP 기반으로 클라이언트의 요청을 서비스
    - **정적 컨텐츠 제공**: WAS를 거치지 않고 제공
    - 동적 컨텐츠 제공을 위한 요청 전달: WAS에 요청하여 응답을 클라이언트에 전송
  - 어플리케이션 종류: **Apache**, Nginx, IIS 등
- WAS
  - 기능: 서버단에서 필요한 기능(DB 조회 및 다양한 로직 처리)을 수행하고 **동적인 컨텐츠를 제공**
    - 웹 서버에 지나치게 부하가 가해지는 것을 막기 위해 도입
    - 웹 서버를 앞단에 두고(클라이언트 쪽) WAS들을 웹 서버에 플러그인 형태로 설정하는 것이 가능
  - 종류: Tomcat, JBoss 등



호스팅

- 대형 **서버의 기능을 빌려쓰는** 것
- 종류: 웹 호스팅, 서버 호스팅, 클라우드 호스팅
  - 웹호스팅: 하나의 서버 장비를 여러 명이 공유하여 사용
  - 서버호스팅: 한명의 고객이 하나의 서버장비를 임대
    - 고정적으로 트래픽 양이 많은 사이트에 적합
  - 클라우드호스팅: **가상서버를 임대**하고 **이용한만큼 지불**



## 2. OSI 7계층

> Open Systems Interconnection Reference Model
>
> 최근에는 사용되지 않으며 실무에선 대부분 TCP/IP 아키텍쳐가 이용되므로 대충 읽자



Application Presentation Session Transport Network Datalink Physical

각 계층은 하위 계층의 기능을 이용하여 상위 계층에 기능을 제공

계층을 지날 때마다 헤더가 붙음



물리 계층

- 단위: bit
- 장치: 허브(리피터)
- 물리적 연결의 성립 및 종료, 전기 신호 변조/복조



데이터 링크 계층

- 단위: 프레임(데이터+헤더+트레일러)
- 장치: 스위치/브리지
- 프레이에 MAC주소를 부여하고 이를 통해 통신함
- 포인트 투 포인트 간 신뢰성 있는 전송 보장: 오류 제어/흐름 제어/ 회선 제어
  - 오류제어: 검출은 여기서 하고 수정은 전송 계층에서
  - 흐름제어: 전송 데이터의 양을 제한하는 기술
  - 회선제어: 신호 간 충돌이 발생하지 않도록 제어하는 기술



네트워크 계층

- 단위: 패킷
- 장치: **라우터**
  - 라우터는 컴퓨터간 연결 수를 줄이기 위한 근거리 허브
  - ISP: 원거리의 라우터를 연결함
- 라우팅 프로토콜을 사용하여 최적의 경로 선택, IP주소를 지정



전송 계층

- 단위: 세그먼트
- 프로토콜: TCP, UDP
- 신뢰성 있는 데이터를 주고 받을 수 있게 함
- 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 함: **어떻게?**



세션 계층

- 단위: 데이터
- 장치: L5 스위치
- 양측 응용 프로세스가 통신을 관리하기 위한 방법을 제공
- TCP/IP 세션을 만들고 없앰



표현 계층

- 단위: 데이터
- 데이터 부호화, 변환: 파일 인코딩이나 명령어 포장/압축/암호화 등을 진행
- 암호화 등을 통해 코드 간의 번역을 함



어플리케이션

- 단위: 메세지, 데이터
  - **소켓**에 데이터를 담아서 전달함
  - 소켓은 프로세스가 데이터를 내보내고 받는 창구
    - 한 프로세스가 여러 소켓을 가질 수 있음
    - 소켓은 전송 프로토콜(TCP/UDP), IP주소, **포트 넘버**로 정의됨
- 프로토콜: HTTP, FTP, POP3 등
- 직접적으로 응용 프로세스와 관계하여 여러 가지 프로토콜 개체에 대해 UI 제공





## 3. TCP/IP

> TCP와 IP를 중심으로 하는 프로토콜의 집합으로 가장 많이 이용되는 네트워크 아키텍처



### 3.1. TCP/IP 계층구조

TCP/IP 아키텍처는 4계층으로 구성되고, 상위 3계층은 통신 상대와 같은 프로토콜을 사용함

![model](https://www.guru99.com/images/1/093019_0615_TCPIPModelW3.png)

- 애플리케이션층
  - 애플리케이션에서 다룰 **데이터 형식과 절차를 결정**함
    - 인간이 인식할 수 있는 형태(문자, 이미지 등)로 데이터를 표현
  - 프로토콜: HTTP, SMTP, DHCP, DNS 등
  - 데이터 명: 메시지
- 트랜스포트층
  - 애플리케이션에 **데이터를 분배**하거나 분할/조립을 수행함
    - 여러 애플리케이션의 데이터를 수신하여 각 애플리케이션으로 할당함
  - 프로토콜: TCP/UDP (두 개밖에 없음)
  - 데이터 명: 세그먼트(TCP), 데이터그램(UDP)
- 인터넷층
  - 엔드투엔드 통신: **네트워크 간**의 데이터 전송
    - 네트워크끼리 연결하고 데이터를 전송하는 기기가 **라우터**
  - 프로토콜: IP, ICMP, ARP 등
  - 데이터 명: **패킷** 또는 데이터그램
    - 패킷: 정보를 **일정한 크기**로 분할한 뒤 각 데이터에 송수신 주소 및 부가 정보 입력
    - 패킷 교환: 원거리 통신망의 연결 기술로 전체 메시지를 **각 노드가 수용 가능한 크기(패킷)으로 잘라서** 송수신
- 네트워크 인터페이스층
  - **같은 네트워크** 내 **인터페이스 간**에 데이터를 전송함
    - 한 네트워크는 **레이어2 스위치**에 의해 구성됨: 스위치에 의해 **이더넷 프레임**이 교환됨
  - 프로토콜: **이더넷**, 무선LAN, PPP 등
  - 데이터 명: 프레임



TCP/IP에서 송수신의 흐름

- 캡슐화
  - 송신시 각 **계층별로 헤더를 추가**하는 것
  - 수신시 각 계층별로 헤더를 참조하여 처리하고 벗기는 것은 역캡슐화
- FCS(Frame Check Sequence)
  - 네트워크 인터페이스층에서는 이더넷 헤더 및 에러체크정보 FCS를 추가함
  - FCS가 추가되면 캡슐화 완료: 송신 준비 끝
- 목적지로 송신
  - **IP 주소**를 지정하여 목적지의 인터페이스까지 IP 패킷을 송신
  - 인터페이스는 **MAC주소**로 구분됨
    - IP주소에 대응하는 MAC주소를 대응시키는 **주소 해석** 필요
    - **Address Resolution Protocol**: 목적지 IP 주소 설정시 자동으로 실행되어 **같은 네트워크 내**에서 목적지의 MAC주소를 반환
    - 자세한 사항은 인터넷 계층 참고



IP 주소

- IP란?
  - 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 **정보 위주**의 규약
  - 엔드 투 엔드: 즉 **호스트 간** 통신을 하는 것
- IP주소란?
  - 호스트의(인터페이스) 식별 정보
    - 각 인터페이스별로 IP주소 지정 가능(안할수도 있음)
  - IPv4의 경우 32비트로 **도트형 10진표기**로 나타냄
- IP주소의 구성
  - **유니캐스트**의 경우 네트워크부와 호스트부 2가지로 구성됨
    - 유니캐스트: 단 한 곳으로 데이터를 전송
    - 어디까지가 네트워크부인지 명시한 것이 **서브넷 마스크**
      - 보통 prefix표기를 이용: 192.168.1.1/24 (앞의 24비트가  네트워크부)
    - 호스트부를 모두 0으로 채우면 **네트워크 주소**, 1로 채우면 **브로드캐스트 주소**
  - **브로드캐스트**는 255.255.255.255를 사용하거나 호스트부의 비트를 모두 1로 한 주소를 가짐
    - 브로드캐스트: 같은 내트워크 내 모든 호스트에게 똑같은 데이터를 전송
  - **멀티캐스트**는 224.0.0.0 ~ 239.255.255.255로 범위가 정해져 있음
    - 멀티캐스트: 특정 그룹에 포함되는 호스트들에 똑같은 데이터를 전송
- 이용범위에 따른 구분
  - 퍼블릭 IP 주소: 인터넷에서 사용하는 주소
    - 인터넷 통신을 위해서는 반드시 퍼블릭 IP주소가 필요
  - 사설 IP 주소: 사설 네트워크에서 이용하는 IP주소
    - 지정된 범위가 있으며 다른 네트워크와 겹치더라도 네트워크 내에서의 통신에는 문제 없음
  - **NAT**(Network Address Translation)
    - 사설네트워크 - 인터넷 통신에 필요: 목적지가 사설 주소로 된 IP패킷은 폐기됨
    - **라우터가** 출발지 IP주소를 퍼블릭 IP주소로 변환하여 요청하고 응답을 받으면 해당 사설 IP 주소로 데이터를 보냄



MAC 주소

- **하드웨어의 고유한 식별번호**: OS에 "할당"되는 IP주소와 달리 불변하는 물리 주소임
  - 기기 자체를 식별함
    - IP주소는 "호스트가 네트워크 상에서 **어디 있는가**"를 나타냄
    - MAC주소는 **누구인가**를 나타냄: MAC주소만 있으면 통신이 매우 어려움
      - 통신을 위해 전화번호부를 계속 뒤지는 것과 같기 때문
  - 네트워크 인터페이스에 할당됨
    - Network Interface Controller 제작사에서 할당하며 48bit로 구성됨
  - 외부에서 내부의 사설 네트워크로 통신할 때 중요
    - 사설 IP를 외부에서 볼 수 없으나 MAC주소를 알고 있으면 도달가능하기 때문
- MAC주소의 구성
  - 24bit OUI + 24bit Serial Number
    - OUI: 이더넷 인터페이스 제조 벤더 식별 코드
    - 시리얼 넘버: 각 벤더가 하드웨어에 할당
  - 4bit씩 끊어서 16진수로 표기하여 '-'로 구분하는게 일반적
    - 내 노트북 bluethooth 이더넷 어댑터는 `3C-A0-67-A5-40-EA` 임



### 3.2. Transport Layer

> 데이터를 (분할하여) 송신하고, 수신한 후 어플리케이션이 사용할 수 있도록 조립 및 분배



등장 배경

1. 호스트 간 이동은 인터넷층(IP)에서 다 해결이 되나 **한 장치 내 여러 프로그램이 통신**할 경우 IP로는 한계가 있었음
2. IP는 **best effort**: 데이터 보내는 데에는 최선을 다하나 안 되면 말고ㅎ
3. 이를 보완하기 위해 **ICMP**가 나왔지만 오류 보고만 하지 대응은 못함
4. 1을 해결하기 위해 **포트 번호**가 등장했고 2/3을 해결하기 위해 **전송 계층** 도입



포트 번호

- 어플리케이션에 데이터를 할당하기 위해서 **어플리케이션 식별**이 필요
  - TCP/UDP 헤더에 어플리케이션을 식별하는 포트번호를 지정
  - 포트번호는 16bit로 0~65535
- **well-known port number**
  - 주요 어플리케이션 프로토콜의 포트 번호로 미리 지정되어 있음(0~1023)
  - HTTP: 80, HTTPS: 443, SMTP: 25 등
- registered port number
  - well-known 이외에 자주 이용되는 서버 어플리케이션 식별용 포트번호
  - 나머지는 동적/사설 포트번호로 통신 시 동적으로 할당됨



Transmission Control Protocol

- 애플리케이션 간의 통신에서 **신뢰성 확보**가 필요할 때 사용됨

  - 전화를 거는 것처럼 연결, 안정적으로, 순서대로, 에러 없이

- 데이터 전송 절차는 커넥션 수립 - 송수신 - 커넥션 끊기

  - 커넥션 수립 단계에서 통신이 가능한지 **3-way handshake**로 확인

    ![3way](https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png)

    1. 통신하고 싶다는 메시지 보내기(SYN)
    2. 상대가 준비됐다고 보냄(SYN+ACK)
       1. 연결 종료 시엔 여기에 FIN를 상대로부터 추가로 받음(4-way handshake)
    3. ACK로 응답

  - 송신 시 **데이터 크기가 크면 분할**, 분할 방식을 TCP헤더에 기술(고유번호) 

    - 수신 시 이를 참조해 데이터를 조립하고, 확인응답(ACK) 회신
    - 일부 데이터가 제대로 도착하지 않으면 **재송신**
    - 네트워크 혼잡 시 속도 제한: **플로우 제어**



User Datagram Protocol

- TCP에서 신뢰성 기능을 뺀 것
  - **스트리밍** 하려고 만든 것임: 데이터가 다소 유실되는 것보다 속도가 중요
  - **실시간성**을 보장해 주는 **비연결형**임
  - 헤더가 아주 간단하기 때문에 TCP보다 용량이 적고 속도가 빠름
- DNS 는 request의 양이 적고 연결을 유지할 필요가 없기 때문에 UDP를 사용함
  - 신뢰성 문제는 어플리케이션층에서 해결가능(Timeout추가, resend 등)
  - 데이터가 512바이트를 넘거나(UDP segment) 연결을 못 받은 경우엔 TCP 사용



흐름제어/혼잡제어

- Flow Control: **송신측과 수신측**의 데이터 처리속도 차이 해결
  - sender에게 **receiver가 자신의 상태를 feedback**하여 패킷을 지나치게 많이 받지 않도록 함
  - 해결 방법
    - Stop & Wait: 매 패킷마다 확인 응답을 받아야 그 다음 패킷을 전송
    - Sliding Window: **수신측에서 설정한 윈도우 크기**만큼 송신측에서 확인응답 없이 세그먼트 전송, ACK를 받으면 버퍼의 범위가 한꺼번에 이동
- Congestion Control: **송신측의 데이터 전달과 네트워크**의 데이터 처리 속도 차이를 해결
  - 한마디로 많이보내면 혼잡해지니까 속도를 조절하는 것
  - 해결방법
    - AIMD: 윈도우 크기를 선형적으로 증가시키고 혼잡을 감지하면 절반으로 줄임
      - 공평함: 여러 호스트가 한 네트워크 공유시 평형상태로 수렴하게 됨
    - Slow Start: 패킷을 하나씩 보내고 **임계치에 도달할 때까지 윈도우 사이즈 2배씩 증가**시키나 혼잡 감지시 사이즈를 1로 하고 지수적으로 증가시킨 후 혼잡이 발생했던 window size의 절반에 ㅇ 선형증가
      - Congestion Avoidance: 임계치를 넘으면 선형적으로 증가
      - Fast Retransmit: 중복된 패킷을 3개 받으면(Triple duplicated ACK) 혼잡이 일어나 손실됐다고 간주, **즉시 재전송**
      - Fast Recovery: 혼잡 이후 윈도우 사이즈를 1이 아닌 절반으로 내리고 선형증가시킴



### 3.3. Internet Layer

> 네트워크 간의 엔드 투 엔드 전송



IP: 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 **정보 위주**의 규약

- 호스트의 주소 지정, 패킷 분할 및 조립 기능 담당
  - 호스트란 네트워크에 연결된 "컴퓨터"를 말함
  - 네트워크에 연결된 장치를 노드라 하고 IP주소가 할당된 노드를 호스트라 함
- 특징
  - 비신뢰성/비연결형
  - 에러제어, 흐름제어 없음: 에러 검출은 하지만 보낸 내용을 보장하지 않음
- MTU(Maximun Transfer Unit)때문에 IP패킷을 잘라서(단편화) 보냄
- IPv6
  - IPv4가 가진 주소 고갈, 보안성, 이동성 지원 등을 해결하기 위해 등장
  - 보안성: 패킷 출처 인증, 데이터 무결서 및 비밀 보장 기능
  - 이동성: 네트워크의 물리적 위치에 제한받지 않음



ICMP: Internet Control Message Protocol

- 통신이 정상적으로 이루어졌는지 확인하기 위해 등장한 프로토콜
- 주요 기능: 에러 리포트, 진단
  - 에러리포트: 어떤 이유로 IP패킷이 폐기되면 폐기한 기기가 ICMP를 이용해 패킷의 출발지로 **도달불능 메시지**를 보냄
  - 진단: **ping command** 등으로 IP의 엔드투엔드 통신이 가능한지 체크
    - ICMP 헤더에 "에코 요청 메시지"를 기술하여 보낸 데이터를 그대로 돌려받음
    - 데이터를 수신하면 통신 가능함을 확인



ARP: Address Resolution Protocol

- ARP의 원리
  - **브로드캐스트**를 통해 목적지 물리주소를 요청
  - 수신자 중 해당되는 수신자만 **유니캐스트**를 통해 논리주소와 물리주소를 응답
- ARP의 동작 순서
  1. 송신자는 목적지 IP 주소를 담아 패킷 제작
  2. IP프로토콜이 ARP 프로토콜에게 **ARP 요청 메시지**를 생성하도록 요청
  3. 메시지는 이더넷 프레임으로 캡슐화: 브로드캐스트
  4. 모든 호스트 및 라우터는 수신한 프레임을 자신의 ARP 프로토콜로 전달
  5. 목적지 IP 주소가 일치하는 수신자는 자신의 물리주소를 담아 ARP 응답 메시지를 송신
  6. 송신자, IP 주소에 대응하는 물리주소 획득





#### 3.3.1. 라우팅

> 라우터가 IP패킷을 전송하는 것
>
> 어떤 경로로 보낼 것인가? 다음 라우터는 어떻게 찾는가?



라우팅이란?

- **다른 네트워크**에 데이터를 보내기 위해 **IP주소**를 기반으로 데이터의 목적지를 찾는 것
  - 라우팅의 반복을 통해 데이터를 목적지까지 송신하는 것이 가능
  - 라우터에서는 연결 대상인 네트워크의 IP주소를 이용해 인터페이스 IP주소를 설정
    - 예) 네트워크1(192.168.1.0/24) - 인터페이스1(192.168.1.254/24)
- 라우터는 **라우팅 테이블**을 이용하여 IP패킷을 전달
  - 라우팅 테이블에는 **Next Hop**(다음 라우터)와 그에 대응되는 IP 주소가 기록되어 있음
  - 테이블에 경로 등록하는 방법은 3가지 존재
    - 직접 접속: **라우터가 직접 연결된** 네트워크의 경로정보
    - 스태틱 라우팅(간접, 수동): 라우터에 직접 연결되지 않은 네트워크 주소를 수동으로 등록
    - 라우팅 프로토콜(간접, 자동): **라우터끼리 정보를 교환**해 테이블에 필요한 경로를 등록
      - *하나의 라우터가 새로 들어오면 어떻게 되는가?*
  - 목적지 IP주소가 라우팅 테이블에 상에서 인식할 수 없으면 IP패킷은 **폐기**
    - 그럼 테이블에 수많은 IP 주소를 다 등록해야 하는가?
    - **경로요약**: Next Hop이 동일한 네트워크들의 경로 정보를 하나로 모아 등록
      - IP주소에서 겹치는 부분을 네트워크부로 처리하고 Next Hop을 등록
      - 예를 들어 10.2.0.0/24, 10.2.1.0/24의 Next Hop이 동일하다면 10.2.0.0/16으로 등록
      - 모든 네트워크를 집약하면 0.0.0.0/0 인 **디폴트 경로**가 됨
      - PC의 라우팅 테이블에는 직접 접속 경로 정보와 디폴트경로만(**기본 게이트웨이**) 등록
- 라우팅 순서
  1. 라우터가 호스트로부터 IP 패킷을 수신
  2. 테이블에서 Next Hop을 탐색
  3. 수신한 IP패킷의 이더넷 헤더에는 현재 라우터의 MAC주소가 목적지로 되어 있음
  4. ARP를 실행하여 **Next Hop의 MAC주소**를 얻고 이더넷 헤더 + FCS 교체
  5. IP헤더의 TTL(Time To Live, 패킷의 수명)에서 1을 빼준 후 송신
     - 라우팅 시에 IP주소는 변하지 않음: NAT로 변환하면 달라짐
  6. 수신한 라우터는 다시 라우팅 테이블을 통해 라우팅 실시
     - Next Hop이 작접 접속되어 있다면 위와 같이 ARP를 거쳐 송신하고 종료



게이트웨이란?

- **다른 네트워크**로 가기 위한 관문
- 라우터의 상위 개념: 경로 탐색, 네트워크 간 연결 수행 가능
  - 최근에는 한 장비 안에 같이 탑재되는 경우가 많음
  - 라우터가 아니더라도 static routing이 가능하면 게이트웨이의 역할 수행 가능
  - 라우터는 여기에 더해 dynamic routing을 수행 가능



### 3.4. Network Interface Layer	

> 같은 내트워크 내 인터페이스간의 전송



이더넷

- 같은 네트워크 내에서 전송하는 프로토콜
  - 한 이더넷 인터페이스에서 다른 이더넷 인터페이스까지 전송
  - **레이어2 스위치**를 거쳐서 전송: 스위치는 데이터에 변경을 가하지 않음
- 이더넷의 규격
  - 최대 전송속도 + 매체
    - 10BASE5: 최대 10Mbps로 베이스 밴드 방식을 이용해 최대 500m의 동축케이블로 전송
    - 1000BASE-T: 최대1000Mbps로 **UTP케이블**을 이용하여 전송
    - 10GBASE-LX4: 최대 10Gbps로 광섬유 케이블을 이용하여 전송
    - UTP 케이블: 일반적인 LAN 케이블로 구리선을 2줄씩 꼬아 4쌍으로 만들었음
      - 보통 100미터를 넘어가지 않음
- 이더넷 프레임
  - 이더넷 헤더 + 데이터 + FCS
    - 헤더 내에는 목적지/출발지 MAC 주소와 **타입 코드**가 포함
      - 타입 코드: 이더넷으로 운반할 대상의 데이터
      - IPv4는 0x0800, ARP는 0x0806
    - 데이터는 최대 1500byte (Maximun Transmission Unit)
      - 이를 넘는 데이터는 전송 계층에서 분할해 줌
      - IP헤더, TCP헤더 20바이트 씩을 제외하고 1460바이트가 넘는 메시지
    - FCS는 4byte로 에러를 체크함



토폴로지

- 기기들을 어떤 형태로 연결할 것인가? 버스형, 스타형, 링형
- 초기 이더넷은 **버스형**: 전송 매체 공유에 따른 충돌 문제 발생
  - 데이터 전송 타이밍 제어로 **CSMA/CD** 도입
  - "선착순"방식: 케이블이 비었으면 전송, 충돌하면 랜덤 시간 대기 후 다시 비었는지 보고 전송
  - 현재 이더넷은 **스타형**이 주류고 **전이중 통신**(Full Duplex) 도입으로 충돌 문제 없음
    - 전이중 통신: 전송매체를 **송신용/수신용으로 나누어** 송수신을 동시에 수행
    - UTP케이블 RJ45 인터페이스의 경우 1,2수신용 3,6송신용: 4개만 사용함



무선 LAN

- L2스위치에 연결된 **무선 LAN 액세스 포인트**가 무선 LAN 클라이언트와 연결
  - 통신 시 액세스 포인트 경유 여부에 따라 인프라스트럭처모드(O), Ad-Hoc모드(X)로 분류
  - 무선 LAN에 연결하는 것을 **어소시에이션**이라고 함
    1. 무선 LAN 클라이언트가 액세스 포인트의 제어신호(비콘) 중 이용 가능한 주파수 탐색
    2. **SSID**를 지정하여 어소시에이션 요청 보냄
    3. 액세스 포인트가 어소시에이션 응답으로 접속 가능 여부 통지
  - SSID
    - **무선 LAN의 논리적 그룹**을 식별하는 정보
    - 액세스 포인트에 32bit의 SSID가 지정되어 있음
    - 보안 설정은 SSID별로 실시
- 충돌 문제
  - 무선 LAN 액세스 포인트는 한번에 한 클라이언트의 전파만을 수신 가능
  - 충돌을 방지하기 위해 **CSMA/CA** 이용: 충돌 회피
    1. 전파가 이용중인지 확인
    2. 이용중이 아니더라도 랜덤 시간 대기 후(동시에 미사용 판단 가능성) 다시 확인하고 송신
  - 위의 대기 시간이 기본적으로 존재하기 때문에 실효속도(throughput)은 규격상 전송속도의 절반 정도가 됨
- 보안
  - 도청이 편리한 구조: 보안 대책 필수
  - 일반적으로 WPA2 보안 규격이(IEEE802.11i) 이용됨
    - WPA2는 AES 암호와 IEEE802.1X 인증을 이용함





레이어2 스위치(액세스 스위치, 스위칭 허브)

- 이더넷 헤더의 MAC 주소를 확인하여 동일 네트워크 내에서 데이터를 전송

  - 이더넷 프레임은 **전혀 변경하지 않음**
    1. 출발지 MAC주소를 **MAC주소 테이블**에 등록
    2. MAC주소 테이블에서 목적지 MAC주소를 찾아 프레임 전송
    3. 테이블에 없는 경우, **Flooding**: 수신 포트를 제외한 모든 포트로 전송
  - MAC주소 테이블: 스위치별로 **MAC주소와 포트의 대응 관계**를 기록해둔 표
    - 제한 시간 있음(5분 정도)
    - 하나의 포트에 여러 MAC주소가 기록될 수 있음
    - 포트에 연결된 것이 호스트가 아니라 스위치라고 생각해보자!

- 네트워크 분할: **VLAN**

  - L2스위치를 가상으로 분할, 같은 VLAN에 할당한 포트끼리만 프레임을 전송할 수 있도록 함

  - VLAN은 **보안/관리 측면에서 이점**이 있음

    - 데이터 전송 범위를 제한하여 보안 향상
    - 한 네트워크에 기기가 지나치게 많으면 불필요한 전송이 많아짐

  - 복수의 스위치에 걸쳐서 VLAN을 만드는 것도 가능함

    - 스위치 간 연결 효율화를 위해 **태그 VLAN**(트렁크)를 이용하기도 함

    - 태그 VLAN은 포트를 분할

      ![트렁크](https://blog.kakaocdn.net/dn/7P6UY/btqyAcBzKjt/AMBadrFtJ178vntXj4kam1/img.png)

  - **VLAN 간 통신**을 위해서는 라우터나 L3 스위치에 연결해야 함

    - 먼저 IP주소 설정: L3스위치 내부 VLAN 인터페이스 or 포트 자체에 설정
    - 설정한 IP주소로 네트워크 간 연결과 동일하게 라우팅을 거쳐 연결



## 4. 네트워크 보안

> 공격으로부터 네트워크를 보호하기 위해 취약한 부분을 



### 4.1. 보안상 위협



### 4.2. 암호화

#### 인증

보안 대책에서 가장 기본적이고 중요한 수단

정식 사용자 외에는 네트워크나 시스템에 접근할 수 없도록 함



인증의 종류

- 사용자가 아는 **정보**를 이용
  - 패스워드
- 사용자가 소유한 **물건**을 이용
  - 사원증
- 사용자의 신체적 **특징**을 이용
  - 바이오메트릭스



#### 암호화

데이터를 도청될 위험으로부터 지키기 위해 데이터를 암호화 함

암호화하기 전의 데이터를 **평문**이라고 하며 **암호키**를 이용하여 암호문을 생성



대칭키 암호 방식

- 암호화와 복호화에 같은 키를 사용함
- 암호화와 복호의 처리 부하 작으나 **키 배송 문제**가 있음
  - 암호키를 어떻게 공유하고 갱신할 것인가?
  - 암호키를 갱신하지 않고 계속 사용하면 규칙성을 읽힐 수 있기 때문
- 주요 알고리즘: 3DES, AES



공개키 암호 방식

- **수학적 연관성을 갖는 공개키와 비밀키**를 이용함
  1. 공개키와 비밀키 쌍을 갖는 수신자가 공개키를 공개함
  2. 송신자는 공개키를 이용하여 암호화하여 전송
  3. 수신자는 비밀키를 이용하여 복호
- **디지털 서명**
  - **비밀키로 암호화하면 공개키로 복호할 수 있다**는 점을 이용해 **데이터 변조 여부 확인**
    1. 송신자는 데이터에서 해시값을 생성
    2. 해시값을 비밀키로 암호화: 서명
    3. 데이터와 서명을 전송
    4. 수신자는 공개키로 서명을 복호하여 해시값을 얻음
    5. 수신한 데이터에서 생성한 해시값과 서명의 해시값을 비교하여 일치 여부 판단
- 공개키는 인증이 필요함
  - 제3자가 송신자에게 의도적으로 잘못된 공개키를 전송한 후 암호문을 가로채 기밀을 얻을 수 있음
  - 디지털 서명을 이용하여 공개키의 진위 여부 판단
    - PKI(Public Key Infrastructure):신뢰할 수 있는 제3자 기관 CA(Certification Authority)에서 **디지털 인증서**를 발행
    - 디지털 인증서: 의뢰사의 공개키 + CA의 비밀키로 만든 디지털 서명
- 주요 알고리즘: RSA, 타원 곡선 암호



SSL(Secure Socket Layer): 하이브리드 암호 

- TCP/IP 암호화 통신에 사용되는 프로토콜로 넷스케이프에서 개발함 
- 암호화 방식
  1. A가 공개키를 이용하여 대칭키를 암호화한 것을 B에게 보냄
  2. B는 비밀키로 복호화하여 대칭키를 입수
  3. 이후 대칭키를 이용하여 통신
-  HTTPS와 SSL
  - HTTPS: SSL 프로토콜을 이용해 클라이언트와 서버가 암호화된 데이터를 주고받는 것
  - HTTPS 통신 흐름
    1. 서버 소유 기업이 공개키와 비밀키를 제작
    2. CA가 공개키에 대해 디지털 인증서를 만들고 이를 다시 비밀키로 암호화해 전달
    3. 클라이언트가 서버에 요청을 보내면 암호화된 인증서를 수신
    4. 브라우저는 CA의 공개키를 이용해 이를 복호화하여 서버의 공개키 획득
    5. 브라우저는 대칭키를 생성하고 서버의 공개키로 이를 암호화
    6. 서버는 비밀키를 이용하여 브라우저의 대칭키를 입수
    7. 이후 대칭키를 이용하여 통신



VPN(Virtual Private Network)

- 인터넷을 가상으로 사설네트워크처럼 다루는 기술
- WAN 구축 비용을 아끼기 위해 인터넷을 사설 네트워크처럼 이용하는 방식
  - 터널링: 거점 LAN 라우터 사이를 가상으로 연결
  - 터널을 경유하는 데이터는 암호화



## 5. 클라우드

클라우드란?

일반 사용자가 복잡한 컴퓨터 통신망의 네트워크 및 서버 구성 등을 알 필요 없이 어디에서나 구름 속(에 있다고 생각하는) 컴퓨터 자원으로 자기가 원하는 작업을 할 수 있다는 것



여기서는 **클라우드 서비스**에 대해 다룸

- 서버를 직접 관리/운용하지 않고 인터넷을 통해 서버의 기능만 이용하는 것
- 서버의 어느 부분을 사용자가 이용하는지에 따라 IaaS, PaaS, SaaS로 분류함



### 5.1. IaaS, PaaS, SaaS

