# C

C언어



참고자료

- 윤성우, 열혈강의 C 프로그래밍
- Softbank 사내 교육 프로그램
- 홍정모, 따라 배우는 C



[TOC]

## **1. C언어의 기본**

> ?



### 1.1. C언어 개론



C언어란

- C언어는 **프로그래밍 언어**의 일종임
- 프로그래밍 언어는 사람과 **컴파일러**가 이해할 수 있는 언어
  - 컴파일러는 인간의 언어를 기계어로 번역해 주는 것: 번역하는 일을 **컴파일**이라 함
    - 실행파일을 만들어 줌(C의 경우, 오브젝트 코드를 만들어 줌)
    - C, C++의 경우엔 **링커**도 필요함
    - 오브젝트 코드와 라이브러리 코드, start-up 코드를 엮어 실행 파일로 만들어 줌
  - 프로그래밍은 소스코드 작성부터 프로그램 실행까지의 과정
    - IDE는 일련의 과정을 통합하여 진행할 수 있도록 해줌



C언어의 탄생

- UNIX 개발을 위해 탄생함
  - 어셈블리어로 작성된 UNIX의 높은 하드웨어 의존도를 극복할 필요성 있었음
  - low-level언어의 특성을 가지면서도 높은 이식성과 익히기 쉽다는 특징의 C언어 개발
- 타 언어 대비(FORTRAN) 배우기 쉬운 점 + Kernighan의 매뉴얼로 대중화 성공



C언어의 특징

- 장점
  - **절차지향적**으로 익히기 쉬움: 인간의 사고방식은 기본적으로 절차지향
  - 이식성이 높고 유연함
    - **CPU 종류에 상관 없이 실행이 가능**함
    - 기본적으로 모든 것을 만들 수 있음
  - 성능이 좋음
    - 하드웨어를 제어하기 편리하게 설계되어 있음
  - 프로그래머 중심임
    - 프로그래머에게 많은 권한을 줌
- 단점
  - 높은 자유도를 취하는 대신 프로그래머가 **신경 쓸 부분이 많음**
    - 메모리 관리 등



C언어의 표준

- K&R C(classic C, 1978): UNIX와 함께 제공된 라이브러리가 표준
- ANSI(1989), ISO(1990)에서 The spirit of C를 제정
  - 프로그래머를 믿어라
  - 한 연산에 한 가지 방법만 제공해라
  - 호환이 보장되지 않더라도 속도를 빠르게 해라 
- ANSI/ISO C9X Committee
  - 국제 문자집합 추가
  - 64bit 프로세서 대응
  - **C언어는 단순하게** 유지, C++의 사이즈를 키우는 방향으로 합의
- C11 standard
  - C99의 일부를 선택적 기능으로 변경: 오히려 표준을 더 줄여버림
  - 멀티 프로세서 대응 concurrent programming



함수

> "C언어는 함수로 시작해서 함수로 끝난다"

- 입력에 따른 출력이 존재하고 **기능**을 지니는 것

  - 프로그래밍의 목적은 기능들을 수행하는 것
  - **인자**: 함수의 호출(함수 실행을 명령하는 것)을 위해 전달하는 입력 값

- 함수의 구조

  - ```c
    int main (void)		// 출력형태, 함수이름, 입력형태
    {
        printf("Hello world! \n");		// body
        return 0;
    }
    ```

  - 함수의 특성: 입력형태, 출력형태, 함수이름

  - 함수의 기능을 정의하는 영역을 body라고 함

  - cf) python은 indenting이 생명이나 C의 경우 컴파일러가 알아서 빈칸을 다 없애기 때문에 몇 칸을 띄어도 상관 없음 

- main 함수

  - 프로그램이 실행되자마자 호출되는 함수
  - C언어로 구현된 모든 프로그램에는 main 함수가 정의되어야 함
    - main은 다른 함수와 달리 이름을 바꿀 수 없음
    - **정해진 순서**에 의해서 진행되는 **함수의 호출이 프로그램의 흐름**

- 표준함수

  - `printf()`는 정의하지 않았는데 호출됨: 기본적으로 제공된 것
  - 기본적으로 제공되는 함수가 표준함수로, 이들의 집합을 **표준 라이브러리**라 함
  - 표준함수의 호출에는 **헤더파일 선언**이 필요함
    - 헤더파일 선언은 소스파일 맨 앞에 와야 함

- RETURN의 기능

  - 함수를 **호출한 영역으로** 결과값을 전달
  - 실행중인 함수 종료
    - **main함수의 종료는 프로그램의 종료**가 됨



### 1.2. 변수와 연산자



변수란?

- 값을 저장할 수 있는 **메모리 공간에 붙은 이름**
  - 혹은 메모리 공간 그 자체를 변수라 함
- 왜 필요한가? 편리하니까
  - CPU가 작업을 할 때는 **메모리 주소**가 필요 (아키텍처 참고)
  - 변수의 도입으로 메모리 주소를 일일이 표현하지 않아도 됨
    - **변수의 이름을 통해** 값을 저장 및 참조



변수의 종류

- 전역변수
  - 프로그램의 어디서든 접근 가능, main이 실행되기 전에 메모리에 할당(Data 영역)
    - 중괄호 내에 선언되지 않음
    - 프로그램 시작과 동시에 할당되어 종료시까지 존재
    - 초기화하지 않으면 0으로 초기화 됨
  - 프로그램이 커지면 전역변수로 인해 **프로그램이 복잡해질 수 있음**
    - 전역변수의 변경은 다른 함수의 변경을 요구함
- 지역변수
  - 특정 블록에서만 접근 가능, 함수가 **실행될 때마다 Stack 영역에 기록**
- 정적변수
  - 특정 블록에서만 접근 가능: 프로그램이 실행될 때 메모리에 할당되고, 종료되면 해제(Data 영역)
  - 앞에 static을 붙여서 선언`static int a=5;`
  - 지역변수에 static을 붙이면 전역변수의 성격을 지니는 지역변수가 됨
    - 1번만 초기화되고 **프로그램 종료 시까지 메모리 상에 존재**함(전역 변수 특징)
    - **선언된 함수 내에서만 접근 가능**(지역 변수 특징)
  - 전역변수의 단점(어디서나 접근, 변경)을 극복했기 때문에 **가급적 전역변수는 static으로 대체**
- register변수
  - 메인 메모리 대신 레지스터를 사용
    - 단 레지스터는 매우 한정되어 있으므로 실제 레지스터에서 처리될지는 모름
    - 저장 여부는 컴파일러가 결정함
    - 일반적인 변수를 사용했을 때보다 더 빠르게 처리됨
  - 앞에 register를 붙여서 선언`register int a=10;`
    - 전역변수에는 register를 붙일 수 없음: 하나의 변수가 레지스터에 계속 머무르는 것은 낭비



변수의 선언, 대입

- `int num;` 
  - int: **정수**의 저장이 가능한 메모리 공간을 할당함
  - num: 그 공간의 이름을 num이라 **선언**함
    - 선언 시 주의사항: 중괄호 내에서 선언할 경우 선언문은 앞부분에 와야 함
- `num = 1;`
  - 변수 num에 1이라는 값을 **대입**함
  - 선언된 변수에 처음으로 값을 저장하는 것을 **초기화**라 함
    - 선언만 하고 초기화하지 않으면 **쓰레기 값**이 저장됨
  - `int num=12;` 하는 식으로 선언과 동시에 초기화하는 것도 가능
  - `int num1=10, int num2=20;` 과 같이 여러 변수를 동시에 선언하는 것도 가능



연산자

- postIncrement, preIncrement

  - `++num` : 값을 1 증가 후, 속한 **문장**의 나머지를 진행
  - `num++`: 속한 **문장**을 진행한 후 값을 1 증가
  - postIncrement의 경우 괄호가 있어도 관계 없이 문장이 끝나야만 증가
    - `int num2 = (num1--) + 2;` 의 경우 num1의 원래 값으로 연산을 끝내고 num1의 값을 변경함

- 관계 연산자

  - <, >, ==, !=, <=, >=
  - 조건을 만족하면 1을, 만족하지 않으면 0을 반환함
    - 파이썬과 달리 **리턴 값이 숫자**임에 주목
    - 참고) C는 0이 아닌 모든 숫자를 true로 판단

- 논리 연산자

  - &&, ||, !

  - 이것도 참이면 1을, 거짓이면 0을 리턴

  - ```c
    int num1 = 10;
    int num2 = 12;
    
    result1 = (num1 == 10 && num2 == 12);
    ```

    - `num1 == 10`의 결과는 1(true), `num2 == 12`의 결과도 1
    - 1 && 1의 결과도 1 이므로 result1에는 1이 저장됨
    - **논리 연산자보다 관계 연산자가 먼저 진행됨**

- 연산자 우선순위

  - **결합방향**: 우선순위가 동일한 두 연산자가 하나의 수식에 존재할 때 연산하는 순서
  - ![priority](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F264ACE4658DE886F33)

- 함수 호출문의 인자전달 위치에 연산식이 올 수 있다



#### 자료형

자료형이란?

- 변수에 담기는 데이터의 형태
  - int, char, float 등
- 자료형이 필요한 이유
  - CPU가 데이터를 구분할 수 있도록 사전에 알려주기 위해서
    - 자료형은 **데이터를 표현하는 기준**이 됨
    - 기본적으로는 정수/실수 구분만 하면 되지만 효율성을 위해 더 많은 자료형 존재
  - 데이터를 효율적으로 다루기 위해: **메모리 사이즈별로 자료형을 구분**
    - ANSI에서는 자료형 별 크기를 정확히 제한하고 있지는 않음
    - 컴파일러마다 조금씩 차이가 있음: `sizeof()` 연산자를 이용하여 확인하자
    - int가 CPU가 성능을 내기에 가장 좋기 때문에 **int보다 작은 데이터는 int로 바꿔서 연산**함
      - `char num1=1, num2=2;` 에서 `sizeof(num1+num2)`는 4가 됨
- 자료형 별 서식문자
  - 



정수/실수의 표현

- 정수의 표현

  - Most Significant Bit: 가장 왼쪽 비트로 부호를 나타냄
  - 2의 보수: 더했을 때 0이 되도록 하는 수
    - 해당 수의 비트를 전부 바꾼 후 1을 더해 줌

- 실수의 표현: 부동소수점

  ![float](https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Float_point_example_frac.svg/900px-Float_point_example_frac.svg.png)

  - 실수를 **근사**하여 유효숫자를 나타내는 가수 + 소수점 위치를 나타내는 지수로 나누어 표기
    - 위 그림과 같은 32bit IEEE 754형식에서는 지수에 7bit, 가수에 23bit를 사용
    - 표현할 수를 2진법으로 변환하고 소수점을 왼쪽으로 이동시켜 1.xx 형태로 변환(정규화)
    - 소수점을 이동시킨 횟수가 지수, 소수점 이하가 가수
    - 지수에 bias인 127을 더해서 지수부 확정
  - 고정 소수점 방식보다 넓은 범위가 표현 가능하나 느림
  - **정확도 문제** 존재함



문자 자료형

- ASCII Code
  - 128개의 문자를 나타내는 방법
  - `char ch1 = 'A';` 와 같이 문자는 작은 따옴표로 감싸서 표현함
  - char 타입은 문자로도, 숫자로도 출력이 가능함
    - 컴파일러가 아스키 코드를 바탕으로 문자를 숫자로 바꿈
    - `char ch1 = 'A';`, `printf("%c %d", ch1, ch1);`을 수행하면 `A 65`가 출력됨
  - A는 65, a는 97이다



상수란?

- 변경이 불가능한 데이터
- 이름이 없는 상수: **literal**
  - 3, 4, 1.59 같이 이름이 없는 상수
  - 리터럴의 대입
    - 정수형 상수는 정수형 변수에 대입 가능함: `int num = 5;`
    - 문자형 상수 'A' 는 숫자 65로 표현되기 때문에 `sizeof('A')`를 실행하면 4가 됨
    - 접미사가 필요한 경우 있음
      - 정수형 상수는 기본적으로 int, 실수는 double형 데이터기 때문에 각각 char나 float에 대입하면 컴파일 시 경고메시지 발생
      - `float num = 5.789f;` 하는 식으로 해결 가능
- 이름이 있는 상수: **symbolic**
  - 변수 선언 시 const만 추가하면 되고, **선언과 동시에 초기화**해야 함: `const int MAX = 100;`
  - 선언과 동시에 초기화하지 않으면 쓰레기 값이 할당되는데, 상수는 변경 불가하기 떄문
  - 상수의 이름은 **모두 대문자**로 작성하는 것이 관례
    - 둘 이상의 단어를 연결할 때는 언더바 사용: MY_AGE



형 변환

- 데이터의 표현방식을 바꾸는 것으로, 자동 형 변환과 강제 형 변환이 있음

- 자동 형 변환

  - 대입연산에서의 자동 형 변환
    - 대입 시 두 피연산자의 형이 일치하지 않으면 왼쪽을 기준으로 형 변환
    - **저장소의 자료형에 맞춰서 형 변환**되는 것
    - `double num = 252;` int형 정수 245가 double이 됨
    - 데이터 표현범위가 좁은 자료형으로의 변환은 **데이터 손실이 발생할 수 있음**
  - Integral Promotion에서의 자동 형 변환
    - int보다 작은 정수형 데이터의 연산 시 발생
  - 피연산자의 자료형 불일치
    - 산술연산에서 피연산자 둘이 자료형이 다를 경우 **데이터 손실을 최소화**하는 쪽으로 형 변환
    - 정수 자료형보다 실수 자료형이 앞섬
    - int > long > long long > float > double > long double

- 강제 형 변환(명시적 형 변환)

  - **소괄호를 이용하여 자료형을 변환**해 줌

  - ```c
    int num1 = 3, num2 = 4;
    double result = num1 / num2;
    ```

  - 위 코드에서 num1 / num2 는 정수끼리의 연산이기 때문에, `(double)num1`을 해줘야 함

    - num1이 double로 형변환되므로 num1 / num2는 자동 형변환 됨



### 1.3. 제어문과 함수

> 프로그램을 순차적으로만 실행하는 것이 아니라 원하는 대로 흐름을 바꿈: "제어"



#### 1.3.1. 반복문

while 문

- 특정 조건을 주고 **조건을 만족하는 동안** 특정 영역을 계속해서 반복

  - ```c
    while(num<3)								// 반복 조건
        printf("Hello world! %d \n", num++);	// 반복 영역
    ```

  - 먼저 조건을 확인(비교연산 진행)하고 반복영역을 실행한 후 **다시 조건 심사**

  - 반복의 대상이 한 문장이라면 중괄호 생략 가능

  - 반복조건이 와야 할 위치에 참 값이 오면 무한루프가 됨: **break**로 탈출

- while문은 중첩 가능

  - ```c
    int main(void){
    	int cur = 2, is = 0;
        
        while(cur < 10){
            is = 1;
            while(is < 10){
                printf("%d * %d = %d", cur, is, cur*is);
                is++;
            }
            cur++;
        }
        return 0;
    }
    ```



do-while 문

- 반복조건을 **뒤에서 검사**한다는 점이 while문과의 차이점
  - 반복문을 반드시 **1번 이상 시행**함
  - 일반적으로는 while문을 사용하고, 1번 이상 꼭 실행될 필요가 있을 때 do-while문 사용



for 문

- 반복을 위한 변수선언, 조건검사, 종료조건 3가지를 한 문장에 묶어서 편하게 구성한 반복문
- 반복 횟수가 정해진 경우 for문이 편하고 아닌 경우 while문이 좋을 수 있음



반복문 생략 및 탈출

- break
  - 자신을 감싸는 **가장 가까운 위치의 반복문 하나**를 빠져나가는 데 사용됨
- continue
  - continue문 이후는 생략하고 반복문의 조건검사 위치로 돌아옴 



#### 1.3.2. 조건문

if문

- **조건에 따라서 실행을 하느냐 마느냐**를 가능하게 함
  - 
  - 조건이 만족될 때 실행할 문장이 하나라면 중괄호 생략 가능
  - if문은 몇 줄에 걸쳐서 표현되더라도 하나의 문장으로 인식됨
- else의 도입
  - if와 else가 만나서 이루는 문장은 하나임
  - else if는 if~else문을 중첩시킨 것
- 조건 연산자
  - `(num1 > num2) ? num1 : num2`
  - 삼항 연산자라고도 함
  - if ~ else문을 대체하는 용도로 많이 사용됨



switch

- 언제 사용하는가?
  - 조건 분기의 수가 많은 경우 switch의 사용이 권장됨
- switch와 break
  - break는 switch문의 영역을 구분하는 데 사용됨
  - break가 없으면 다음 케이스들이 계속 실행됨



#### 1.3.3. 함수

함수의 선언

- 함수 정의의 구조
  - 반환 형태, 함수 이름, 입력 형태, body
  - 함수는 전달인자의 유무, 반환 값의 유무에 따라 4가지 유형으로 분류 가능
  - 선언 시 **매개변수의 이름을 생략해서 선언**하는 것이 가능함
    - 그럼 body에서 매개변수를 어떻게 하지?
- 함수의 호출
  - 한번 정의된 함수는 몇 번이고 반복 호출 가능
  - 호출되기 전에 정의되어야 함
  - 함수가 호출되면 **호출된 함수의 영역으로 실행의 흐름이 이동**
  - main을 포함하여 모든 함수는 다른 함수를 호출할 수 있음



함수와 변수

- 지역변수
  - 중괄호 내에 선언되는 변수: **선언된 지역 내에서만 유효함**
  - 함수 내에서 선언된 지역변수는 **함수가 호출될 때마다 메모리 공간에 새롭게 할당**됨
    - Stack에 순차적으로 쌓임
    - 함수가 반환되면(종료) 자동으로 소멸됨: 지역변수를 automatic variable이라고도 함
  - 선언된 지역이 다르면 이름이 같아도 문제되지 않음
    - 지역변수는 외부에 선언된 동일한 이름의 변수를 **가림**
  - **매개변수는 지역변수의 일종**임
    - Stack에 쌓임



재귀함수

- 함수 내에서 자기 자신을 호출하는 함수
  - 완료되지 않은 함수를 다시 호출하는 것이 가능한가?
  - **함수의 복사본**을 불러와 실행하기 때문에 가능함



## **2. 포인터, 배열**



### 2.1. 1차원 배열과 포인터



배열이란?

- 다수의 데이터를 순차적으로 접근할 수 있도록 **한번에 많은 수의 변수를 선언**하는 것
- 배열의 선언 `int oneDimArr [4];`
  - 배열을 이루는 요소의 자료형 int
  - 배열의 이름 oneDimArr
  - 배열의 길이 [4]
- 배열의 초기화
  - ```c
    int arr[5] = {1, 2, 3, 4, 5};	// 선언된 길이만큼 원소들을 순서대로 저장
    int arr[] = {1, 2, 3, 4};		// 길이는 컴파일러가 알아서 채워줌
    int arr[4] = {1, 2, 3};			// 채워지지 않은 부분은 0으로 채워짐
    ```



문자열

- 문자열은 **null문자**로 구분되는 배열
  - 널 문자: ASCII 코드 값 0인 문자 `\0`
    - 공백 문자와는 다름(공백문자는 ASCII 32)
  - C언어에서 **모든 문자열의 끝에는 널 문자가 자동으로 삽입**됨
    - 널 문자가 없으면 문자열이 아님
  
- 문자열의 선언

  - ```c
    char str[14] = "Good morning!";		// 마지막의 null문자까지 포함하여 길이 14
    char str[] = "Good morning!";		// 컴파일러가 알아서 길이를 결정
    ```



포인터란?

- **메모리의 주소 값**을 저장하기 위한 변수
- 포인터의 선언 `int * ptr = &num;`
  - 포인터의 타입 `int*` : 이 포인터가 가리키는 주소에 저장된 값은 int 타입임
    - asterisk를 어디에 붙이는지는 상관 없음: `int* ptr`과  `int *ptr`은 동일한 선언
    - 해당 주소를 참조할 때 메모리 공간을 얼마나 읽어야 하는지 알기 위해 타입 선언이 필요
  - 포인터의 이름 `ptr`
  - 포인터에 할당되는 값 `&num`
    - & 연산자: **피연산자의 주소 값을 반환**하는 연산자
- `*` 연산자(간접 참조 연산자)
  - **포인터가 가리키는 메모리 공간**에 접근함
  - `*ptr = 20;`하면 ptr이 가리키는 변수(num)에 20을 저장함
- 포인터는 **반드시 초기화해야** 함
  - 초기화하지 않으면 쓰레기 값으로 초기화
  - 이후 * 연산자를 통해 조작하면 엄한 메모리 공간의 값이 바뀔 수 있음
  - 널 포인터로 초기화하는 것을 권장함
- NULL pointer
  - 아무것도 가리키지 않는 포인터
  - `int *ptr = 0;` 과 같이 초기화



포인터와 배열

- **배열의 이름은 포인터**
  - **배열의 시작 부분을 가리키는 포인터**라고 볼 수 있음
  - 단, 값을 바꿀 수 없는 **상수 형태의 포인터** 임
    - 포인터는 변수로, 값이 바뀌지만 배열의 이름은 배열에 binding되어 있음
    - 포인터는 연산이 가능하지만 배열 이름은 연산이 불가
- 포인터 연산
  - 어떤 타입의 포인터에 n만큼 더하거나 빼면 주소 값은 `n * sizeof(Type)`만큼 변화함
    
    - 주소 값은 %p 서식문자로 출력할 수 있음
    
    - ```c
      int main(void)
      {
          int * ptr1 = 0x0010;
          double * ptr2 = 0x0010;
          
          printf("%p %p", ++ptr1, ++ptr2);
      }
      ```
    
      출력 결과는 00000014, 00000018
    
  - **`arr[i] == *(arr + i)` 임**
- 포인터와 문자열
  - 배열을 기반으로 선언`char str1[] = "My String";`
    - str1은 다른 위치를 가리킬 수 없음: 상수 형태의 포인터
    - 그러나 문자열의 내용물은 변경 가능
    - **변수 형태의 문자열**이라고 함
  - 포인터를 기반으로 선언`char* str2 = "My String";`
    - str2는 다른 위치를 가리킬 수 있음
    - 그러나 문자열의 내용은 변경 불가
    - **상수 형태의 문자열**이라고 함
  - **문자열 리터럴**은 메모리 공간에 저장된 후 주소값이 반환됨
    - String constant: 큰 따옴표에 묶인 문자열, 변경할 수 없음
      - 그럼 `char str1[] = "My String";`도 변경 못하는 것 아닌가?
      - 이 경우엔 배열을 만들어서 문자를 하나씩 넣은 것으로 문자열 상수가 아님
      - 문자열 배열 변수의 내용물은 **Heap**에, 문자열 리터럴은 **정적영역**에 저장됨
      - 이걸 변경하려고 하면 **Segmentation fault** 발생
      - NULL로 설정된 영역(접근이 허용되지 않은 영역)에 접근하려고 하면 발생
    - 함수에 문자열 상수를 인자로 전달하는 경우 "문자열의 주소 값"을 전달하는 것
      - 사용 `whoAreYou("Hong");`
      - 선언 `void whoAreYou(char* str){ ... }`
    - 리터럴이란?
      - 소스코드 상의 어떤 고정된 값을 나타내기 위한 표기
      - 어떤 숫자나 기호가 다른 데이터를 가리키는 것이 아니라 자신이 데이터로 사용되는 것
- 포인터 배열
  - **원소들이 포인터 변수인 배열**
  - `int * arr[10]` 길이가 10이고 int형 포인터들을 저장하는 배열
  - 문자열 배열
    - 문자열의 주소 값을 저장하는 배열: char의 포인터 배열
    - `char* strArr[3] = {"simple", "string", "array"};`



포인터와 함수

- **Call by value**

  - 함수호출 시 인자의 **값을 매개변수에 복사**하여 전달
  - 호출된 이후에 **전달되는 인자와 매개변수는 별개**가 됨
    - 함수 내에서 **복사된 값을 갖는 변수가 새롭게 생성**된다고 이해하면 됨
      - 생성된 변수는 스택에 저장!
    - 함수 내에서 매개변수의 값을 변경해도 인자로 사용된 **원래 변수의 값은 불변**
    - `scanf()`에서 인자로 변수가 아니라 주소를 쓰는 이유

- **Call by reference**

  - 함수호출 시 인자의 **주소(reference)를** 매개변수에 전달

    - 매개변수로 배열을 선언할 수 없기 때문
    - 배열은 일반적으로 크기 때문에 매개변수로 배열을 선언하면 최적화에서 불리
    - 주소만 전달한 것이기 때문에 **원래의 변수에 접근 가능**

  - 주소는 포인터나 배열 이름으로 전달함

    - 포인터: `void showArayElem (int* param, int len)`

    - 배열 이름: `void showArayElem (int param[], int len)`

    - 위 둘은 완전히 동일한 선언

    - 그러나 함수 내에서 배열을 선언하고 다른 배열명을 가져와 초기화하는 것은 불가

      - ```c
        int arr[3] = {1, 2, 3};
        int ptr[] = arr;		// 불가능
        ```

- swap 함수

  - 대표적인 call by value와 call by reference의 차이를 설명하는 예제
  - 여기에 안 써도 알지?



포인터와 const

- 선언하는 방법의 종류
  - 타입 앞에 const 선언
    - `const int* ptr = &num;`
    - **num에 저장된 값을 변경할 수 없음**
    - ptr이 가리키는 주소 자체를 바꾸는 것은 가능
  - 타입 뒤에 const 선언
    - `int* const ptr = &num;`
    - num에 저장된 값은 변경 가능
    - **다른 주소를 가리키는 것은 불가**
  - 양쪽에 const 선언
    - `const int* const ptr = &num;`
- const 선언을 무의미하게 만드는 문장을 삽입하면 안 됨
  - 예) `const int* ptr = &num;` 으로 선언하고 `int* rptr = ptr;`로 선언하면 rptr을 이용하여 num에 저장된 값 변경 가능
  - 컴파일은 되지만 에러메세지가 뜨고 권장하지 않음



### 2.2. 다차원 배열과 포인터



2차원 배열의 선언

- `TYPE arr[행 길이][열 길이];`

  - 1행 1열의 인덱스는 `[0][0]`임에 주의하자
  - 메모리는 선형으로 할당: **한 행이 다 할당되면 그 다음 행이 할당**됨

- 초기화

  - ```c
    int arr[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    ```

  - 초기화를 생략하고 비는 공간은 0으로 초기화 됨

  - 안쪽 중괄호는 쓰지 않아도 알아서 0행0열 - 0행 n열 - n행 n열 순으로 초기화 됨

  - 배열의 **세로길이를 생략하고 초기화 가능**

    - 가로길이는 안됨
    - `int arr[][4] = {1, 2, 3, 4, 5, 6, 7, 8};`



더블 포인터

- 정의

  - **포인터를 가리키는 포인터**

  - ```c
    int num = 3;
    int * ptr = &num;
    int ** dptr = &ptr;
    ```

- swap함수

  - 변수를 swap하는 함수는 포인터를 인자로, **포인터를 swap하는 함수는 더블 포인터를 인자로**

- 포인터 배열

  - 포인터 배열의 배열명은 더블 포인터
  - `int * arr1[20];` 에서 arr1은 int형 더블 포인터가 됨



다차원 배열과 포인터

- 배열 포인터
  - `int (*ptr) [4];` 
    - 열의 길이가 4인 int형 2차원 배열을 나타내는 포인터
    - 가리키는 대상(int), 포인터 이름(ptr), 포인터 연산 시 크기가 증감하는 단위(sizeof(int)*4)
  - 포인터 배열과의 차이
    - `int (*arr) [4];` 열의 길이가 4인 int형 2차원 배열을 가리키는 포인터 arr의 선언
    - `int * arr [4];` int형 포인터 4개를 담는 포인터 배열 arr의 선언
  - 함수 인자로 전달
    - `int (*ptr)[7]`은 `int ptr[][7]`과 같이 인자로 전달 가능
- `sizeof(arr) / sizeof(arr[0])`
  - 2차원 배열의 행 길이를 계산할 때 흔히 사용되는 방법()
- `arr[i] == *(arr + i)`
  - `arr[2][1] = 4;`는
  - `(*(arr+2))[1] = 4;`로 대체 가능
    - arr는 특정 열의 길이를 갖는 2차원 배열을 가리키는 포인터
    - arr + 2는 2번 행이 시작되는 주소를 가리키는 포인터
    - `*(arr + 2)`는 2번 행을 나타내는 포인터: `(*(arr + 2))[1]`로 접근하여 값을 바꿈
    - `*(arr[2] + 1) = 4;` 또는 `*(*(arr+2)+1)=4;` 로도 대체 가능



### 2.3. 함수 포인터, void 포인터

함수 포인터

- **함수의 주소 값을 저장**하는 포인터 변수
- 함수 포인터의 선언: 반환형과 매개변수 선언의 정보가 필요
  - `int SoSimple(int num1, int num2){...}` 의 포인터는 다음과 같이 선언
  - `int (*fptr) (int, int);`
  - 할당은 함수 이름으로 하면 된다: `fptr = SoSimple;`
  - 호출은 함수와 동일하게 인자를 전달하여 실행: `fptr(3, 4);`
- 함수 포인터는 매개변수의 선언으로도 올 수 있음



void 포인터

- 변수의 타입에 관계 없이 주소 값을 담을 수 있는 포인터
  - 함수의 주소 값도 담을 수 있음
  - **포인터 연산이 불가하다**는 단점 존재
  - 먼저 선언하고 타입은 나중에 결정하는 식으로 해결



main 함수에의 인자 전달

- `int main(void){...}` 를 다음과 같이 선언 가능
- `int main(int argc, char * argv[]){...}`
  - argc는 전달되는 문자열의 수
  - argv는 char형 더블 포인터 변수로, char형 포인터 변수로 이뤄진 1차원 배열의 이름을 전달 받음
    - 각각의 char형 포인터 변수는 전달되는 문자열을 가리킴
    - argc는 argv의 길이를 나타내게 됨



## **3. C언어 심화**