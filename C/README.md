# C

C언어



참고자료

- 열혈강의 C 프로그래밍



[TOC]

## **1. C언어의 기본**

> ?



### 1.1. C언어 개론



C언어란

- C언어는 **프로그래밍 언어**의 일종임
- 프로그래밍 언어는 사람과 **컴파일러**가 이해할 수 있는 언어
  - 컴파일러는 인간의 언어를 기계어로 번역해 주는 것: 번역하는 일을 **컴파일**이라 함
    - 실행파일을 만들어 줌(C의 경우, 오브젝트 코드를 만들어 줌)
    - C, C++의 경우엔 **링커**도 필요함
    - 오브젝트 코드와 라이브러리 코드, start-up 코드를 엮어 실행 파일로 만들어 줌
  - 프로그래밍은 소스코드 작성부터 프로그램 실행까지의 과정
    - IDE는 일련의 과정을 통합하여 진행할 수 있도록 해줌



C언어의 탄생

- UNIX 개발을 위해 탄생함
  - 어셈블리어로 작성된 UNIX의 높은 하드웨어 의존도를 극복할 필요성 있었음
  - low-level언어의 특성을 가지면서도 높은 이식성과 익히기 쉽다는 특징의 C언어 개발
- 타 언어 대비(FORTRAN) 배우기 쉬운 점 + Kernighan의 매뉴얼로 대중화 성공



C언어의 특징

- 장점
  - **절차지향적**으로 익히기 쉬움: 인간의 사고방식은 기본적으로 절차지향
  - 이식성이 높고 유연함
    - **CPU 종류에 상관 없이 실행이 가능**함
    - 기본적으로 모든 것을 만들 수 있음
  - 성능이 좋음
    - 하드웨어를 제어하기 편리하게 설계되어 있음
  - 프로그래머 중심임
    - 프로그래머에게 많은 권한을 줌
- 단점
  - 높은 자유도를 취하는 대신 프로그래머가 **신경 쓸 부분이 많음**
    - 메모리 관리 등



C언어의 표준

- K&R C(classic C, 1978): UNIX와 함께 제공된 라이브러리가 표준
- ANSI(1989), ISO(1990)에서 The spirit of C를 제정
  - 프로그래머를 믿어라
  - 한 연산에 한 가지 방법만 제공해라
  - 호환이 보장되지 않더라도 속도를 빠르게 해라 
- ANSI/ISO C9X Committee
  - 국제 문자집합 추가
  - 64bit 프로세서 대응
  - **C언어는 단순하게** 유지, C++의 사이즈를 키우는 방향으로 합의
- C11 standard
  - C99의 일부를 선택적 기능으로 변경: 오히려 표준을 더 줄여버림
  - 멀티 프로세서 대응 concurrent programming



함수

> "C언어는 함수로 시작해서 함수로 끝난다"

- 입력에 따른 출력이 존재하고 **기능**을 지니는 것

  - 프로그래밍의 목적은 기능들을 수행하는 것
  - **인자**: 함수의 호출(함수 실행을 명령하는 것)을 위해 전달하는 입력 값

- 함수의 구조

  - ```c
    int main (void)		// 출력형태, 함수이름, 입력형태
    {
        printf("Hello world! \n");		// body
        return 0;
    }
    ```

  - 함수의 특성: 입력형태, 출력형태, 함수이름

  - 함수의 기능을 정의하는 영역을 body라고 함

  - cf) python은 indenting이 생명이나 C의 경우 컴파일러가 알아서 빈칸을 다 없애기 때문에 몇 칸을 띄어도 상관 없음 

- main 함수

  - 프로그램이 실행되자마자 호출되는 함수
  - C언어로 구현된 모든 프로그램에는 main 함수가 정의되어야 함
    - main은 다른 함수와 달리 이름을 바꿀 수 없음
    - **정해진 순서**에 의해서 진행되는 **함수의 호출이 프로그램의 흐름**

- 표준함수

  - `printf()`는 정의하지 않았는데 호출됨: 기본적으로 제공된 것
  - 기본적으로 제공되는 함수가 표준함수로, 이들의 집합을 **표준 라이브러리**라 함
  - 표준함수의 호출에는 **헤더파일 선언**이 필요함
    - 헤더파일 선언은 소스파일 맨 앞에 와야 함

- RETURN의 기능

  - 함수를 **호출한 영역으로** 결과값을 전달
  - 실행중인 함수 종료
    - **main함수의 종료는 프로그램의 종료**가 됨



### 1.2. 변수와 연산자



변수란?

- 값을 저장할 수 있는 **메모리 공간에 붙은 이름**
  - 혹은 메모리 공간 그 자체를 변수라 함
- 왜 필요한가? 편리하니까
  - CPU가 작업을 할 때는 **메모리 주소**가 필요 (아키텍처 참고)
  - 변수의 도입으로 메모리 주소를 일일이 표현하지 않아도 됨
    - **변수의 이름을 통해** 값을 저장 및 참조



변수의 선언, 대입

- `int num;` 
  - int: **정수**의 저장이 가능한 메모리 공간을 할당함
  - num: 그 공간의 이름을 num이라 **선언**함
    - 선언 시 주의사항: 중괄호 내에서 선언할 경우 선언문은 앞부분에 와야 함
- `num = 1;`
  - 변수 num에 1이라는 값을 **대입**함
  - 선언된 변수에 처음으로 값을 저장하는 것을 **초기화**라 함
    - 선언만 하고 초기화하지 않으면 **쓰레기 값**이 저장됨
  - `int num=12;` 하는 식으로 선언과 동시에 초기화하는 것도 가능
  - `int num1=10, int num2=20;` 과 같이 여러 변수를 동시에 선언하는 것도 가능



연산자

- postIncrement, preIncrement

  - `++num` : 값을 1 증가 후, 속한 **문장**의 나머지를 진행
  - `num++`: 속한 **문장**을 진행한 후 값을 1 증가
  - postIncrement의 경우 괄호가 있어도 관계 없이 문장이 끝나야만 증가
    - `int num2 = (num1--) + 2;` 의 경우 num1의 원래 값으로 연산을 끝내고 num1의 값을 변경함

- 관계 연산자

  - <, >, ==, !=, <=, >=
  - 조건을 만족하면 1을, 만족하지 않으면 0을 반환함
    - 파이썬과 달리 **리턴 값이 숫자**임에 주목
    - 참고) C는 0이 아닌 모든 숫자를 true로 판단

- 논리 연산자

  - &&, ||, !

  - 이것도 참이면 1을, 거짓이면 0을 리턴

  - ```c
    int num1 = 10;
    int num2 = 12;
    
    result1 = (num1 == 10 && num2 == 12);
    ```

    - `num1 == 10`의 결과는 1(true), `num2 == 12`의 결과도 1
    - 1 && 1의 결과도 1 이므로 result1에는 1이 저장됨
    - **논리 연산자보다 관계 연산자가 먼저 진행됨**

- 연산자 우선순위

  - **결합방향**: 우선순위가 동일한 두 연산자가 하나의 수식에 존재할 때 연산하는 순서
  - ![priority](https://lh3.googleusercontent.com/proxy/Xa8ZdZ8Qx1IuN56E1hvdKaMrEdngdeVFUHPMnGQxwmvD0vOCjtTodMjH1osZQyj57r4m27uAIv4yDHeLIUiJtqwObecSWrbjPDVScHFSyw64_qsJKn-Vum2H5Ilbaex6gx2ZRhsRJBDM8LMS9506Ma9bNDttyPOqhFGcom3GTTi-8-H1QwLU7v41Dw4fLBwcdUAMUKkF3ibLWgkp)

- 함수 호출문의 인자전달 위치에 연산식이 올 수 있다



#### 자료형

자료형이란?

- 변수에 담기는 데이터의 형태
  - int, char, float 등
- 자료형이 필요한 이유
  - CPU가 데이터를 구분할 수 있도록 사전에 알려주기 위해서
    - 자료형은 **데이터를 표현하는 기준**이 됨
    - 기본적으로는 정수/실수 구분만 하면 되지만 효율성을 위해 더 많은 자료형 존재
  - 데이터를 효율적으로 다루기 위해: **메모리 사이즈별로 자료형을 구분**
    - ANSI에서는 자료형 별 크기를 정확히 제한하고 있지는 않음
    - 컴파일러마다 조금씩 차이가 있음: `sizeof()` 연산자를 이용하여 확인하자
    - int가 CPU가 성능을 내기에 가장 좋기 때문에 **int보다 작은 데이터는 int로 바꿔서 연산**함
      - `char num1=1, num2=2;` 에서 `sizeof(num1+num2)`는 4가 됨
- 자료형 별 서식문자
  - 



정수/실수의 표현

- 정수의 표현

  - Most Significant Bit: 가장 왼쪽 비트로 부호를 나타냄
  - 2의 보수: 더했을 때 0이 되도록 하는 수
    - 해당 수의 비트를 전부 바꾼 후 1을 더해 줌

- 실수의 표현: 부동소수점

  ![float](https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Float_point_example_frac.svg/900px-Float_point_example_frac.svg.png)

  - 실수를 **근사**하여 유효숫자를 나타내는 가수 + 소수점 위치를 나타내는 지수로 나누어 표기
    - 위 그림과 같은 32bit IEEE 754형식에서는 지수에 7bit, 가수에 23bit를 사용
    - 표현할 수를 2진법으로 변환하고 소수점을 왼쪽으로 이동시켜 1.xx 형태로 변환(정규화)
    - 소수점을 이동시킨 횟수가 지수, 소수점 이하가 가수
    - 지수에 bias인 127을 더해서 지수부 확정
  - 고정 소수점 방식보다 넓은 범위가 표현 가능하나 느림
  - **정확도 문제** 존재함



문자 자료형

- ASCII Code
  - 128개의 문자를 나타내는 방법
  - `char ch1 = 'A';` 와 같이 문자는 작은 따옴표로 감싸서 표현함
  - char 타입은 문자로도, 숫자로도 출력이 가능함
    - 컴파일러가 아스키 코드를 바탕으로 문자를 숫자로 바꿈
    - `char ch1 = 'A';`, `printf("%c %d", ch1, ch1);`을 수행하면 `A 65`가 출력됨
  - A는 65, a는 97이다



상수란?

- 변경이 불가능한 데이터
- 이름이 없는 상수: **literal**
  - 3, 4, 1.59 같이 이름이 없는 상수
  - 리터럴의 대입
    - 정수형 상수는 정수형 변수에 대입 가능함: `int num = 5;`
    - 문자형 상수 'A' 는 숫자 65로 표현되기 때문에 `sizeof('A')`를 실행하면 4가 됨
    - 접미사가 필요한 경우 있음
      - 정수형 상수는 기본적으로 int, 실수는 double형 데이터기 때문에 각각 char나 float에 대입하면 컴파일 시 경고메시지 발생
      - `float num = 5.789f;` 하는 식으로 해결 가능
- 이름이 있는 상수: **symbolic**
  - 변수 선언 시 const만 추가하면 되고, **선언과 동시에 초기화**해야 함: `const int MAX = 100;`
  - 선언과 동시에 초기화하지 않으면 쓰레기 값이 할당되는데, 상수는 변경 불가하기 떄문
  - 상수의 이름은 **모두 대문자**로 작성하는 것이 관례
    - 둘 이상의 단어를 연결할 때는 언더바 사용: MY_AGE



형 변환

- 데이터의 표현방식을 바꾸는 것으로, 자동 형 변환과 강제 형 변환이 있음

- 자동 형 변환

  - 대입연산에서의 자동 형 변환
    - 대입 시 두 피연산자의 형이 일치하지 않으면 왼쪽을 기준으로 형 변환
    - **저장소의 자료형에 맞춰서 형 변환**되는 것
    - `double num = 252;` int형 정수 245가 double이 됨
    - 데이터 표현범위가 좁은 자료형으로의 변환은 **데이터 손실이 발생할 수 있음**
  - Integral Promotion에서의 자동 형 변환
    - int보다 작은 정수형 데이터의 연산 시 발생
  - 피연산자의 자료형 불일치
    - 산술연산에서 피연산자 둘이 자료형이 다를 경우 **데이터 손실을 최소화**하는 쪽으로 형 변환
    - 정수 자료형보다 실수 자료형이 앞섬
    - int > long > long long > float > double > long double

- 강제 형 변환(명시적 형 변환)

  - **소괄호를 이용하여 자료형을 변환**해 줌

  - ```c
    int num1 = 3, num2 = 4;
    double result = num1 / num2;
    ```

  - 위 코드에서 num1 / num2 는 정수끼리의 연산이기 때문에, `(double)num1`을 해줘야 함

    - num1이 double로 형변환되므로 num1 / num2는 자동 형변환 됨



### 1.3. 제어문과 함수

> 프로그램을 순차적으로만 실행하는 것이 아니라 원하는 대로 흐름을 바꿈: "제어"



#### 1.3.1. 반복문

while 문

- 특정 조건을 주고 **조건을 만족하는 동안** 특정 영역을 계속해서 반복

  - ```c
    while(num<3)								// 반복 조건
        printf("Hello world! %d \n", num++);	// 반복 영역
    ```

  - 먼저 조건을 확인(비교연산 진행)하고 반복영역을 실행한 후 **다시 조건 심사**

  - 반복의 대상이 한 문장이라면 중괄호 생략 가능

  - 반복조건이 와야 할 위치에 참 값이 오면 무한루프가 됨: **break**로 탈출

- while문은 중첩 가능

  - ```c
    int main(void){
    	int cur = 2, is = 0;
        
        while(cur < 10){
            is = 1;
            while(is < 10){
                printf("%d * %d = %d", cur, is, cur*is);
                is++;
            }
            cur++;
        }
        return 0;
    }
    ```



do-while 문

- 반복조건을 **뒤에서 검사**한다는 점이 while문과의 차이점
  - 반복문을 반드시 **1번 이상 시행**함
  - 일반적으로는 while문을 사용하고, 1번 이상 꼭 실행될 필요가 있을 때 do-while문 사용



for 문

- 반복을 위한 변수선언, 조건검사, 종료조건 3가지를 한 문장에 묶어서 편하게 구성한 반복문
- 반복 횟수가 정해진 경우 for문이 편하고 아닌 경우 while문이 좋을 수 있음



반복문 생략 및 탈출

- break
  - 자신을 감싸는 **가장 가까운 위치의 반복문 하나**를 빠져나가는 데 사용됨
- continue
  - continue문 이후는 생략하고 반복문의 조건검사 위치로 돌아옴 



#### 1.3.2. 조건문

if문

- **조건에 따라서 실행을 하느냐 마느냐**를 가능하게 함
  - 
  - 조건이 만족될 때 실행할 문장이 하나라면 중괄호 생략 가능
  - if문은 몇 줄에 걸쳐서 표현되더라도 하나의 문장으로 인식됨
- else의 도입
  - if와 else가 만나서 이루는 문장은 하나임
  - else if는 if~else문을 중첩시킨 것
- 조건 연산자
  - `(num1 > num2) ? num1 : num2`
  - 삼항 연산자라고도 함
  - if ~ else문을 대체하는 용도로 많이 사용됨



switch

- 언제 사용하는가?
  - 조건 분기의 수가 많은 경우 switch의 사용이 권장됨
- switch와 break



#### 1.3.3. 함수

함수의 선언

- 함수 정의의 구조
  - 반환 형태, 함수 이름, 입력 형태, body
  - 함수는 전달인자의 유무, 반환 값의 유무에 따라 4가지 유형으로 분류 가능
  - 선언 시 **매개변수의 이름을 생략해서 선언**하는 것이 가능함
    - 그럼 body에서 매개변수를 어떻게 하지?
- 함수의 호출
  - 한번 정의된 함수는 몇 번이고 반복 호출 가능
  - 호출되기 전에 정의되어야 함
  - 함수가 호출되면 **호출된 함수의 영역으로 실행의 흐름이 이동**
  - main을 포함하여 모든 함수는 다른 함수를 호출할 수 있음



함수와 변수

- 지역변수
  - 중괄호 내에 선언되는 변수: **선언된 지역 내에서만 유효함**
  - 함수 내에서 선언된 지역변수는 함수가 호출될 때마다 메모리 공간에 새롭게 할당됨
    - Stack에 순차적으로 쌓임
    - 함수가 반환되면(종료) 자동으로 소멸됨: 지역변수를 automatic variable이라고도 함
  - 선언된 지역이 다르면 이름이 같아도 문제되지 않음
    - 지역변수는 외부에 선언된 동일한 이름의 변수를 **가림**
  - 매개변수는 지역변수의 일종임
- 전역변수
  - 중괄호 내에 선언되지 않음: 프로그램 전체 영역 어디서든 접근이 가능함
  - 프로그램 시작과 동시에 할당되어 종료시까지 존재하며 초기화하지 않으면 0으로 초기화 됨
  - 전역변수 선언은 **가급적 자제하는 것이 좋음**
    - 프로그램의 구조를 복잡하게 만듦: 전역변수의 변경은 다른 함수의 변경을 요구함
  - 지역변수는 동일한 이름의 전역변수를 **가림**
- static 변수
  - 지역변수에 static을 붙이면 전역변수의 성격을 지니는 지역변수가 됨
    - 1번만 초기화되고 **프로그램 종료 시까지 메모리 상에 존재**함(전역 변수 특징)
    - **선언된 함수 내에서만 접근 가능**(지역 변수 특징)
  - 전역변수의 단점(어디서나 접근, 변경)을 극복했기 때문에 가급적 전역변수는 static으로 대체
- register 변수
  - 변수를 레지스터에 저장(할 수도 있고 안 할 수도 있음)
    - 저장 여부는 컴파일러가 결정함
  - 전역변수에는 register를 붙일 수 없음: 하나의 변수가 레지스터에 계속 머무르는 것은 낭비



재귀함수

- 함수 내에서 자기 자신을 호출하는 함수
  - 완료되지 않은 함수를 다시 호출하는 것이 가능한가?
  - **함수의 복사본**을 불러와 실행하기 때문에 가능함



## **2. 포인터, 배열**





## **3. C언어 심화**