# Data Structure

자료구조 기초 이론 및 예제들



참고서적

- 윤성우의 열혈 자료구조
- 자료구조와 함께 배우는 알고리즘 입문 - Bohyoh Shibata
- 파이썬 알고리즘 인터뷰 - 박상길



[TOC]

## **1. 기본 자료구조**



## **2. 스택과 큐**



## **3. 집합**



## **4. 리스트**



## **5. Tree**

> 사이클을 갖지 않는 그래프
>
> "하나의 뿌리에서" 위로 뻗어 나가는 형상처럼 생겼기 때문에 트리라고 이름 붙여짐



트리의 성질

- 사이클이 없음
  - 트리는 부모가 자식을 가리키는 단방향 그래프로 사이클이 생길 수 없음
- 루트는 유일함
  - 부모 노드를 하나만 갖기 때문에 루트도 하나일 수밖에 없음
- 재귀적임: 트리의 자식은 트리임



트리 용어

- Node: 트리의 구성 요소
  - 부모 노드: 어떤 노드 바로 위(root 방향)에 연결된 노드
  - 자식 노드: 어떤 노드 바로 아래에 연결된 노드
  - 형제 노드: 같은 부모노드를 갖는 자식 노드들
- Degree: 자식 노드의 갯수
  - Size: 자신을 포함한 **모든 자손 노드**의 갯수
- Height: 현재 위치에서부터 리프 노드까지의 거리
  - Leaf: 자식 노드를 갖지 않는 노드
  - root: 부모 노드를 갖지 않는 노드
- Depth: 루트에서부터 현재 노드까지의 거리
  - Level: 루트에서부터 깊이 n만큼 떨어진 노드들을 level n 노드들이라고 함



트리 순회

- 트리 자료구조에서 각 노드를 정확히 한 번씩 방문하는 것
- 순회 방식
  - Pre-Order
  - In-Order
  - Post-Order



### 5.1. Binary Tree

> 모든 노드가 **최대 2개의 자식 노드**를 갖는 트리



이진 트리의 유형

- Full Binary Tree
  - 모든 노드가 0개 또는 2개의 자식 노드를 갖는다
- Complete Binary Tree
  - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있음
  - 마지막 레벨의 노드들은 왼쪽부터 채워짐
- Perfect Binary Tree(Fully Complete Binary Tree)
  - 모든 노드는 2개의 자식 노드를 가짐
  - 모든 리프 노드가 동일한 높이를 가짐



### 5.2. Binary Search Tree

> 정렬된 이진 트리
>
> 노드의 왼쪽 서브트리에는 노드보다 작거나 같은 값, 오른쪽 서브트리에는 크거나 같은 값



특징

- 중복을 허용하지 않음



BST의 필요성

- 이름부터가 그렇지만 이진 탐색을 위해 고안됨
  - 균형이 완벽히 잡힌 perfect binary tree의 경우 시간 복잡도 O(log n)
  - 단 트리의 균형이 깨지면 최악의 경우 O(n)까지도 증가할 수 있음
  - **자가 균형 이진 탐색 트리**(Self-Balancing BST)가 필요!
    - AVL 트리, 레드-블랙 트리 등
- inorder traversal 탐색을 통해 자료를 정렬하여 출력 가능



### 5.3. Heap

> **힙의 특성**을 만족하는 거의 완전한 트리(Almost Complete Tree)
>
> 힙의 특성: 부모가 항상 자식보다 같거나 작음(최소힙) or 부모가 항상 자식보다 크거나 같음(최대힙)



힙의 구현



이진 힙 vs 이진 탐색 트리

- 힙은 상하관계를 보장함
  - 부모는 자식보다 작고 왼쪽 오른쪽은 상관 없음
- BST는 좌우 관계를 보장함
  - 부모는 왼쪽 자식보다는 크고 오른쪽 자식보다는 작다



문제풀이에서의 힙

- 정렬되지 않은 배열에서 k번째로 큰 값을 추출하는 경우 [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/)
  - 추가, 삭제가 빈번할 때는 힙을 사용하는 것이 좋음
  - 값이 고정된 경우에는 그냥 정렬해서 k번째를 추출



### 5.4. Trie

> 문자열 탐색을 위한 자료구조로 m-ary Tree의 형태를 띔

![Trie](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1200px-Trie_example.svg.png)





## **6. 해시**

> Key를 Value에 매핑할 수 있는 구조



해시 함수란?

- Key를 고정 크기 값으로 변환해주는 함수
  - 해시 테이블 또는 해시 맵을 인덱싱하기 위해 사용됨
- 해시 함수를 사용하여 인덱싱을 하는 것을 **해싱**이라 함
- 해시 함수의 성능은 다음과 같이 측정됨
  - 함수 값의 충돌이 최소화되는지?
  - 연산이 빠른지?
    - 충돌의 최소화와 빠른 연산은 trade-off 관계를 가짐
  - 해시 값이 균일하게 분포되는지?
  - 사용할 키의 *모든 정보*를 이용하여 해싱하는지?



해시 함수의 충돌

- 컨테이너의 수보다 아이템이 많은 경우, 비둘기집의 원리에 의해 충돌은 반드시 발생함
- 확률적으로 컨테이너의 수보다 아이템이 훨씬 적어도 충돌은 발생함
  - **Birthday Problem**: 23명만 모여도 생일이 같은 사람이 존재할 확률 50%, 57명인 경우엔 99% 이상
- 충돌을 막기 위해서 **로드 팩터**를 모니터링 함
  - load factor = n/k (테이블에 저장된 갯수 / 버킷의 갯수)
  - 로드 팩터 값에 따라 함수를 재작성하거나 테이블의 크기를 조정함
  - 자바10의 경우 로드 팩터가 0.75를 넘어가면 테이블의 공간을 재할당 함
- 충돌이 발생하는 경우 다음 방법을 이용하여 해결
  - **개별 체이닝**
  - **오픈 어드레싱**



해싱 알고리즘

- Modulo-Division Method

  - `h(x) = x mod m`

  - x는 입력값을 연산하여 랜덤하게 만든 키 값, m은 해시 테이블의 크기

  - 입력값은 다음과 같은 방식으로 랜덤하게 만들어 줌

  - ```C
    unsigned hash(char* s){
        unsigned hashval;
        
        for (hashval = 0; *s != '\0'; s++)
            hashval = *s + 31 * hashval;
        return hashval % HASHSIZE;
    }
    ```

    - 문자열의 각 자릿수를 계수로 갖는 31의 power series로 x를 표현하여 랜덤하게 만들었음



개별 체이닝

- 충돌 발생 시 같은 해시 값의 데이터들을 **연결 리스트로 연결**
- 시간 복잡도
  - 잘 구현되면 O(1), 최악의 경우 O(n): 모든 해시 충돌이 발생할 경우
- **해시 테이블** 구조의 원형임



오픈 어드레싱

- 충돌 발생 시 빈 공간을 탐색하여 저장함
- 장점
  - 구현이 간단하고 성능이 괜찮음
- 단점
  - **클러스터링** 발생: 선형 탐색의 경우 충돌한 곳 바로 다음에 저장되기 때문
  - 버킷 사이즈보다 데이터가 많이 들어오면 삽입 불가
    - 로드 팩터를 넘으면 **Growth Factor** 비율에 따라 더 큰 크기의 버킷을 생성하여 리해싱 실시
- 체이닝과 비교
  - 낮은 로드팩터에서는 성능이 좋으나 높은 로드팩터에서 급격한 성능저하 발생
  - Ruby 등은 해시 테이블을 오픈 어드레싱 방식을 택하되 로드 팩터를 적게 잡아 이를 해결함





### 6.1. Hash Table

> 파이썬의 딕셔너리는 오픈 어드레싱 방식의 해시 테이블로 구현됨



기본 원리: 개별 체이닝과 같음

1. 키의 해시 값을 계산함
2. 해시 값을 이용해 배열의 인덱스를 구함
3. 같은 인덱스가 있다면 연결 리스트로 연결



### 6.2. Hash Set



### 6.3. Hash Map