# Data Structure

자료구조 기초 이론 및 예제들



참고서적

- 윤성우의 열혈 자료구조
- 자료구조와 함께 배우는 알고리즘 입문 - Bohyoh Shibata
- 파이썬 알고리즘 인터뷰 - 박상길



[TOC]

## **1. 기본 자료구조**



## **2. 스택과 큐**



## **3. 집합**



## **4. 리스트**



## **5. 트리**



## **6. 해시**

> Key를 Value에 매핑할 수 있는 구조



해시 함수란?

- Key를 고정 크기 값으로 변환해주는 함수
  - 해시 테이블 또는 해시 맵을 인덱싱하기 위해 사용됨
- 해시 함수를 사용하여 인덱싱을 하는 것을 **해싱**이라 함
- 해시 함수의 성능은 다음과 같이 측정됨
  - 함수 값의 충돌이 최소화되는지?
  - 연산이 빠른지?
    - 충돌의 최소화와 빠른 연산은 trade-off 관계를 가짐
  - 해시 값이 균일하게 분포되는지?
  - 사용할 키의 *모든 정보*를 이용하여 해싱하는지?



해시 함수의 충돌

- 컨테이너의 수보다 아이템이 많은 경우, 비둘기집의 원리에 의해 충돌은 반드시 발생함
- 확률적으로 컨테이너의 수보다 아이템이 훨씬 적어도 충돌은 발생함
  - **Birthday Problem**: 23명만 모여도 생일이 같은 사람이 존재할 확률 50%, 57명인 경우엔 99% 이상
- 충돌을 막기 위해서 **로드 팩터**를 모니터링 함
  - load factor = n/k (테이블에 저장된 갯수 / 버킷의 갯수)
  - 로드 팩터 값에 따라 함수를 재작성하거나 테이블의 크기를 조정함
  - 자바10의 경우 로드 팩터가 0.75를 넘어가면 테이블의 공간을 재할당 함
- 충돌이 발생하는 경우 다음 방법을 이용하여 해결
  - **개별 체이닝**
  - **오픈 어드레싱**



해싱 알고리즘

- Modulo-Division Method

  - `h(x) = x mod m`

  - x는 입력값을 연산하여 랜덤하게 만든 키 값, m은 해시 테이블의 크기

  - 입력값은 다음과 같은 방식으로 랜덤하게 만들어 줌

  - ```C
    unsigned hash(char* s){
        unsigned hashval;
        
        for (hashval = 0; *s != '\0'; s++)
            hashval = *s + 31 * hashval;
        return hashval % HASHSIZE;
    }
    ```

    - 문자열의 각 자릿수를 계수로 갖는 31의 power series로 x를 표현하여 랜덤하게 만들었음



개별 체이닝

- 충돌 발생 시 같은 해시 값의 데이터들을 **연결 리스트로 연결**
- 시간 복잡도
  - 잘 구현되면 O(1), 최악의 경우 O(n): 모든 해시 충돌이 발생할 경우
- **해시 테이블** 구조의 원형임



오픈 어드레싱

- 충돌 발생 시 빈 공간을 탐색하여 저장함
- 장점
  - 구현이 간단하고 성능이 괜찮음
- 단점
  - **클러스터링** 발생: 선형 탐색의 경우 충돌한 곳 바로 다음에 저장되기 때문
  - 버킷 사이즈보다 데이터가 많이 들어오면 삽입 불가
    - 로드 팩터를 넘으면 **Growth Factor** 비율에 따라 더 큰 크기의 버킷을 생성하여 리해싱 실시
- 체이닝과 비교
  - 낮은 로드팩터에서는 성능이 좋으나 높은 로드팩터에서 급격한 성능저하 발생
  - Ruby 등은 해시 테이블을 오픈 어드레싱 방식을 택하되 로드 팩터를 적게 잡아 이를 해결함





### 6.1. Hash Table

> 파이썬의 딕셔너리는 오픈 어드레싱 방식의 해시 테이블로 구현됨



기본 원리: 개별 체이닝과 같음

1. 키의 해시 값을 계산함
2. 해시 값을 이용해 배열의 인덱스를 구함
3. 같은 인덱스가 있다면 연결 리스트로 연결



### 6.2. Hash Set



### 6.3. Hash Map