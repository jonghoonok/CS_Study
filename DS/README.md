# Data Structure

>  데이터 단위와 데이터 자체 사이의 물리적 또는 논리적 관계



참고서적

- 윤성우의 열혈 자료구조
- 자료구조와 함께 배우는 알고리즘 입문 - Bohyoh Shibata
- 파이썬 알고리즘 인터뷰 - 박상길



[TOC]



## **1. 기본 자료구조**



### 1.1. 배열



배열이란?

- **같은 자료형**의 변수로 이루어진 요소가 모여 **직선 모양으로** 줄지어 있는 자료구조

  - ```c
    int arr[number of element];
    ```

  - 이 때 **요소의 갯수는 상수**만 사용 가능

    - 변수를 사용하면 런타임에 크기가 변화될 수 있음
    - **배열은 크기가 변하지 않는 자료구조**로 컴파일 타임에 크기가 결정됨

- 배열의 개별 요소에는 **인덱스**를 이용하여 접근



배열의 필요성

- 빠른 검색



### 1.2. 구조체



구조체란?

- 임의의 데이터를 다시 조합하여 만드는 자료구조

  - 클래스와 같은 개념
  - 임의의 데이터 타입들을 멤버로 가지는 데이터의 묶음
    - 어떤 객체가 갖는 데이터들을 각각 배열로는 관리하기 어렵기 때문에 묶어서 관리하는 것

- 구조체의 선언

  - ```c
    struct person{
        int		height;
        long	personID;
        double	vision;
    };
    ```

  - 중괄호 안의 멤버들을 모아 `struct person` 타입의 구조체를 새롭게 정의한 것 



구조체의 사용

- 멤버 접근

  - `objectName.meberName` : 객체 이름을 이용하여 멤버에 접근
  - `pointerName -> memberName` : 객체를 가리키는 포인터 이름을 이용하여 멤버에 접근

- typedef

  - 구조체의 이름 앞에는 반드시 struct가 따라와야 함: 번거로우니 typedef를 이용하여 동의어 선언

  - ```c
    struct person{
        ...
    }typedef P
    ```

  - 이걸로 `struct person` 을 `P`로 대체 가능



## **2. 스택과 큐**



### 2.1. 스택



스택이란?

- 데이터를 일시적으로 저장하기 위한 자료구조로, **후입선출**이라는 특징을 가짐
- 프로그램에서 함수를 호출하고 실행할 때 내부적으로 스택이 사용됨
- 보통 배열 또는 링크드리스트로 구현됨
- 데이터를 넣는 작업을 **push**, 꺼내는 작업을 **pop**이라 함
  - push, pop은 스택의 top에서 수행됨
  - 스택의 가장 밑바닥을 bottom이라 하고, 스택을 배열로 구현하면 `stk[0]`이 bottom이 됨
  - **스택 포인터** ptr을 움직이며 pop과 push를 수행
    - ptr은 포인터 변수가 아니라 스택의 인덱스로, 스택에 저장된 원소의 갯수를 나타냄
    - top은 `stk[ptr-1]`임



스택 구현하기

- 초기화
  - 스택의 메모리 공간을 할당
  - 스택 구조체의 멤버인 최대 크기(max), 스택 포인터, 스택을 가리키는 포인터를 초기화
- Push
  - 스택이 가득 찼는지 확인(ptr의 값이 max 이상인지 체크)
  - 가득 차지 않았다면 데이터를 stk[ptr]에 저장하고 ptr을 증가시킴
- Pop
  - 스택이 비었는지 확인(ptr의 값이 0 이하인지 체크)
  - 비지 않았다면 stk[ptr-1]의 데이터를 리턴하고 ptr을 감소시킴
- Peek
  - 스택이 비었는지 확인하고 비지 않았다면 top의 데이터를 리턴
- Clear
  - ptr을 bottom으로 되돌림(`s -> ptr = 0;`)
  - 배열 요소는 변경할 필요 없음: **모든 데이터 출입은 top에서 이루어지므로** ptr만 변경하면 됨
- Capacity
  - 스택의 용량을 반환(`return s -> max;`)
- Size
  - 현재 스택에 쌓여 있는 데이터의 갯수를 반환(`return s -> ptr`;)
- Search
  - 스택의 top에서부터 인덱스를 감소시키며 원하는 데이터가 있는지 선형적으로 탐색
- Print
  - 스택의 top에서부터 인덱스를 감소시키며 모든 데이터를 출력
- Terminate
  - 스택에 할당된 메모리를 해제하고(`free()`) 멤버의 값을 0으로 초기화



### 2.2. 큐



큐란?

- 데이터를 일시적으로 저장하기 위한 자료구조로, **선입선출**이라는 특징을 가짐
- Process Ready Queue 등 이름 그대로 대기열에 사용됨
- 보통 배열이나 링크드리스트로 구현됨
- 데이터를 넣는 작업을 **enqueue**, 꺼내는 작업을 **dequeue**라고 함
  - 데이터를 꺼내는 쪽을 front, 넣는 쪽을 rear라고 함



원형 큐의 필요성

- 스택과 달리 **큐에서 데이터를 꺼내는 작업은 O(n)**으로 개선이 필요함
  - 맨 앞의 데이터를 꺼내고 나면 2번째 이후의 데이터를 한 칸씩 밀어줘야 함
- 데이터를 꺼내도 앞쪽으로 밀어주지 않기 위해 **링 버퍼** 사용
  - **front, rear**를 도입하여 논리적으로 첫 번째, 마지막 요소를 식별하고 이 변수들만 변경해줌
  - 링 버퍼는 **오래된 데이터를 버리는 데 사용**될 수 있음: 가장 최근에 들어온 데이터 n개만 저장함



큐 구현하기

- 초기화
  - 큐의 메모리 공간을 할당
  - 큐 구조체의 멤버인 최대 크기(max), 데이터의 수(num), front, rear, 큐를 가리키는 포인터를 초기화
    - front == rear일 때 큐가 가득 찼는지 판단하기 위해 num이 필요
- Enqueue
  - 큐가 가득 찼는지 확인(num의 값이 max 이상인지 체크)
  - 가득 차지 않았다면 데이터를 queue[rear]에 저장하고 rear을 증가시킴
    - rear이 배열의 크기를 넘어갈 수 있음
      1. 나머지 연산을 하거나 
      2. `rear == max`인 경우에 0으로 만들어줌
- Dequeue
  - 큐가 비었는지 확인(num의 값이 0 이하인지 체크)
  - 비지 않았다면 queue[front]의 데이터를 리턴하고 front를 감소시킴
    - 마찬가지로 front가 0보다 작아지는 경우에 대해 처리해줌
- Peek
  - 큐가 비었는지 확인하고 비지 않았다면 front의 데이터를 리턴
- Clear
  - num, front, rear를 모두 0으로 만들어줌
  - 스택과 마찬가지로 배열 요소의 변경은 불필요
- Capacity
  - 큐의 용량을 반환(`return q -> max;`)
- Size
  - 현재 큐에 쌓여 있는 데이터의 갯수를 반환(`return q -> num`;)
- Search
  - 큐의 front에서부터 인덱스를 증가시키며 원하는 데이터가 있는지 선형적으로 탐색
  - front에서부터 출발하기 위해 나머지 연산을 사용: `(i + q -> front) % q -> max`
- Print
  - 큐의 front에서부터 인덱스를 증가시키며 모든 데이터를 출력
- Terminate
  - 큐에 할당된 메모리를 해제하고(`free()`) 멤버의 값을 0으로 초기화



## **3. 집합**



## **4. 리스트**



## **5. Tree**

> 사이클을 갖지 않는 그래프
>
> "하나의 뿌리에서" 위로 뻗어 나가는 형상처럼 생겼기 때문에 트리라고 이름 붙여짐



트리의 성질

- 사이클이 없음
  - 트리는 부모가 자식을 가리키는 단방향 그래프로 사이클이 생길 수 없음
- 루트는 유일함
  - 부모 노드를 하나만 갖기 때문에 루트도 하나일 수밖에 없음
- 재귀적임: 트리의 자식은 트리임



트리 용어

- Node: 트리의 구성 요소
  - 부모 노드: 어떤 노드 바로 위(root 방향)에 연결된 노드
  - 자식 노드: 어떤 노드 바로 아래에 연결된 노드
  - 형제 노드: 같은 부모노드를 갖는 자식 노드들
- Degree: 자식 노드의 갯수
  - Size: 자신을 포함한 **모든 자손 노드**의 갯수
- Height: 현재 위치에서부터 리프 노드까지의 거리
  - Leaf: 자식 노드를 갖지 않는 노드
  - root: 부모 노드를 갖지 않는 노드
- Depth: 루트에서부터 현재 노드까지의 거리
  - Level: 루트에서부터 깊이 n만큼 떨어진 노드들을 level n 노드들이라고 함



트리 순회

- 트리 자료구조에서 각 노드를 정확히 한 번씩 방문하는 것
- 순회 방식
  - Pre-Order
  - In-Order
  - Post-Order



### 5.1. Binary Tree

> 모든 노드가 **최대 2개의 자식 노드**를 갖는 트리



이진 트리의 유형

- Full Binary Tree
  - 모든 노드가 0개 또는 2개의 자식 노드를 갖는다
- Complete Binary Tree
  - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있음
  - 마지막 레벨의 노드들은 왼쪽부터 채워짐
- Perfect Binary Tree(Fully Complete Binary Tree)
  - 모든 노드는 2개의 자식 노드를 가짐
  - 모든 리프 노드가 동일한 높이를 가짐



### 5.2. Binary Search Tree

> 정렬된 이진 트리
>
> 노드의 왼쪽 서브트리에는 노드보다 작거나 같은 값, 오른쪽 서브트리에는 크거나 같은 값



특징

- 중복을 허용하지 않음



BST의 필요성

- 이름부터가 그렇지만 이진 탐색을 위해 고안됨
  - 균형이 완벽히 잡힌 perfect binary tree의 경우 시간 복잡도 O(log n)
  - 단 트리의 균형이 깨지면 최악의 경우 O(n)까지도 증가할 수 있음
  - **자가 균형 이진 탐색 트리**(Self-Balancing BST)가 필요!
    - AVL 트리, 레드-블랙 트리 등
- inorder traversal 탐색을 통해 자료를 정렬하여 출력 가능



### 5.3. Heap

> **힙의 특성**을 만족하는 거의 완전한 트리(Almost Complete Tree)
>
> 힙의 특성: 부모가 항상 자식보다 같거나 작음(최소힙) or 부모가 항상 자식보다 크거나 같음(최대힙)



힙의 구현



이진 힙 vs 이진 탐색 트리

- 힙은 상하관계를 보장함
  - 부모는 자식보다 작고 왼쪽 오른쪽은 상관 없음
- BST는 좌우 관계를 보장함
  - 부모는 왼쪽 자식보다는 크고 오른쪽 자식보다는 작다



문제풀이에서의 힙

- 정렬되지 않은 배열에서 k번째로 큰 값을 추출하는 경우 [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/)
  - 추가, 삭제가 빈번할 때는 힙을 사용하는 것이 좋음
  - 값이 고정된 경우에는 그냥 정렬해서 k번째를 추출



### 5.4. Trie

> 문자열 탐색을 위한 자료구조로 m-ary Tree의 형태를 띔

![Trie](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/1200px-Trie_example.svg.png)





## **6. 해시**

> Key를 Value에 매핑할 수 있는 구조



해시 함수란?

- Key를 고정 크기 값으로 변환해주는 함수
  - 해시 테이블 또는 해시 맵을 인덱싱하기 위해 사용됨
- 해시 함수를 사용하여 인덱싱을 하는 것을 **해싱**이라 함
- 해시 함수의 성능은 다음과 같이 측정됨
  - 함수 값의 충돌이 최소화되는지?
  - 연산이 빠른지?
    - 충돌의 최소화와 빠른 연산은 trade-off 관계를 가짐
  - 해시 값이 균일하게 분포되는지?
  - 사용할 키의 *모든 정보*를 이용하여 해싱하는지?



해시 함수의 충돌

- 컨테이너의 수보다 아이템이 많은 경우, 비둘기집의 원리에 의해 충돌은 반드시 발생함
- 확률적으로 컨테이너의 수보다 아이템이 훨씬 적어도 충돌은 발생함
  - **Birthday Problem**: 23명만 모여도 생일이 같은 사람이 존재할 확률 50%, 57명인 경우엔 99% 이상
- 충돌을 막기 위해서 **로드 팩터**를 모니터링 함
  - load factor = n/k (테이블에 저장된 갯수 / 버킷의 갯수)
  - 로드 팩터 값에 따라 함수를 재작성하거나 테이블의 크기를 조정함
  - 자바10의 경우 로드 팩터가 0.75를 넘어가면 테이블의 공간을 재할당 함
- 충돌이 발생하는 경우 다음 방법을 이용하여 해결
  - **개별 체이닝**
  - **오픈 어드레싱**



해싱 알고리즘

- Modulo-Division Method

  - `h(x) = x mod m`

  - x는 입력값을 연산하여 랜덤하게 만든 키 값, m은 해시 테이블의 크기

  - 입력값은 다음과 같은 방식으로 랜덤하게 만들어 줌

  - ```C
    unsigned hash(char* s){
        unsigned hashval;
        
        for (hashval = 0; *s != '\0'; s++)
            hashval = *s + 31 * hashval;
        return hashval % HASHSIZE;
    }
    ```

    - 문자열의 각 자릿수를 계수로 갖는 31의 power series로 x를 표현하여 랜덤하게 만들었음



개별 체이닝

- 충돌 발생 시 같은 해시 값의 데이터들을 **연결 리스트로 연결**
- 시간 복잡도
  - 잘 구현되면 O(1), 최악의 경우 O(n): 모든 해시 충돌이 발생할 경우
- **해시 테이블** 구조의 원형임



오픈 어드레싱

- 충돌 발생 시 빈 공간을 탐색하여 저장함
- 장점
  - 구현이 간단하고 성능이 괜찮음
- 단점
  - **클러스터링** 발생: 선형 탐색의 경우 충돌한 곳 바로 다음에 저장되기 때문
  - 버킷 사이즈보다 데이터가 많이 들어오면 삽입 불가
    - 로드 팩터를 넘으면 **Growth Factor** 비율에 따라 더 큰 크기의 버킷을 생성하여 리해싱 실시
- 체이닝과 비교
  - 낮은 로드팩터에서는 성능이 좋으나 높은 로드팩터에서 급격한 성능저하 발생
  - Ruby 등은 해시 테이블을 오픈 어드레싱 방식을 택하되 로드 팩터를 적게 잡아 이를 해결함





### 6.1. Hash Table

> 파이썬의 딕셔너리는 오픈 어드레싱 방식의 해시 테이블로 구현됨



기본 원리: 개별 체이닝과 같음

1. 키의 해시 값을 계산함
2. 해시 값을 이용해 배열의 인덱스를 구함
3. 같은 인덱스가 있다면 연결 리스트로 연결



### 6.2. Hash Set



### 6.3. Hash Map