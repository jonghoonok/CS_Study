# 개발 일반 지식



[TOC]

## 1. 아키텍처



#### Monolithic, SOA, MSA

![비교](https://post-phinf.pstatic.net/MjAyMDAzMTNfMjEx/MDAxNTg0MDg2MDM1MDIy.D5J8C3qndcanj1dgKtrlw0M1P2jxesdfr27bIcr_T2Mg.6vSP0oIToodtanRm0vYD2Sknztqv_QU2AyygpcFVQzIg.JPEG/msa_img02_post.jpg?type=w1200)



모놀리식 아키텍처

![monolithic](https://gblobscdn.gitbook.com/assets%2F-Lej4tgjCgS0Wyj6JGe2%2F-Lf3aFiJ5iI8PxEdUh03%2F-Lf3aShjT-V66QCuldqr%2Fmsa1.PNG?alt=media)

- 하나의 어플리케이션 내에 모든 로직이 들어가 있음
  - 위 예시에서는 톰캣 서버에서 작동하는 파일 하나에 모든 컴포넌트가 들어있음
- 전통적인 웹 시스템 개발 스타일임
- 문제점
  - 규모가 큰 애플리케이션에서는 빌드 및 배포 시간, 서버의 기동 시간이 **오래걸림**
  - **협업이 어려움** :  한 두 사람의 실수는 전체 시스템의 빌드 실패를 유발
  - 특정 컴포넌트나 모듈에서의 성능 문제나 장애가 다른 컴포넌트에까지 영향을 줌
    - 시스템 컴포넌트들이 서로 로컬 콜(Call-by-Reference) 기반으로 타이트하게 연결되어 있기 때문
  - 업데이트와 재배포에 불리함
    - 특정 컴포넌트를 수정 시 전체 애플리케이션을 재컴파일해서 전체를 재배포해야 함 
    - 컴포넌트별로 기능 / 비기능적 특성에 맞춰서 다른 기술을 도입하고자 할때 유연하지 않음



서비스지향 아키텍처(SOA)

- 그림이랑 정의, 특징 채울 것
- ESB를 사용함
  - SOA가 애초에 엔터프라이즈 시스템을 중심으로 고안된 아키텍처임
  - 분산처리 환경에서 발생하는 문제를 어플리케이션 외부에서 해결하기 위함
- 결국 망했음
  - 조직 구조가 SOA를 제대로 적용할 수 있도록 변화하지 못함
  - ESB 중앙집중형 구조에 따른 기능의 비대화를 해결하지 못함



마이크로서비스 아키텍처(MSA)

- SOA를 대용량 웹 서비스 개발에 맞게 경량화하고, 대규모 개발팀의 조직 구조에 맞도록 변형한 것

  - 서비스를 더욱 잘게 나눔: 서비스 별로 DB를 갖고, 배포도 로드밸런서에 의해 독립적으로 수행됨
  - 어플리케이션을 보다 빨리 개발하고 성능을 지속적으로 높일 수 있음

- API Gateway와 서비스 메쉬를 이용함

  - MSA는 하나의 ESB를 다수의 마이크로서비스 컴포넌트로 나누어 서비스 간 통신을 처리함
  - 수많은 서비스 간 통신 기능을 구현하는 것은 대단히 복잡함
  - 따라서 서비스간 직접 통신을 하지 않고, API Gateway와 **서비스 메쉬**를 이용해 통신함
    - ![API Gateway](https://gblobscdn.gitbook.com/assets%2F-Lej4tgjCgS0Wyj6JGe2%2F-Lf3aFiJ5iI8PxEdUh03%2F-Lf3aSiSQZAMVnFrSo4n%2Fmsa7.PNG?alt=media)
    - API Gateway가 인증, 로깅 등 공통 기능을 처리해 API가 비즈니스로직에만 집중할 수 있게함

  - 서비스 메쉬는 **사이드카 패턴**
    - ????

- 문제점

  - API 통신을 위해 데이터 변환을 하는 데서 오버헤드 발생
  - 메모리 사용량 증가: 각 서비스를 독립된 서버에 배치하기 때문에 중복되는 모듈이 발생
  - 트랜잭션 처리
    - 이건 거의 해결이 불가능함: 에러 처리 로직을 구현해서 어떻게 할 수는 있긴함
    - 금융/제조 기업 등 **트랜잭션 처리가 중요한 시스템에는 부적합**



변화가 일어나는 이유?

- 데이터를 바라보는 시각의 변화
  - 비정형화된 데이터의 비중이 갈수록 늘어남
    - RDBMS로는 부족하여 NoSQL이 도입된 바 있음
  - 각 서비스별로 정말 필요한 비즈니스 로직만 남겨야 함
  - SOA에서는 공통 또는 특정 결과를 처리하기 위해 단일 서비스화를 했으나 그걸 쪼개서 중복되어 재사용할 수 있게 서비스를 하나의 도메인 기준으로 나눔



사이드카 패턴

- 모든 응용 프로그램 컨테이너에 사이드카 컨테이너를 추가하여 배포함
- 사이드카는 서비스에 들어오고 나가는 모든 네트워크 트래픽을 처리함
  - 서비스가 타 서비스를 직접 호출하지 않고 proxy를 통해 호출함
  - 이를 통해 별도 작업 없이 서비스 연결, 로깅, 모니터링, 보안, 트래픽 제어가 가능함
  - 왜?????



쿠버네티스

- 오픈소스 **컨테이너** 오케스트레이션 플랫폼
- 마이크로서비스 어플리케이션 실행에 최적화되어 있음
  - 왜???



데브옵스

- 뭔데???



## 2. Softbank OJT

> 소프트뱅크 신입사원 OJT에서 배운 개발 일반 지식



### 과제 소개

Web Server: Nginx

WAS: Wildfly







Nginx

문제점: 서버 실행이 안 됐다

원인: 80포트가 사용중이어서 실행되지 않았음(실행 후 제대로 종료되지 않아서 캐시를 잡아먹고 있었던 것으로 추정)

해결: `nginx.conf` 파일에서 server를 81로 바꿔서 실행함

보충

- `nginx.conf`에서 많은 일을 할 수 있는데, 포트 번호를 바꾸거나 root를 수정하여 서버가 실행될 때 어디에 있는 html파일을 열지 설정할 수 있음
- 프롬프트에서 `netstat -a` 명령어를 통해 현재 사용되고 있는 포트번호를 확인 가능