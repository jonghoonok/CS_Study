# System Programming

시스템 프로그래밍



참고서적 및 수업

- 패스트캠퍼스 컴퓨터공학 올인원 패키지 : 시스템 프로그래밍
- 



[TOC]

## **1. 시스템 프로그래밍이란?**



무엇을 공부하는가?

- 운영체제 기초 이론에 기반한 실습
  - 운영체제를 제어하는 명령어들을 통해서 알아봄
- 리눅스의 활용
  - 인터넷 서비스의 서버 환경 익히기
  - 고급 운영체제 기능의 직접적인 제어
  - UNIX 계열 OS 사용법 익히기



### 1.1. 리눅스란?



리눅스의 특징

- 서버에 많이 사용되는 운영체제
  - 최근 서버 환경은 대부분 리눅스 기반
  - AWS의 서버를 세팅할 때 고를 수 있는 운영체제는 대부분 리눅스
- 프로그래밍에도 많이 사용됨
  - 빠른 테스트를 위해 **clean한 리눅스 환경**에서 컴파일하는 경우
    - plain한 프로그래밍이 가능
    - clean한 리눅스 환경 : kernel + shell + system 기본 프로그램
- UNIX 계열 운영체제임
  - 리눅스의 사용법을 익히면 UNIX의 사용법 또한 익힐 수 있음
  - 다중 사용자, 다중 작업이 가능
- 오픈 소스임



리눅스의 역사

- 대학의 UNIX 컴퓨터를 집에서 쓰기 위해 리누스 토발즈가 커널을 개발
- GNU(GNU is Not UNIX) 프로젝트
  - 여러 회사에서 UNIX가 각자 개발되어 소스가 공유되지 않던 문화에 반발하여 시작
  - 리차드 스톨만이 1985년에 GNU 선언문을 발표
  - 자유 소프트웨어 재단(FSF)설립, GNU **공개 라이센스**(GPL) 규약 제공
    - 소스의 무료 공개 + 변경 후 배포 시 소스 오픈 강제
  - OS 개발 프로젝트
    - 시스템 콜, 컴파일러, API, 라이브러리, 쉘을 개발
    - GNU Hurd : 커널 개발이 지연됨
- GNU 프로젝트와 리눅스의 만남
  - 리차드 스톨만이 리누스 토발즈에게 커널이 GPL을 따르게 하지 않겠냐고 제안
  - 두 프로젝트가 합쳐지며 오픈 소스 OS인 리눅스가 완성



### 1.2. 우분투 리눅스 사용



리눅스 배포판이란?

- 리눅스 커널 및 다양한 소프트웨어 패키지(API, 컴파일러, 쉘 등)를 묶어서 배포하는 것
  - Red Hat Linux, Fedora, **ubuntu** 등
  - 이 문서에서는 ubuntu 기준으로 설명



리눅스 서버 생성 및 접속

- AWS에서 EC2 또는 인스턴스(서버) 생성
  - ubuntu로 생성
- **Elastic IP** 생성 및 접속
  - 동적으로 생성되는 IP(비용 발생)
  - 서버에는 고정 IP를 설정해야 함
- 자신의 PC(클라이언트)에서 EC2(서버) 접속
  - Mac 기준 : Shell을 이용
  - 윈도우 기준
    - 인스턴스 생성 시 다운로드 받은 `.pem`파일을 `.ppk`로 변환해야 함
    - putty 다운로드
    - putty gen 실행하여 변환
    - putty 실행하여 `ubuntu@IPaddress` 입력
    - Auth에서 `.ppk`파일을 로딩



VMWare

- 클라이언트에서 우분투 리눅스를 사용하기 위해 VMWare를 설치
- ubuntu server를 다운로드받아 VMWare에서 iso파일을 이용해 설치



## **2. 시스템 프로그래밍 기본**



### 2.1. UNIX/Linux의 기본 구성 



리눅스와 파일

- **모든 것은 파일**이라는 철학을 따름
  - 모든 interaction은 파일을 읽고 쓰듯이 이루어 짐
  - 마우스, 키보드 등 모든 디바이스 관련 기술도 파일처럼 취급됨
- 파일 네임스페이스
  - 전역 **네임스페이스**를 제공함
    - 리눅스는 모든 파일이 root directory에 속함(`/media/floofy/jonghoon.jpg`)
    - 윈도우의 경우 A 드라이브, C 드라이브 등이 나뉘어 있음
- 파일은 inode 고유값과 자료구조에 의해 관리됨



리눅스와 프로세스

- 프로세스의 구조
  - 리눅스 실행 파일 포맷 ELF(Executable and Linkable Format)
  - 콜스택, 코드(텍스트), 데이터 및 BSS 섹션 등
- 다양한 시스템 리소스와 관련됨
  - 프로세스 내에서 **시스템 콜 호출을 통해 리소스를 처리**할 수 있도록 구성됨
  - 타이머, 시그널, 파일, 네트워크, 디바이스, IPC 등
- 가상 메모리 지원
- 각 프로세스는 pid(프로세스 ID) 고유값으로 구분됨
- 신규 프로세스의 생성
  - init 프로세스(첫 번째 프로세스)를 기반으로 `fork()` 시스템콜을 사용해 생성



리눅스와 권한

- 리눅스는 사용자/그룹으로 권한을 관리함
  - 운영체제는 사용자/리소스 권한을 관리함
  - 로그인 사용자, 사용자를 grouping한 그룹으로 관리할 수 있음
  - root는 슈퍼 관리자
- **파일마다** 권한을 관리함
  - 소유자, 소유자 그룹, 모든 사용자에 대해 실행, 읽기, 쓰기 권한 관리
  - 접근 권한 정보는 inode 자료구조에 저장됨



### 2.2. 쉘 사용법



Shell이란?

- 사용자와-하드웨어 or 사용자-운영체제 간 인터페이스
  - 사용자의 명령을 해석해서 커널에 명령을 요청
  - 관련된 시스템 콜을 사용하도록 프로그래밍 되어 있음



쉘의 종류

- Korn Shell(ksh)
  - 유닉스에서 가장 많이 사용됨
- **Bourne-Again Shell**(bash)
  - GNU 프로젝트의 일환으로 개발된 리눅스 용 쉘
  - 콘 쉘을 기반으로 개발됨
- C Shell(csh)
- Bourne Shell(sh)



#### Bash의 기본 명령어



Help

- 명령어 앞에 `man`을 치면 해당 명령어의 옵션들을 보여줌
  - 예) `man ls` 하면 ls 뒤에 올 수 있는 옵션들을 출력
  - manual이라는 뜻



다중 사용자 관련

- `whoami`
  - 로그인한 사용자 ID를 알려줌
- `passwd`
  - 로그인한 사용자 ID의 암호를 변경
- 신규 유저 추가
  - 신규 유저/그룹는 **root**만(super user) 추가할 수 있음
    - root로 로그인하거나
    - `sudo` 명령어를 이용해 root 권한으로 실행
  - `useradd`
    - 기본 설정을 자동으로 하지 않음
  - `adduser`
    - 기본 설정을 자동으로 수행함
- `su`
  - 사용자를 변경함
  - `su ID ` : 현재 사용자의 **환경설정** 기반으로 ID로 전환
    - `.profile`을 참조함
  - `su - ID` : 변경되는 사용자의 환경설정 기반으로 ID로 전환



디렉토리/파일 관련

- `pwd`

  - 현재 디렉토리의 위치를 보여줌

- `cd`

  - 디렉토리 이동
  - 예) `cd /etc/` : etc 디렉토리로 이동하기
  - `cd ~` : 현재 로그인한 아이디의 home directory로 이동

- `ls` or `dir`

  - 현재 디렉토리에 있는 파일 목록을 출력

  - 뒤에 `-al`을 붙이면 숨김 파일, 시스템 파일(`.`으로 시작)까지 모두 볼 수 있음

    - **inode 정보도 출력**함

    - 파일 별 소유자, 소유자 그룹, 모든 사용자에 대해 읽고 쓰고 실행하는 권한
    - `-rwxr-xr-x 1 root root 120 Jul 19 19:28 debian-start`
    - 소유자의 권한+그룹의 권한+기타 사용자의 권한
    - r : 읽기, w : 쓰기, x : 실행
    - 맨 앞의 `-`는 파일임을 나타냄(`d`면 디렉토리라는 뜻)

  - 와일드 카드

    - 정규 표현식과 같음
    - `*`는 임의 문자열
    - `?`는 문자 하나
    - `ls host*` 하면 host로 시작하는 파일 목록을 출력, `ls host?`하면 host(한글자) 파일 목록 출력

- 파일 보기

  - `cat file` : 터미널에서 바로 파일 내용을 볼 수 있음
    - `vi file` 하게 되면 vi에서 열고 cat을 사용하면 터미널에서 열게 됨
  - `head file` : 파일의 앞 부분을 볼 수 있음(default 10줄)
  - `tail file` : 파일의 끝 부분을 볼 수 있음(default 10줄)

- `rm file`

  - 해당 파일을 삭제
  - `rm -rf` 하게되면 하위 디렉토리를 포함한 모든 파일을(r) 강제로(f) 삭제함



권한 관련

- `sudo`
  - root 계정으로 로그인하지 않은 상태에서 **root 권한이 필요한 명령어를 실행**할 수 있게 함
  - 어떤 아이디에서 sudo를 사용하려면 해당 아이디가 **sudo를 사용할 수 있게 설정**되어 있어야 함
    - `/etc/sudoers` 설정 파일에서 설정을 변경 가능
  - 시스템에 영향이 가는 중요한 명령을 수행할 때 root로 로그인하기보다 sudo를 사용하는 것이 일반적
    - 주의를 환기하기 위해서?
- `chmod`
  - **파일 권한을 변경**함
  - 누구에게 + 주는지/뺏는지 + 무슨 권한을
    - 문자를 사용하는 방법
    - 숫자를 사용하는 방법 : r=4, w=2, x=1로 변환하여 부여할 수 있음
    - `chmod ug+rw test.c`  : test.c 파일에 대해 user와 group에게 읽기/쓰기 권한을 추가(+)
    - `chmod u=rwx, g=rw, o=rx` : user는 rwx로, group은 rw로, 기타 사용자는 rx로 설정
    - `chmod 400 mysecurity.pem`  : `r--------`로 설정함(소유자만 읽을 수 있음)
    - `chmod -R 777 directory` : 디렉토리 내 모든 파일에 대해(-Recursive) 전부 rwx 가능하게 변경
- 소유자 변경
  - `chown` : 소유하는 사용자를 변경
    - `chown [option][user:group][file]`
  - `chgrp` : 소유하는 그룹을 변경



#### Linux Redirection, Pipe



Standard Stream(표준 입출력)

- command로 실행되는 프로세스는 3가지 스트림을 갖고 있음
  - Standard Input Stream - **`stdin`**
  - Standard Output Stream - **`stdout`**
  - Standard Error Stream - **`stderr`**
- 모든 스트림은 일반적인 plain text로 console에 출력하도록 되어 있음



리다이렉션이란?

- 표준 스트림의 흐름을 다른 쪽으로 바꿀 수 있음
  - `>, <` 기호를 사용함
  - 주로 **명령어 표준 출력을 화면이 아닌 파일에 쓸 때** 사용
- 예시
  - `ls > files.txt`
    - ls로 출력되는 표준 **출력 스트림의 방향을 파일로** 바꿈
    - 파일에 ls로 출력되는 결과가 저장됨
  - `head < files.txt`
    - files 내용이 head라는 파일의 처음부터 10라인까지 출력해주는 명령으로 넣어짐
    - files.txt의 앞 10라인이 console에 출력되는 것
  - `head < files.txt > files2.txt`
    - files.txt의 내용이 head로 들어가서 첫 10라인이 출력
    - 되어야 하는데 그 출력 스트림이 다시 files2.txt로 들어가서 저장됨
    - **리다이렉션은 앞에서부터 순서대로** 이루어짐
- 기존 파일에 추가할 경우
  - `>>, <<` 를 사용함
  - `ls >> files.txt` 기존에 있는 files.txt **파일 뒤에 ls의 출력 결과가 추가**됨



파이프란?

- 두 프로세스 사이에서 **한 프로세스의 출력 스트림을 또 다른 프로세스의 입력 스트림으로** 사용할 때
  - `|` 기호를 사용함
  - UNIX 철학이 반영된 것
    - **프로세스는 단순하게** : 이를 여러 개 엮어서 원하는 기능을 실행
- 예시
  - `ls | grep files`
    - ls 명령의 출력 내용이 **grep 명령**의(찾기 명령) 입력 스트림으로 들어감
    - grep files는 grep 명령의 입력 스트림을 검색해 files가 들어있는 입력 내용만 출력함
    - 따라서 ls 명령으로 나타낼 파일/디렉토리 중에 files가 포함된 것을 출력함



#### 프로세스 관련



프로세스 vs 바이너리

- 바이너리는(코드 이미지) **실행 파일**
- 프로세스는 **실행 중인 프로그램**
  - 실행 파일에 대한 정보에 추가로 실행 관련 정보를 가짐
    - 가상 메모리 및 물리 메모리 정보
    - 시스템 리소스 관련 정보
    - 스케줄링 단위



리눅스의 프로세스 실행 환경

- UNIX 철학
  - 한 가지 프로그램은 한 가지 기능에만 충실할 것
  - 여러 프로그램이 각자의 일을 수행해 전체 시스템이 동작하여 사용자가 원하는 기능을 제공
- 리눅스에는 기본적으로 다양한 프로세스가 실행됨
  - **프로세스를 제어/관리하는 명령어가 발달**되어 있음



foreground, background 프로세스

- foreground process
  - shell에서 실행을 명령한 후 해당 **프로세스 수행 종료까지 사용자가 다른 입력을 하지 못함**
- background process
  - 사용자 입력과 상관 없이 실행되는 프로세스(**뒤에서 실행**)
  - shell에서 해당 프로세스 실행 시 맨 뒤에 `&`를 붙여줌
  - 예) `find / -name '*.py' > list.txt &`
    - .py로 끝나는 파일을 찾아서 그 결과를 list.txt에 저장해라
    - 일반적으로 탐색은 오래걸리기 때문에 background process로 실행
    - 실행하면 job number와 pid가 표시됨



foreground 프로세스의 제어

- 프로세스 **일시 중지**
  - Ctrl + Z : (suspended 상태)로 만듦
    - 콘솔에 job number + 상태 가 출력됨
  - `bg` 명령어
    - 직전에 Stop된 프로세스를 실행시킴
    - bg + job number로 해당 프로세스를 다시 실행할 수 있음
  - `jobs` 명령어
    - 백그라운드로 진행 또는 중지된 상태로 있는 프로세스를 보여줌
- 프로세스 **강제 종료**
  - Ctrl + C : 해당 프로세스를 완전히 종료
  - 운영체제 **소프트웨어 인터럽트**가 해당 프로세스에 보내짐



프로세스 상태 확인

- `ps` 명령어로 확인 가능
- option
  - `-a` : 모든 사용자의 프로세스 출력
  - `-u` : 프로세스 소유자에 대한 상세 정보 출력
  - `-l` : 프로세스 관련 상세 정보 출력
  - `-x` : 터미널에 로그인한 후 실행한 프로세스가 아닌 프로세스도 출력
    - 주로 **daemon process**를 확인하기 위해 사용됨
    - 기본적으로 ps 명령은 현재 shell에서 실행한 프로세스들만 보여주기 때문
  - `-e` : 해당 프로세스와 관련된 환경 변수 정보를 함께 출력
  - `-f` : 프로세스 간 관계 정보도 함께 출력
  - 이 외에도 있지만 생략
- Daemon process
  - 사용자 모르게 **시스템 관리를 위해 실행되는 프로세스**
  - 보통 시스템이 부팅될 때 자동 실행
  - 예) ftpd, inetd
- ps 출력 정보 항목
  - USER : 프로세스를 실행시킨 사용자 ID
  - PID : 프로세스 ID
  - %CPU : 마지막 1분간 프로세스가 사용한 CPU burst time의 점유율
  - %MEM : 마지막 1분간 프로세스가 사용한 메모리 점유율
  - VSZ : 프로세스가 사용하는 가상 메모리 사이즈
  - RSS : 프로세스가 사용하는 실제 메모리 사이즈
  - STAT : 프로세스 상태
  - START : 프로세스가 시작된 시간
  - TIME : 현재까지 사용된 CPU 시간
  - COMMAND : 명령어



프로세스 중지

- `kill PID` 명령어로 죽일 수 있음
- 강제 종료하고 싶은 경우 `kill -9`



#### 리눅스 파일 시스템



파일 인터페이스

- 리눅스에서는 **파일 추상화 인터페이스**로 모든 데이터 및 디바이스에 접근
  - **모든 것은 파일**이라는 철학
  - 모든 자원에 대한 추상화 인터페이스로 파일 인터페이스를 활용하는 것
    - 파일을 처리하는 4가지 인터페이스로(open, read, write, close) 다른 작업도 처리하자



파일 시스템의 체계

- **슈퍼블록** : 파일 시스템의 전체에 대한 정보
- 파일은 **inode** 고유값과 자료구조에 의해 주요 정보가 관리됨
  - inode에는 파일 **메타 데이터**와 disk block이 저장됨
  - 메타 데이터 : 파일 권한, 소유자 정보, 파일 사이즈, 생성시간, 데이터 저장 위치 등
  - inode 번호가 파일이름에 매칭됨
    - 각각의 파일은 inode를 기반으로 액세스



파일 탐색

예) `/home/ubuntu/link.txt` 를 어떻게 찾아갈까?

1. 먼저 각 디렉토리의 엔트리(**dentry**)를 탐색
   - 각 엔트리는 해당 디렉토리에 대한 파일/디렉토리의 정보를 갖고 있음
   - 여기서 파일/디렉토리 정보는 **inode로 관리**됨
     - 모든 것은 파일이라는 것
2. root dentry에서 'home'을, 'home'에서 'ubuntu'를, 'ubuntu'에서 'link.txt'을 찾아 해당하는 inode를 얻음



파일 복사

- `cp`
  - `cp file1 file2` 명령어로 file1을 file2로 복사함
  - 원본 파일 **inode 구조 내의 모든 데이터를 복사**해서 새로운 파일을 생성함
  - deep copy라고 할 수 있음
    - 원본을 수정해도 복사본의 내용은 변경되지 않음
    - 원본을 삭제해도 복사본은 남음
- 하드 링크
  - `ln file1 file2` 명령어로 file1을 file2로 복사함
  - 이렇게 복사된 파일의 **inode 번호는 원본 파일과 동일**
  - shallow copy라고 할 수 있음
    - 원본을 수정하면 복사본의 내용도 변경됨
    - **원본을 삭제해도 복사본은 남음** : inode 구조는 아직 남아있기 때문
  - 대용량의 파일을 다른 디렉토리에 복사하는 경우에 유용함
- 소프트 링크
  - `ln -s file1 file2` 명령어로 file1을 file2로 복사함
  - 복사된 파일의 **inode 번호는 원본 파일과 다름**
    - 새로 생성된 inode 구조의 direct block 자리에 원본 파일 inode 구조의 주소가 저장됨
  - 윈도우의 바로가기와 동일하다고 볼 수 있음
    - 원본을 수정하면 복사본의 내용도 변경됨
    - 원본을 삭제하면 복사본도 삭제됨
    - `ls -al`을 통해 해당 파일이 어느 파일을 가리키는지 확인 가능
    - 링크 파일임을 알려주기 위해 권한정보 첫 글자에 `l`이 표시됨



특수 파일(디바이스)

- 블록 디바이스(block device)
  - 블록, 섹터 단위로 데이터를 전송하는 디바이스
  - HDD, SSD 등 저장매체
  - I/O 송수신 속도가 높음
  - 권한정보 첫 글자가 `b`로 표시됨
- 캐릭터 디바이스(character device)
  - 바이트 단위로 데이터를 전송하는 디바이스
  - 키보드, 마우스 등 
  - I/O 송수신 속도가 낮음
  - 권한정보 첫 글자는 `c`
- `/dev` 디렉토리로 이동해서 다양한 디바이스들의 파일을 확인 가능



## **3. 시스템 프로그래밍 핵심 기술**



시스템 프로그래밍의 기반 요소

- 시스템 콜

  - 사용자 영역에서 운영 체제를 제어 : 사용자 영역에서 **커널에 요청하는 함수**
  - 시스템 콜은 C언어로 되어있음

- C 라이브러리(API)

  - **응용 프로그램과 분리**된 하위 호환 인터페이스
    - 필요할 때만 프로세스가 해당 라이브러리를 호출
    - 예) 시스템 콜 래퍼, 입출력 라이브러리 등
  - 동적 라이브러리
    - 라이브러리의 바이너리 코드에 실행 코드를 붙여 실행 파일을 만듦
  - 정적 라이브러리
  - UNIX C 라이브러리 : libc
  - LINUX C 라이브러리 : GNU libc
    - 시스템콜, 시스템콜 래퍼, 기본 응용 프로그램 기능 포함

- C 컴파일러

  - UNIX C 컴파일러 : cc

  - LINUX C 컴파일러 : GNU cc(gcc)

    - 우분투 리눅스에 gcc를 설치할 수 있음

    - ```bash
      sudo apt-get install gcc
      gcc --version
      gcc -o test.c test
      ```



시스템 콜의 동작

- eax 레지스터에 시스템 콜 번호를 넣음
- ebx 레지스터에는 시스템 콜에 해당하는 인자 값을 넣음
- 소프트웨어 인터럽트 명령을 호출하면서 `0x80`값을 넘겨줌
  - CPU는 사용자 모드를 커널 모드로 전환
  - IDT(Interrupt Descriptor Table)에서 `0x80`에 해당하는 주소 함수를 찾아서 실행
  - `system_call()` 함수에서 eax로부터 시스템 콜 번호를 찾아 해당 번호에 맞는 함수로 이동
  - 해당 시스템 콜 함수 실행 후 다시 사용자 모드로 변경하고 해당 프로세스의 다음 코드 진행
  - IDT그림



ABI(Application Binary Interface)

- 응용 프로그램 **바이너리 인터페이스**
  - ABI가 호환되면 재컴파일 없이 동작 가능
  - ABI가 다르기 때문에 Linux에서 만든 프로그램이 윈도우에서 실행되지 않음
- 함수의 실행 방식, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크 방식 등을 정의함
- 컴파일러, 링커(라이브러리 링크), 툴 체인(컴파일러를 만드는 프로그램)에서 제공함



표준화

- POSIX
  - 유닉스 시스템 프로그래밍 인터페이스 표준
    - IEEE에서 표준화를 시도함
    - 리차드 스톨만이 POSIX라는 이름을 제안함
- C언어
  - ANSI(American National Standards Institute)에서 ANSI C 표준 정립
- 리눅스는 POSIX와 ANSI C를 지원함



## **4. 프로세스 관리**



프로세스 ID(pid)

- 각 프로세스는 해당 시점에 **unique**한 pid를 가짐
- signed 16 비트 정수값 사용 : 최대 32768
- pid 할당 방식
  - 최근 할당된 pid 기준으로 1씩 증가
  - 최댓값에 도달하면 할당할 수 없는 상태 도달



프로세스 계층

- 최초 프로세스
  - init 프로세스(pid 1) : 운영체제가 생성함
  - 특별히 하는 일은 없고 컴퓨터가 종료될 때까지 유지됨
- 프로세스는 다른 프로세스로부터 생성됨
- ppid : 부모 프로세스의 pid값
  - `ps -ef` 명령어로 확인 가능
  - `-e` : 모든 프로세스에 대한 정보 출력
  - `-f` : 다음 목록을 출력(UID, PID, PPID, CPU%, STIME, TTY, TIME, CMD)



프로세스와 소유자 관리

- 리눅스 내부에서는 프로세스의 소유자와(사용자) 그룹을 UID/GID(정수)로 관리함
  - `etc/passwd`에서 확인 가능
  - 사용자 이름:password:UID:GID:사용자 정보:사용자 홈 디렉토리:로그인 시 실행할 shell 환경
- 사용자에게 보여줄 때만 UID와 사용자 이름 매핑 정보를 기반으로 사용자 이름을 제공



프로세스 ID 시스템콜

- `getpid()`, `getppid()`
  - 현재 프로세스의 pid와 ppid를 얻는 시스템 콜
  - `ps`의 경우 `bash` 프로세스가 부모 프로세스가 됨을 확인할 수 있음



#### 프로세스 생성과 종료



프로세스 생성 과정

- 프로세스는 다른 프로세스로부터 생성됨
- Code, Data, BSS, Heap, Stack의 공간을 생성
- 프로세스 이미지를 해당 공간에 업로드하고 실행 시작



`fork()` 

- 새로운 프로세스 공간을 만든 후 fork()를 호출한 프로세스의 공간을 모두 **복사**
- **호출한 프로세스가 부모 프로세스**가 되어 데이터를 그대로 복사하는 것
  - 부모 프로세스가 그대로 남음
- 헤더 파일 : `<unistd.h>`
- 함수 원형 : `pid_t fork(void);`
  - pid 값을 리턴함 : 자식은 0, 부모는 기존의 pid 값, fork 실패시 -1
  - 부모 프로세스와 자식 프로세스가 실행할 코드를 구분할 수 있음
  - 부모 프로세스 공간을 모두 복사한 후, fork() 이후의 코드부터 실행



`exec()`

- exec()를 호출한 프로세스 공간의 Code, Data, BSS 영역을 새로운 프로세스의 이미지로 **덮어 씌움**
  - **부모 프로세스는 사라짐**
  - Program Counter가 새로운 코드를 가리키기 때문에 호출한 프로세스의 코드는 실행되지 않음
- 별도의 프로세스 공간을 만들지 않음
- 6가지 시스템 콜이 존재함
  - `execl()` : 첫 번째 인자로 경로를 넣음
  - `execlp()` : PATH를 참조해 실행 파일을 보기 때문에 첫 번째 인자로 명령어만 쓰면 됨
  - `execle()` : 환경변수를 따로 설정해서 마지막 인자로 받음
  - `execv()` : 인자를 변수로 미리 만들어서(string) 넣을 수 있음
  - `execvp()` : string을 사용하는 것 외에 execlp()와 동일
  - `execve()` : string을 사용하는 것 외에 execle()와 동일



`wait()`

![wait](https://shivammitra.com/assets/images/fork.png)

- wait() 함수를 사용하면 fork() 함수 호출 시 자식 프로세스가 종료될 때까지 부모 프로세스가 기다림
- 자식 프로세스와 부모 프로세스의 **동기화**나 **자식보다 부모가 먼저 죽는 것**을 막기 위해 사용함
  - 자식 프로세스 종료시 해당 정보를 부모 프로세스가 확인해야 함
  - 부모 프로세스가 먼저 죽으면 이를 확인하지 못해 정보가 메모리에 유지됨
  - 이를 **좀비 프로세스 or 고아 프로세스** 라고 함
- `wait(NULL)`로 실행할 수 있음
- execl()과의 사용
  - execl()만 사용하면 부모 프로세스가 사라짐
  - 따라서 fork()를 하여 생긴 **자식 프로세스에서 execl()을 실행**
  - 종료시 부모 프로세스에 SIGCHLD 시그널을 보내면 부모 프로세스의 wait()이 풀려 코드가 마저 실행됨



리눅스 프로세스 구조

- 프로세스 당 4GB의 가상 메모리를 할당함
  - Kernel Space : `0xff`부터 `0xc0`까지 1GB의 공간에 커널 이미지가 들어감
  - User Space : 나머지 3GB의 공간에 스택, 힙, BSS, Data, Text가 들어감
- 커널에 할당한 가상 메모리는 프로세스 간에 공유됨
  - 동일한 이미지가 프로세스마다 들어가는 것은 낭비이기 때문
  - 프로세스 별 페이지 테이블에서 **커널에 해당되는 물리 메모리 주소는 동일**함



copy-on-write

- 자식 프로세스 생성 시 부모 프로세스 페이지를 우선 사용하고 **페이지 쓰기 작업시에만 복사하고 분리**하는 것
  - 프로세스 생성 시간을 줄일 수 있음
    - fork()에서 기존 프로세스 공간(4GB)을 전부 복사하면 시간이 매우 오래 걸림
  - 새로 생성된 프로세스에 새롭게 할당해야 하는 페이지 수를 최소화
- 동작 방식
  - 자식 프로세스에 read 요청시
    - 자식 프로세스의 페이지 테이블은 부모 프로세스와 동일한 물리 메모리 주소를 가리킴
  - 자식 프로세스에 write 요청시
    - 물리 메모리 상에서 페이지를 복사함
    - 자식 프로세스의 페이지 테이블에서 **page pointer를 변경**함 



프로세스 종료

`exit()`

- 프로세스를 종료하는 시스템 콜
- main에서 `return 0;` 과의 차이
  - exit()은 **즉시 프로세스를 종료**함 : exit() 다음에 있는 코드는 실행되지 않음
  - return 0는 main 함수를 종료함
    - 단 main에서 return하게 되면 C언어 실행 파일에 기본으로 포함된 `_start()` 함수를 호출
    - start()는 다시 exit()을 호출하기 때문에 큰 차이는 없다고 할 수 있음
    - start 안에 main이 있기 때문에 main이 끝나면 다시 start로 돌아가는 것
- 함수 원형 : `void exit(int status)`
  - 프로세스 종료 상태를 나타내는 번호를 넣음
    - 자식 프로세스가 종료되었을 때 부모 프로세스가 확인하기 위함
    - 부모 프로세스는 `status & 0377` 의 계산 결과로 종료 상태를 확인함
  - 0 : EXIT_SUCCESS, 1: EXIT_FAILURE
- exit() 함수의 주요 동작
  - `atexit()`에 등록된 함수 실행
    - 프로세스가 **종료될 때 실행되어야 할 함수들**을 atexit() 함수 내부에 등록할 수 있음
    - 등록된 역순으로 실행함
  - 열려 있는 모든 I/O stream buffer 삭제
  - 프로세스가 오픈한 파일을 모두 닫음
  - `tmpfile()` 함수를 통해 생성한 임시 파일 삭제
    - 임시 파일을 `wb+` (쓸 수 있는 이진 상태) 모드로 오픈 가능



`wait()`의 리턴값

- wait()의 함수 원형 : `pit_t wait(int *status)`
  - 리턴값은 종료된 자식 프로세스의 pid
- status 정보를 통해 기본적인 자식 프로세스 관련 정보를 확인할 수 있음
  - `int WIFEXITED(status)` : 자식 프로세스가 정상 종료시 리턴 값이 0이 아닌 값이 됨
  - 위에서 `wait(NULL)`로 사용했던 이유는 ??



#### 프로세스 스케줄링 관련



Priority-Based Scheduler

- 정적 우선순위
  - 프로세스마다 우선순위를 **미리 지정**
- 동적 우선순위
  - 스케줄러가 상황에 따라 우선순위를 동적으로 변경



우선순위 변경 시스템 콜

- `nice()`

  - 함수 원형 : `int nice(int inc)`
    - 우선순위의 값을 인자로 받음
  - 프로세스 중 root가 소유한 프로세스만 우선순위를 높일 수 있음
    - 나머지 프로세스는 낮추는 것만 가능
    - 스케줄링 방식에 따라 우선순위가 적용될 수도, 안 될 수도 있음

- `getpriority()`, `setpriority()`

  - 함수 원형

    - ```c
      int getpriority(int which, id_t who);
      int setpriority(int which, id_t who, int set);
      ```

  - which : 어떤 자원의 우선순위를 가져올 것인지(세팅할 것인지)를 결정함

    - 프로세스(PRIO_PROCESS), 프로세스 그룹(PRIO_PGRP), 사용자(PRIO_USER) 별로 우선순위를 가져올 수 있음
    - 사용자 별로 우선순위를 매기거나 하는 방식일 때 의미가 있음



#### IPC 기법



File 기법

- 파일을 통한 데이터 공유
- 프로세스 A가 파일에 뭔가를 썼을 때 프로세스 B가 이를 알 방법이 없음
  - 공유하고 있는 커널 공간을 이용해서 해결
  - 아래 방법들이 전부 커널 공간을 통한 IPC 기법



pipe

- fork()로 자식 프로세스를 만들었을 때 **부모에서 자식으로 데이터를 보낼 수 있는 단방향 통로**
- 사용 방법
  - 배열을 선언해 `pipe()`의 인자로 전달하여 파이프를 생성함
  - 부모 프로세스에서는 `write()` 시스템 콜을 이용해 배열에 데이터를 입력
  - 자식 프로세스에서는 `read()` 시스템 콜을 이용해 배열의 데이터를 조회



message queue

- FIFO 정책으로 데이터를 전송함

  - 어떤 프로세스도 큐에 접근할 수 있고 양방향으로 통신이 가능

- 사용 방법

  - 메세지 큐를 생성

  - ```c
    msqid = msgget(key, msgflg);	// key는 메세지 큐의 식별키, msgflg는 옵션
    // 생성되면 ID를 리턴하여 msqid에 저장
    ```

  - `msgsnd()` 를 이용하여 특정 메세지큐로 메세지를 전송

    - 타입을 설정할 수 있음

  - `msgrcv()` 를 이용하여 메세지를 수신

    - 원하는 타입에 대해 먼저 들어가 있던 메세지를 받음



shared memory

- 커널 공간에 메모리 공간을 만들어 두고 **변수를 이용해 해당 공간에 접근**하는 방식

- 공유 메모리 key를 가지고 여러 프로세스가 접근할 수 있음

- 사용 방법

  - 공유 메모리를 생성

  - ```c
    int shmat()
    ```

  - 공유 메모리 연결

  - ```c
    void *shmat();
    
    shmaddr = (char *)shmat(shmid, (char*))
    ```

  - 공유 메모리 해제

  - ```c
    int shmdt(char *shmaddr);
    ```

  - 공유 메모리에서 읽기

  - ```c
    
    ```

  - 공유 메모리에서 쓰기



기타 IPC 기법

- signal
- semaphore
- socket



시그널 동작 메커니즘

- 시그널이란?
  - 커널 또는 프로세스에서 어떤 이벤트가 발생되었는지 다른 **프로세스에 알려주는 기법**
  - UNIX에서 30년 이상 사용된 전통적인 기법
  - 예) Ctrl + C를 눌러서 프로세스를 종료시킬 때 시그널이 해당 프로세스에 전달되어 종료 처리
- 시그널 종류와 각 **시그널에 따른 기본 동작**(디폴트 처리)이 미리 정의되어 있음
  - 기본 동작 대신 다른 동작을 하도록 프로그램 내에서 override 가능
- 주요 시그널(총 64종류)
  - `kill -l` 명령어를 이용해서 열람 가능
  - SIGKILL : 프로세스 강제 종료
  - SIGALARM : 알람 발생
  - SIGSTP : 프로세스 stop(Ctrl + Z)
  - SIGCONT : 멈춰진 프로세스를 실행
  - SIGINT : 프로세스에 인터럽트를 보내서 kill(Ctrl + C)
  - SIGSEGV : 프로세스가 다른 메모리 영역을 침범한 경우
  - SIGUSR1, SIGUSR2 : 프로세스 내부에서 재정의 가능한 시그널
    - IPC에 사용 가능



시그널과 프로세스

- PCB에서 해당 프로세스가 블록 또는 처리해야하는 시그널 관련 정보를 관리함
  - pending : 해당 프로세스에 전달된 시그널들을 순서대로 연결하여 저장
  - sigpending : ?
  - blocked : 64bit의 비트마스크를 이용하여 어떤 시그널이 블럭되어 있는지 판단
  - sig : 각 시그널에 대해 어떤 동작을 해야 하는지 관리함
- 커널 모드에서 **사용자 모드 전환 시 시그널 정보를 확인해 처리**함
  - 사용자 모드로 전환되기 전에 기본 동작을 처리
  - 만약 재정의되어있다면 Program Counter를 해당 함수로 이동시켜놓고 사용자 모드로 전환됨



## **5. Shell Script**



쉘 스크립트란?

- 쉘 명령어를 기본으로 몇 가지 문법이 추가된 형태
  - 쉘을 사용해 프로그래밍이 가능하도록 한 것
  - 쉘 스크립트 대신 과거에는 perl, 최근에는 python을 이용하기도 함
- 서버 작업 자동화 및 운영(DevOps)를 위해 익혀둘 필요가 있음
  - 예) 어느날 서버가 다운되었는데 서버 저장공간이 하나도 남지 않았음 : 로그 파일이 많이 쌓여 로그 파일 업데이트가 안 되었고 관련 프로그램이 비정상 종료됨. 어떻게 하면 오래된 로그 파일을 자동 삭제할까?
  - 쉘스크립트를 생성하여 주기적으로 실행하면 됨



기본 문법

- 쉘 스크립트는 **파일로 작성한 후 파일을 실행**함

  - 파일의 첫 라인은 `#!/bin/bash`로 시작
  - 쉘 스크립트 파일은 실행 권한을(x) 가지고 있어야 함
    - 저장한 후 `chmod`로 실행 권한을 부여해야 함
  - 파일 이름은 일반적으로 `fileName.sh`와 같은 형태로 작성함

- 예제

  - Hello World 출력하기

  - ```shell
    #!/bin/bash
    
    echo 'Hello World!'		# 화면에 출력해주는 쉘 명령어
    ```



#### 변수



변수 선언과 사용

- 변수 이름은 `$variableName`과 같이 $를 앞에 붙임

- 할당할 데이터와 변수 사이에 **띄어쓰기를 허용하지 않음**

- 예제

  - ```shell
    #!/bin/bash
    
    mysql_id='root'		# my_sql = 'root'는 안 됨
    mysql_directory='/etc/mysql'
    
    echo $mysql_id
    echo $mysql_directory
    ```



리스트 변수

- 선언

  - `variable_name=(data1 data2 data3 ...)`

- 사용

  - `${variable_name[index]}`

- 예제

  - ```shell
    #!/bin/bash
    
    daemons=("httpd" "mysqld" "vsftpd")
    echo ${daemons[1]}			# $daemons 배열의 1번 원소 출력 : mysqld
    echo ${daemons[@]}			# $daemons 배열의 모든 데이터 출력
    echo ${daemons[*]}			# $daemons 배열의 모든 데이터 출력
    echo ${#daemons[@]}			# $daemons 배열의 크기 출력
    
    filelist( $(ls) )	# 해당 쉘 스크립트 실행 디렉토리에서 ls 실행 결과를 $filelist에 저장
    echo ${filelist[*]}	# $filelist 배열의 모든 데이터 출력
    ```



사전에 정의된 지역 변수

- `$$` : 쉘의 프로세스 번호
- `$0` : 쉘스크립트 이름
- `$1` ~`$9` :  명령줄 인수
  - 예) `ls -al` 명령어를 실행했을 때 $0에는 ls, $1에는 -al이 저장됨
- `$*` : 모든 명령줄의 인수리스트
- `$#` : 인수의 갯수
- `$?` : 최근 실행한 명령어의 종료 값
  - 0 : 성공, 1~125 : 에러
  - 126 : 파일이 실행가능하지 않음
  - 128 ~ 255 : 시그널 발생



연산자

- `expr`를 이용하여 숫자를 계산함

  - back tick을 사용해야 함
  - 연산자와 괄호 앞에는 역 슬래시 사용
  - 연산자와 숫자, 변수, 기호 사이에는 space를 넣어야 함

- 예제

  - (10 + 20) / 8 - 8 계산하기

  - ```shell
    #!/bin/bash
    
    num=`expr \( 10 + 20 \) / 8 - 8`
    echo $num
    ```



조건문

- 기본 if 구문

  - 명령문을 꼭 탭으로 띄울 필요 없이 then과 if 안에만 들어 있으면 됨
    - 한 줄로 작성할 수도 있음
    - `if [ 조건 ]; then 명령문; fi`
  - 가독성이 떨어지기 때문에 굳이 외우지 말고 필요할 때마다 참고하는 것을 권장

- 예제

  - 두 인자를 받아서 값이 다르면 'different values'를 출력하기

    ```shell
    #!/bin/bash
    
    if [ $1 != $2 ]
    then
    	echo "different values"
    	exit
    fi
    ```

- 수치 비교

  - `value1 -eq value2` : 값이 같음(equal)
  - `value1 -ne value2` : 값이 같지 않음(not equal)
  - `value1 -lt value2` : 값1이 값2보다 작음(less than)
  - `value1 -le value2` : 값1이 값2보다 작거나 같음(less or equal)
  - `value1 -gt value2` : 값1이 값2보다 큼(greater than)
  - `value1 -ge value2` : 값1이 값2보다 크거나 같음(greater or equal)

- 파일 검사

  - 파일의 상태에 근거해서 조건을 부여할 수 있음
  - 존재하는지(-e), 디렉토리인지(-d), 심볼릭 링크인지(-h) 등등



반복문

- 기본 for 구문

  - ```shell
    #!/bin/bash
    
    for database in $(ls)
    do
    	echo $database
    done
    ```

  - 파이썬 for문과 비슷함

  - 반복문도 한 줄에 출력 가능

    - `for database in $(ls); do echo $database; done`

- while 구문

  - ```shell
    #!/bin/bash
    
    lists=$(ls)
    num=${#lists[@]}
    index=0
    while [ $num -ge 0 ]
    do
    	echo ${lists[$index]}
    	index=`expr $index + 1`
    	num=`expr $num - `
    done
    ```

  - while문이 일반적으로 더 복잡한 것은 아니고 위 예제가 for문으로 쓰기 편한 경우임



## **6. 스레드**



Pthread란?

- POSIX thread : 스레드 표준 API
- Pthread API
  - 저수준 API로 100여개의 함수를 제공함
  - 복잡하지만 UNIX 시스템의 핵심 스레딩 라이브러리임
  - 다른 스레딩 솔루션도 결국 Pthread로 구현되어 있음



Pthread 라이브러리

- `<pthread.h>` 헤더 파일에 정의됨
- 모든 함수는 `pthread_`로 시작 : 100여 개가 존재
- 크게 두 가지 그룹으로 나눌 수 있음
  - **스레드 관리** : 생성, 종료, join, detach 등
  - **동기화** : mutex 등 동기화 관련 함수
- 컴파일 시 명시적으로 `-pthread` 옵션이 필요함
  - 기본 라이브러리(glibc)와 분리된 `libpthread` 라이브러리에 별도로 구현되어 있기 때문
  - 예) `gcc -pthread test.c -o test`



스레드 관리 함수

- `pthread_create`
  - 스레드를 생성하는 함수
  - 첫 번째 인자로 해당 스레드를 가리키는 포인터를 가리킴 : 스레드를 미리 선언해야 함
  - 두 번째 인자는 설정이 필요한 경우 넣는데 대개는 NULL을 사용
  - 세 번째 인자로 스레드가 실행하는 함수를 넣어줌 : 함수도 미리 선언해야 함
  - 마지막 인자로 스레드 실행 함수에 들어갈 인자를 넣어줌
- `pthread_exit`
  - 스레드를 종료하는 함수 : exit와 유사함
  - 인자로 상태 값을 넣어 줌 : 0이나 NULL은 정상 종료를 나타냄
- `pthread_join`
  - 스레드 조인 함수 : 생성된 **스레드가 끝날 때까지 기다리도록 하는 함수**
    - 프로세스에서 새로운 스레드를 생성했을 때, 프로세스는 이와 구분하기 위해 메인 스레드라고 부름
    - 메인 스레드는 스레드를 생성한 뒤 pthread_create() 다음 코드를 실행하게 됨
    - 메인 스레드가 모든 코드를 실행하여 끝났는데 다른 스레드가 실행 중이면 문제 발생
    - 따라서 조인 함수를 이용해 특정 스레드가 끝날 때까지 기다려 줘야 함
  - 첫 번째 인자로 기다릴 스레드의 포인터를 받음
  - 두 번째 인자로 status 포인터를 받아 **종료된 스레드의 상태값**을 가져옴
    - 이를 이용해 메인 스레드에서 추가적인 처리를 진행
- `pthread_detach`
  - 해당 스레드가 종료될 경우 **즉시** 관련 리소스를 해제(free) 함
    - 조인을 기다리지 않고 종료 즉시 리소스를 해제함
    - 생성된 스레드가 점유한 자원을 해제하는 방법은 join과 detach 두 가지 밖에 없음
    - join의 경우 다음 코드 실행을 위해 스레드 종료를 기다려야 하지만 detach는 기다리지 않음
  - 첫 번째 인자로 기다릴 스레드의 포인터를 받음



동기화 함수

- 임계영역/자원 관리를 위해 뮤텍스와 같은 동기화 함수를 사용해야 함
- 뮤텍스 선언과 초기화
  - `pthread_mutex_t mutex_lock = PTHREAD_MUTEX_INITIALIZER;` 
- 뮤텍스 락 걸기와 해제
  - 뮤텍스의 포인터를 인자로 받음
  - 락 걸기 : `int pthread_mutex_lock(pthread_mutex_t *mutex);`
  - 락 해제 : `int pthread_mutex_unlock(pthread_mutex_t *mutex);`



## **7. 메모리**



메모리 관련 주요 함수

- 동적 메모리
  - heap 영역에 생성 : `malloc()`
  - 해제 : `free()`



mmap

- 메모리에 파일을 매핑하는 함수

- 함수 원형

  - ```c
    void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)
    ```

  - 메모리 주소 결정

    - start와 offset : 어디서부터 매핑할지 나타내는 주소를 결정
    - length는 파일 중 얼마를(길이) 메모리에 매핑할지 나타내는 사이즈를 결정
    - 보통 start는 NULL or 0을 사용하고 offset은 매핑되길 원하는 주소를 지정
    - `start + offset` ~ `start + offset + length` 만큼의 공간을 요청함

  - 세 번째 인자는 권한을 설정

    - PROT_READ(읽기 가능), PROT_WRITE(쓰기 가능), PROT_EXEC(실행 가능), PROT_NONE(접근 불가)

  - 네 번째 인자는 메모리 주소 공간을 어디에 만들지 결정

    - MAP_SHARED(다른 프로세스와 공유 가능)
    - MAP_PRIVATE(프로세스 내에서만 사용 가능)
    - MAP_FIXED(지정된 주소로 지정)

  - fd : device file에 대한 file descriptor

    - open() 함수를 이용해 받아 온 파일을 가리키는 변수

  - 매핑에 성공하면 주소 값을 리턴하고 실패하면 에러를 발생시킴



mmap의 동작 원리

- mmap 실행 시 가상 메모리 주소에 file 주소를 매핑
- 해당 메모리 접근(**demand paging**)
  - 페이지 폴트 인터럽트 발생
  - OS에서 file data를 복사해서 물리 메모리 페이지에 넣어줌
- 메모리 read : 해당 물리 페이지 데이터를 읽음
- 메모리 write : 해당 물리 페이지 데이터 수정 후 페이지 상태 flag중 dirty bit를 1로 수정
- 파일 close : 물리 페이지 데이터가 file에 업데이트 됨
  - **한 번만 파일에 access**하기 때문에 성능이 향상됨



mmap의 장단점

- read, write시 반복적인 파일 접근을 방지하여 성능 개선
- mapping된 영역은 파일 처리를 위한 lseek()을 사용하지 않고 간단한 포인터 조작으로 탐색이 가능
- 페이지 단위로 매핑하기 때문에 공간의 낭비가 있을 수 있음



munmap

- 메모리에 매핑된 파일의 물리 메모리 주소를 해제함

- 함수 원형

  - ```c
    int munmap(void *addr, size_t length)
    ```

  - *addr은 매핑된 주소, length는 메모리의 크기(mmap에 전달한 값과 동일한 값)



msync

- 메모리에 매핑된 **파일의 변경 사항을 파일에 강제로 동기화** 시키는 함수

- 함수 원형

  - ```c
    int msync(void *start, size_t length, int flags);
    ```

  - start : mmap() 함수를 통해 리턴받은 메모리 맵의 시작 주소

  - length : 동기화를 할 길이 - 전체 파일 길이를 넣어주는 것이 일반적

  - flags : 동기화 방식

    - MS_ASYNC : 동기화하라는 명령만 내리고 결과에 관계 없이 다음 코드 실행
    - MS_SYNC : 메모리에 있는 데이터가 파일에 업데이트될 때까지 대기
    - MS_INVALIDATE : 현재 메모리 맵을 무효화하고 파일의 원본 데이터로 갱신함 

- msync를 사용하지 않아도 **프로세스가 종료되면 자동으로 동기화**가 일어남



inode 파일 시스템 

- mode : 파일 종류/권한(rwx)
- owner info : 소유자/소유 그룹
- size : 파일 사이즈
- timestamps : 생성된 시각과 수정된 시각
- direct blocks : 직접적으로 가리키는 파일 블록
- indirect blocks : 간접적으로 가리키는 파일 블록



inode 관련 시스템콜

- inode의 상태 값들을 가져오는 함수

  - 함수 원형

  - ```c
    // path를 포함한 해당 파일의 이름 + inode 자료구조의 상태를 입력할 구조체 변수
    int stat(const char *path, struct stat *buf);
    
    // file descriptor를 인자로 전달함
    int fstat(int filedes, struct stat *buf);
    ```

  - stat 구조체

    - 너무 많아서 생략