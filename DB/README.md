# DB

데이터베이스 기초부터 심화까지



참고서적

- Do it! 오라클로 배우는 데이터베이스 입문
- Database System Concepts [pdf](https://www.db-book.com/db7/index.html)
  - SNUON 강의 "데이타베이스: 빅데이터 시대의 필수 정보관리 개론" - 이상구
- Softbank 신입사원 OJT



[TOC]

## **1. 데이터베이스 개론**

> 데이터베이스 기본 개념



데이터베이스란?

- 데이터와 정보
  - 데이터: 어떤 필요에 의해 수집했지만 아직 특정 목적을 위해 평가하거나 정제하지 않은 자료
  - 정보: 수집한 데이터를 어떤 목적을 위해 분석하거나 가공한 것
- 효율적인 데이터 관리: **데이터베이스의 필요성** 대두
  - 데이터를 통합하여 관리
  - 일관된 방법을 관리
  - 데이터의 누락, 중복 제거
  - 여러 사용자가 공동으로 실시간 사용 가능
- 데이터베이스
  - 특정 목적을 위해 여러 사람이 공유하여 사용할 수 있으며 효율적 관리와 검색을 위해 **구조화한 데이터 집합**
- 파일 시스템
  - DB등장 이전에 데이터를 관리하던 방식
  - 각각의 응용 프로그램에 필요한 데이터를 각각 저장: 중복 및 누락 발생 가능
    - 데이터의 통합 관리 필요성 대두: **DBMS**의 등장



DBMS란?

- Database Management System
- 여러 목적으로 사용할 데이터의 접근/관리 등 업무를 **DBMS가 전담**함
  - 하나의 DBMS를 통해 관리: 데이터를 관리하는 방식이 통합됨
  - 중복 및 누락 방지: 하나의 소프트웨어가 데이터를 관리
  - 공동으로 실시간 사용 가능: 데이터가 응용프로그램에 독립적이므로 프로그램 업데이트 시에도 사용 가능



데이터 모델

- 데이터를 저장하는 방식을 정의해 놓은 개념 모형

- 계층형 데이터 모델

  - 트리 구조를 활용
  - 부모 자식 관계 - 1:N

- 네트워크형 데이터 모델

  - 그래프 구조를 기반으로 함
  - 자식 개체가 여러 부모 개체를 가질 수 있음 - M:N

- 객체 지향형 데이터 모델

  - 데이터를 독립된 개체로 구성하여 관리

- **관계형 데이터 모델**

  - 데이터 간 관계에 초점

    - 각 데이터의 **독립 특성**만을 규정하여 데이터 묶음을 나눔
    - 중복이 발생할 수 있는 데이터는 별개의 **relation**으로 정의하여 연결

  - 구성 요소

    - | 이름                   | 설명                                   | 대응(구현)되는 개념  |
      | ---------------------- | -------------------------------------- | -------------------- |
      | 개체(entity)           | 데이터화하려는 사물/개념의 정보 단위   | 테이블(**relation**) |
      | 속성(attribute)        | 데이터의 종류, 특성, 상태              | 열(column)           |
      | **관계(relationship)** | 개체 간 또는 속성 간의 연관성을 나타냄 | 외래키               |

  - **릴레이션(relation)과 관계(relationship)의 차이** [링크](https://m.blog.naver.com/PostView.nhn?blogId=ej5811&logNo=80191263951&proxyReferer=https:%2F%2Fwww.google.com%2F)

    - 릴레이션: 집합x와 집합y 사이에 관계 R을 만족하는 모든 순서쌍
      - 테이블이 집합 간의 cartesian product를 생성한다는 것을 생각해보자
      - 집합이론에서는 relation, 논리 데이터 모델링에서는 entity, 관계형 데이터베이스에서는 table
    - 관계: 하나 또는 두 개의 entity type으로부터 **업무적인 이유**에 의해 entity가 연결되어 있는 **페어링의 집합**
      - 예) entity type "주문"의 entity인 "주문번호"가 entity type "주문상품"의 entity인 "상품코드"와 연결되어 페어링을 이루고 있음
      - 페어링은 관계의 멤버이고, 관계는 페어링의 집합체



### 1.1. 관계형 데이터 베이스



관계형 데이터베이스

- 관계형 데이터 모델을 바탕으로 만들어진 데이터베이스
  - 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 **관계**를 나타냄
- 관계형 데이터베이스를 관리하는 시스템은 **RDBMS**(Relational Database Management System)이라 함
  - MS-SQL, MySQL, MariaDB, PostgreSQL, DB2 등



SQL

- Structured Query Language
- RDBMS에서 데이터를 다루고 관리하는 데 사용하는 **질의 언어**
  - 조회, 데이터 조작, 객체 조작 등
  - DQL(Data Query Language)
    - 데이터를 원하는 방식으로 조회하는 명령어
  - DML(Data Manipulation Language)
    - 데이터를 저장, 수정, 삭제하는 명령어
  - DDL(Data Definition Language)
    - 테이블을 포함한 여러 객체를 생성, 수정, 삭제하는 명령어
  - TCL(Transaction Control Language)
    - 트랜잭션 데이터의 영구 저장, 취소 등과 관련된 명령어
  - DCL(Data Control Language)
    - 데이터 사용 권한과 관련된 명령어



관계형 데이터베이스의 구성 요소

- 테이블
  - 2차원 표 형태의 데이터 저장 공간
  - 행: 저장하려는 **하나의 개체를 구성하는 여러 값**을 가로로 늘어뜨린 것
  - 열: 저장하려는 데이터를 **대표하는 이름과 공동 특성**
- 키
  - 수많은 데이터를 구별할 수 있는 유일한 값
  - **기본키**
    - 저장된 행을 식별할 수 있는 유일한 값
    - 값이 중복되지 않아야 함
    - NULL값을 가질 수 없음
    - 보통 후보키 중에 **개인 정보 노출이 가장 적은 데이터를 선정함**
  - 보조키
    - 후보키 중에 기본키로 지정되지 않은 값: 속성은 기본키와 같음
  - 외래키
    - 특정 테이블에 포함되어 있으면서 다른 테이블의 기본키로 지정된 키
    - 예) 학생 정보 테이블에 있는 학과 코드: 학과 정보 테이블과 학생 정보 테이블을 이어줌
  - 복합키
    - 여러 열을 조합하여 기본키 역할을 할 수 있게 만든 키
    - 예) 과목 정보 테이블에서 (과목코드+교수+강의시간) 조합으로 수업을 유일하게 식별함 



오라클 데이터베이스

- 대표적인 상용 관계형 데이터베이스 제품
- 자료형
  - 여러 자료형이 있지만 보통 **VARCHAR2, NUMBER, DATE** 세 가지만을 사용함
- 객체
  - 테이블: 데이터를 저장하는 장소
  - 인덱스: 테이블 검색 효율을 높이기 위해 사용
  - 뷰: 데이터를 논리적으로 연결하여 하나의 테이블**처럼** 사용하게 해줌
  - 시퀀스: 일련 번호를 생성해 줌
  - 시노님: 오라클 객체의 **별칭**을 지정함
  - 프로시저: 프로그래밍 연산 및 기능 수행, return 값 없음
  - 함수: 프로그래밍 연산 및 기능 수행, return 값 있음
  - 패키지: 관련 있는 프로시저와 함수를 보관함
  - 트리거: 데이터 관련 작업의 연결 및 방지 관련 기능 제공
- PL/SQL
  - SQL과 별도로 데이터 관리를 위해 만들어진 프로그래밍 언어
  - 프로그래밍 언어에서 제공하는 요소를(변수, 조건문, 반복문) 사용하여 데이터를 관리할 수 있음



### 1.2. NoSQL

> Not only SQL
>
> 비 관계형 데이터베이스 : 행과 열로 이루어진 테이블 형식 스키마를 사용하지 않는 DB를 통칭함



RDBMS vs NoSQL

- 관계형 데이터베이스
  - 
  - 장점
    -  트랜잭션을 통한 안정적인 데이터 관리
  - 단점
    - 데이터를 처리하는 데 필요한 비용의 증가로 빅데이터 처리가 어려움
    - 관계형 모델과 메모리 내 데이터 구조 간 데이터 불일치 : ORM을 통해 해결할 수 있음
- 비관계형 데이터베이스
  - 장점
    - 확장성 : JOIN 처리가 없기 때문에 스케일 아웃을 통한 노드 확장이 용이함
    - 유연성 : 가변적인 데이터구조로 데이터를 저장할 수 있음
  - 단점
    - 다양하고 복잡한 쿼리가 불가능함
    - 일관성을 항상 보장할 수 없음



NoSQL의 종류

- Key-value
- Document
- Column-family
- Graph



### 1.3. 인덱스



인덱스의 필요성

Full Table Scan

1개 데이터를 찾자고 100만개를 스캔하는 것은 매우 비효율적



인덱스는 메모리에 저장됨 : 페이지 단위로 관리됨



InnoDB?



인덱스의 구조와 원리

B-Tree

인덱스 range scan : 



인덱스는 언제 사용해야 할까

조회에는 효율적(조건절이 있을 때)

INSERT, UPDATE, DELETE에는 비효율적

INSERT : 정렬된 상태로 존재해야하기 때문에 

DELETE : 

인덱스에는 UPDATE 개념이 없어 DELETE한 후 INSERT하기 때문에 부하가 큼



인덱스 설정 기준

Cardinality가 높은 것 : 여러 튜플이 같은 값을 갖는 것은(성별) 이게 낮음



인덱스의 종류

- Clustered
  - 순서대로 데이터를 정렬 : 범위 검색에 강점이 있음
  - 테이블마다 단 하나만 존재할 수 있음
  - 새로 저장하면 뒤에 있는 데이터를 하나씩 다 밀어줘야 함
  - PK가 여기에 해당함
- Non-Clustered
  - 순서와 상관없이 데이터의 주소값만 저장
  - 한 테이블에 여러개가 존재 가능
  - INSERT시 추가 저장 공간이 필요 : 인덱스는 데이터 외의 공간에 저장(통상 10%)
  - 일반적으로 인덱스라고 하면 이걸 말함



## **2. DQL**

> SELECT 문을 이용하여 데이터베이스를 조회, 분석하기



데이터를 조회하는 3가지 방법

- SELECTION
  - **행 단위**로 원하는 데이터를 조회
- PROJECTION
  - **열 단위**로 원하는 데이터를 조회
  - SELECTION, PROJECTION을 함께 사용하여 상세하게 조회할 수도 있음
- JOIN
  - **두 개 이상의 테이블을 연결하여 하나의 테이블처럼 조회**
  - SELECT문을 사용할 때 자주 사용됨



### 2.1. SELECT문의 기본 형식



`SELECT [조회할 열1 이름], [열2], ..., [열N] FROM [조회할 테이블 이름];`

- 조회할 열 이름에 `*`를 넣으면 전체 열 조회 가능: `SELECT * FROM EMP;`
- 띄어쓰기와 줄 바꿈 활용
  - 명령 수행에 영향을 주지 않기 때문에 가독성을 위해 **SELECT와 FROM을 다른 줄에 적는 것 권장**



중복 제거

- DISTINCT를 이용하여 중복을 제거하고 특정 데이터 종류만 확인 가능

- ```SQL
  SELECT DISTINCT DEPTNO
  	FROM EMP;
  ```

- ALL을 이용하면 반대로 중복을 제거하지 않고 그대로 출력함

- ```SQL
  SELECT ALL DEPTNO
  	FROM EMP;
  ```



정렬

- ORDER BY를 사용하여 출력 데이터를 정렬함

- SELECT문의 제일 마지막에 `ORDER BY [정렬하려는 열(여러 개 가능)] [정렬 옵션]` 을 붙여 사용

  - 정렬 옵션은 ASC(기본 값), DESC 존재

  - ```SQL
    SELECT *
    	FROM EMP
    ORDER BY SAL;
    ```

  - 여러 개 조건을 붙이면 먼저 오는 열을 우선 정렬하고 값이 같으면 그 다음 열 기준으로 정렬

    - `ORDER BY DEPTNO DESC, ENAME;`

- 정렬은 느리기 때문에 **가능하면 사용하지 않을 것**을 권장



별칭 설정

- SELECT 절에 명시한 열 이름이 아니라 별칭이(alias) 출력되도록 할 수 있음

  - 편의를 위해 + 해당 열이 어떻게 도출되었는지 노출되지 않기 위해 사용함

- **별칭을 하나씩 지정**하는 방법과 **연산식을 사용**하는 방법 존재

  - 연산식을 사용하여 연수입 출력하기(월급*12 + 상여)

  - ```SQL
    SELECT ENAME, SAL, SAL*12+COMM, COMM
    	FROM EMP;
    ```

  - 별칭을 지정하는 방법

    - 4가지가 있는데 보통 3번째를 많이 사용(한 칸 띄우기, 한 칸 띄우고 큰 따옴표, **한 칸 띄우고 AS**, 한 칸 띄우고 AS 다음에 큰 따옴표 )
    - `SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP;`
    - SQL문에 따옴표 사용이 좋지 않기 때문: 프로그래밍 언어에서 문자열로 ("SQL") 사용 시 에러 발생



WHERE

- **특정 조건을 기준으로** 원하는 행을 출력

  - WHERE절에는 조건식이 들어감: 조건식이 참인 경우에만 출력

- FROM 다음에 WHERE 절을 이용함

  - ```SQL
    SELECT *
    	FROM EMP
    WHERE DEPTNO = 30;
    ```

  -  SQL문에서는 동등 연산자가 ==가 아니라 =임

- WHERE문과 함께 사용하는 연산자

  - **논리 연산자 AND, OR**을 이용하여 **여러 개의 조건식 적용도 가능**: 조건식 갯수는 무제한

    - 여러 개 조건식이 묶여 있을 때 NOT을 이용하여 한번에 뒤집는 경우 많음

  - **IN**을 이용하여 조건식 갯수를 줄일 수 있음

    - OR을 여러 개 사용한 경우

    - ```SQL
      SELECT *
      	FROM EMP
      WHERE JOB = 'MANAGER'
         OR JOB = 'SALESMAN'
         OR JOB = 'CLERK';
      ```

    - IN을 사용한 경우

    - ```SQL
      SELECT *
      	FROM EMP
      WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK');
      ```

  - **BETWEEN A AND B**를 이용하여 조회하기

    - ```SQL
      SELECT *
      	FROM EMP
      WHERE SAL BETWEEN 2000 AND 3000;
      ```

  - 일부 문자열이 포함된 데이터를 조회할 때 사용하는 **LIKE**

    - ENAME 열 값이 대문자 S로 시작하는 데이터를 조회하라는 SQL문

    - ```SQL
      SELECT *
      	FROM EMP
      WHERE ENAME LIKE 'S%';
      ```

    - 와일드 카드: ( `%, _` ) 특정 문자 또는 문자열을 대체함

  - **IS NULL**을 이용해 데이터가 NULL인 행을 조회하기

    - ```SQL
      SELECT *
      	FROM EMP
      WHERE COMM IS NULL;
      ```

    - NULL은 비교 연산자로 비교하면 결과 값도 NULL이 되기 때문에 IS NULL을 이용해야 함

  - **집합 연산자**

    - 두 개 이상의 SELECT문의 결과 값을 연결함
    - 열 갯수와 각각의 열의 자료형이 일치해야(열 이름은 달라도 ok)연결 가능
    - UNION: 합집합으로 묶음, 중복 제거
    - UNION ALL: 합집합으로 묶고 중복 제거하지 않음
    - MINUS: 차집합 - 먼저 작성한 SELECT문의 결과에서 다음 결과를 빼 줌
    - INTERSECT: 교집합



## **3. DML, DDL**





### 트랜잭션



트랜잭션이란?

- 하나의 그룹으로 처리되어야 하는 여러 **쿼리들을 묶은 작업의 논리적 단위**
  - 트랜잭션은 DML 쿼리들의 조합으로 구성됨
  - 예) 송금 트랜잭션 : 돈 보내는 사람의 잔고 UPDATE + 받는 사람의 잔고 UPDATE
  - 쿼리들을 논리적으로 그룹화하기 위해 **커밋**과 **롤백**이 이루어 짐
- 트랜잭션은 한 **작업의 완전성**을 보장함
  - 트랜잭션 내의 모든 처리대상 명령문들이 반드시 완전히 수행되어야 함
  - 어느 한 문장이라도 에러가 발생한다면 트랜잭션으로 묶인 전체 명령문은 모두 취소



트랜잭션의 성질 ACID

- Atomicity
  - 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 함
- Consistency
  - 트랜잭션은 발생 전후에 **데이터의 일관성**을 보장해야 함
  - 데이터의 일관성 : 한 데이터를 서로 다른 장소에서 참조했을 때 조회 결과가 일치하는 것
- Isolation
  - 각 트랜잭션은 서로 간섭 없이 실행되어야 함
- Durability
  - 트랜잭션이 종료되면 영구적으로 DB에 작업의 결과가 저장되어야 함
  - 이를 위해 트랜잭션 종료시 커밋 또는 롤백을 수행함



커밋과 롤백

- 트랜잭션을 논리적인 작업의 단위로 구분하기 위해  커밋과 롤백을 이용함
  - 이를 통해 **데이터 무결성**을 보장할 수 있음
- 커밋
  - 트랜잭션으로 묶인 모든 쿼리가 실행되어 성공하면 트랜잭션의 결과를 DB에 **영구적으로 저장**하는 작업
  - 영구적으로 변경하기 전에 데이터의 변경사항을 확인할 수 있음
  - DDL과 DCL 명령문이 수행되면 자동으로 커밋됨
- 롤백
  - 트랜잭션의 쿼리가 하나라도 실패하면 **실행 결과를 모두 취소하고 DB를 트랜잭션 실행 전의 상태로 되돌리는 것**
  - 컴퓨터가 다운되거나 SQL 프로그램이 비정상 종료되면 자동으로 롤백됨



데이터 무결성

- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 4가지 종류가 있음
  - 개체 **무결성** (Entity integrity) 
    - 모든 테이블이 기본 키 (primary key)로 선택된 필드 (column)를 가져야 함
    - 기본키로 선택된 필드는 빈 값을 허용하지 않음
  - 참조 **무결성** (Referential integrity) 
    - 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지함
    - FK의 값은 NULL이거나 참조하는 테이블의 PK 값 중 하나여야 함
  - 도메인 **무결성** (Domain integrity) 
    - 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 올바른 데이터가 입력됐는지를 체크하는 것
  - **사용자 정의 무결성** 규칙 (User-defined Integrity)
    - 사용자가 정의한 무결성 규칙으로 개체, 참조, 도메인 무결성에 포함되지 않는 것



#### isolation level

여러 트랜잭션이 동시에 DB에 접근할 때 어떻게 제어할지에 대한 설정

- isolation level에 따라 **성능을 얻기 위해서 정합성을 얼마나 포기할 것인지** 정함
- 데이터 정합성과 성능(동시성)은 trade-off 관계를 가지고 있음
  - ACID를 엄격히 지키면 성능 저하
  - ACID를 완벽히 지키는 4레벨부터(Serializable) 지키지 않는 1레벨까지 4단계 존재함



Read-Uncommitted

- 트랜잭션이 커밋 되기 전에 데이터가 변경된 내용을 다른 트랜잭션이 조회 가능
- **Dirty Read**, Non-Repeatable Read, Phantom Read 발생 가능
  - 한 트랜잭션이 수정한 데이터를 다른 트랜잭션이 조회한 후 롤백이 일어난 경우
  - 무효가 된 데이터를 읽고 처리했기 때문에 문제가 생김



Read-Committed

- 커밋이 완료된 트랜잭션의 변경 사항만 다른 트랜잭션에서 조회 가능
- 아직 커밋되지 않았다면 변경 전 데이터를, 커밋됐다면 변경 후의 데이터를 읽음
- **Non-Repeatable Read**, Phantom Read 발생 가능
  - 한 트랜잭션에서 수정하고 커밋한 데이터를 다른 트랜잭션에서 커밋 이전과 이후에 각각 조회한 경우
  - 두 번의 조회에 대해 값이 다르다는 문제가 생김



Repeatable-Read

- 한 트랜잭션이 조회한 데이터는 항상 동일함을 보장
- 조회를 한 번 했으면 트랜잭션 종료시까지 다른 트랜잭션이 변경하거나 삭제 불가
- **Phantom Read** 발생 가능
  - 어떤 범위의 레코드를 읽었을 때 첫 번째 쿼리에선 없던 데이터가 새로 생긴 경우



Serializable

- 한 트랜잭션에서 사용하는 데이터를 다른 트랜잭션에서 접근 불가



## **4. DL/SQL**



## 5. DB 실무

실제로 서비스 개발에서 어떤 식으로 DB를 다루는지 OJT에서 배운 내용을 바탕으로 작성



### 5.1. JDBC

> Java Database Connectivity
>
> DBMS 종류에 상관없이 DB를 조작할 수 있기 위해 사용하는 Java API임



코딩의 흐름

JDBC 드라이버 로드 > DB 연결 > DB 조작(SQL) > DB 연결 종료



JDBC 드라이버 로드 [공식문서](https://jdbc.postgresql.org/documentation/81/connect.html)

- JDBC 드라이버란?
  - 각 DBMS에 맞는 클라이언트
  - DBMS 별 드라이버가 필요함(`.jar` 파일)
    - JDBC가 실제로 하는 일은 없고(API니까...) 드라이버가 일을 함
- `Class.forName("JDBC Name");` 으로 로딩함 
  - 드라이버의 클래스를 객체화하여 로드



DB 연결

- 드라이버 매니저를 통해 연결 객체 획득
  
  - 서버 + DB 이름 + user 이름 + password를 전달
  
  - ```java
    String server = "127.0.0.1";
    String database = "chess";
    String userName = "jonghoon";
    String pwd = "4512";
    
    Connection con = DriverManager.getConnection(url: "jdbc:mysql://" + server + "/" + database + "?");
    return con;
    ```



DB 조작

- Preparedstatement 혹은 Statement를 이용하여 **SQL문을 전달해 DB를 조작**할 준비를 함
  - cf) JPA의 경우 java app 내에서 SQL을 적을 필요가 없음
  - `PreparedStatement pstmt = con.prepareStatement(sql);`
    - Preparedstatement의 경우 ?를 이용하여 sql문에 원하는 데이터를 세팅할 수 있음
    - 동일하거나 비슷한 sql문을 반복적으로 실행하기 위해 사용됨: **Cache를 이용**함 → 성능 좋음
    - 처음 실행될 때만 연결 생성 - 컴파일 - 실행 3단계를 거치고 이후에는 ?의 값만 바꿔서 실행됨
  - `Statement st = con.createStatement();`
    - SQL문 수행 과정에서 매번 컴파일이 일어나기 때문에 성능 안 좋음
  - 여기서 con은 위에서 생성한 DB 연결 객체임
- DB 조작 실행: execute, executeQuery, executeUpdate
  - `pstmt.execute();`
    - boolean 타입의 값을 반환함: 리턴 값이 ResultSet인 경우엔 true, 그 외엔 false
  - `pstmt.executeQuery();`
    - ResultSet 객체의 값을 반환함: SELECT 구문을 수행할 때 사용됨
  - `pstmt.executeUpdate();`
    - Int 타입의 값을 반환함: SELECT 이외의 구문을 수행할 때 사용됨(반영된 레코드의 건수를 반환)



결과값 획득, 종료

